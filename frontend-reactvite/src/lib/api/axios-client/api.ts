/* tslint:disable */
/* eslint-disable */
/**
 * Master KG Job Portal API
 * Master KG Job Portal API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { type AxiosPromise, type AxiosInstance, type AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Combined serializer for user account data and job portal profile.
 * @export
 * @interface AdvancedProfile
 */
export interface AdvancedProfile {
    /**
     * 
     * @type {AdvancedProfileUserData}
     * @memberof AdvancedProfile
     */
    'user_data': AdvancedProfileUserData;
    /**
     * 
     * @type {AdvancedProfileJobPortalProfile}
     * @memberof AdvancedProfile
     */
    'job_portal_profile': AdvancedProfileJobPortalProfile;
}
/**
 * 
 * @export
 * @interface AdvancedProfileJobPortalProfile
 */
export interface AdvancedProfileJobPortalProfile {
    /**
     * 
     * @type {number}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'user': number;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'date_of_birth'?: string | null;
    /**
     * 
     * @type {PatchedUserProfileUpdateGender}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'gender'?: PatchedUserProfileUpdateGender;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'postal_code'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'terms_accepted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'terms_accepted_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'preferred_language'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'notification_preferences'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'is_verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'verification_date': string | null;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileJobPortalProfile
     */
    'updated_at': string;
}
/**
 * Combined serializer for updating both user account and job portal profile.
 * @export
 * @interface AdvancedProfileUpdate
 */
export interface AdvancedProfileUpdate {
    /**
     * 
     * @type {UserUpdate}
     * @memberof AdvancedProfileUpdate
     */
    'user_data'?: UserUpdate;
    /**
     * 
     * @type {UserProfileUpdate}
     * @memberof AdvancedProfileUpdate
     */
    'job_portal_profile'?: UserProfileUpdate;
}
/**
 * 
 * @export
 * @interface AdvancedProfileUserData
 */
export interface AdvancedProfileUserData {
    /**
     * 
     * @type {number}
     * @memberof AdvancedProfileUserData
     */
    'id': number;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'date_joined': string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'last_login': string | null;
    /**
     * Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи.
     * @type {boolean}
     * @memberof AdvancedProfileUserData
     */
    'is_active'?: boolean;
    /**
     * Отметьте, если пользователь может входить в административную часть сайта.
     * @type {boolean}
     * @memberof AdvancedProfileUserData
     */
    'is_staff': boolean;
    /**
     * Указывает, что пользователь имеет все права без явного их назначения.
     * @type {boolean}
     * @memberof AdvancedProfileUserData
     */
    'is_superuser': boolean;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'groups': string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'permissions': string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'photo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdvancedProfileUserData
     */
    'photo_url'?: string | null;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Bid
 */
export interface Bid {
    /**
     * 
     * @type {number}
     * @memberof Bid
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Bid
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof Bid
     */
    'provider': number;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'provider_name': string;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof Bid
     */
    'estimated_duration'?: number | null;
    /**
     * 
     * @type {BidStatusEnum}
     * @memberof Bid
     */
    'status'?: BidStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Bid
     */
    'is_negotiable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'terms_conditions'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'created_at': string;
}
/**
 * Serializer for bid actions (accept/reject/withdraw).
 * @export
 * @interface BidAction
 */
export interface BidAction {
    /**
     * Reason for rejection/withdrawal
     * @type {string}
     * @memberof BidAction
     */
    'reason'?: string;
}
/**
 * Unified serializer for bid creation and updates.
 * @export
 * @interface BidCreateUpdate
 */
export interface BidCreateUpdate {
    /**
     * 
     * @type {string}
     * @memberof BidCreateUpdate
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof BidCreateUpdate
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof BidCreateUpdate
     */
    'estimated_duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BidCreateUpdate
     */
    'terms_conditions'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BidCreateUpdate
     */
    'is_negotiable'?: boolean;
}
/**
 * * `pending` - Pending * `accepted` - Accepted * `rejected` - Rejected * `withdrawn` - Withdrawn
 * @export
 * @enum {string}
 */

export enum BidStatusEnum {
    pending = 'pending',
    accepted = 'accepted',
    rejected = 'rejected',
    withdrawn = 'withdrawn'
}


/**
 * 
 * @export
 * @enum {string}
 */

export enum BlankEnum {
    empty = ''
}


/**
 * * `general` - General * `specialist` - Specialist * `reviews` - Reviews * `account` - Account * `search` - Найти * `safety` - Safety
 * @export
 * @enum {string}
 */

export enum CategoryEnum {
    general = 'general',
    specialist = 'specialist',
    reviews = 'reviews',
    account = 'account',
    search = 'search',
    safety = 'safety'
}


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Certificate
 */
export interface Certificate {
    /**
     * 
     * @type {number}
     * @memberof Certificate
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Certificate
     */
    'service_provider': number;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    'issuing_organization': string;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    'certificate_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    'issue_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    'expiry_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    'certificate_file'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Certificate
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    'updated_at': string;
}
/**
 * Mobile-optimized serializer for chat conversation list.
 * @export
 * @interface ChatConversation
 */
export interface ChatConversation {
    /**
     * 
     * @type {number}
     * @memberof ChatConversation
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ChatConversation
     */
    'title'?: string;
    /**
     * 
     * @type {ChatTypeEnum}
     * @memberof ChatConversation
     */
    'chat_type'?: ChatTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ChatConversation
     */
    'other_participant_name': string;
    /**
     * 
     * @type {string}
     * @memberof ChatConversation
     */
    'other_participant_avatar': string;
    /**
     * 
     * @type {string}
     * @memberof ChatConversation
     */
    'other_participant_online': string;
    /**
     * 
     * @type {string}
     * @memberof ChatConversation
     */
    'last_message_preview': string;
    /**
     * 
     * @type {string}
     * @memberof ChatConversation
     */
    'last_message_time': string;
    /**
     * 
     * @type {string}
     * @memberof ChatConversation
     */
    'service_category': string;
    /**
     * 
     * @type {string}
     * @memberof ChatConversation
     */
    'unread_count': string;
    /**
     * 
     * @type {boolean}
     * @memberof ChatConversation
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChatConversation
     */
    'created_at': string;
}
/**
 * Mobile-optimized serializer for chat conversation details with messages.
 * @export
 * @interface ChatConversationDetail
 */
export interface ChatConversationDetail {
    /**
     * 
     * @type {number}
     * @memberof ChatConversationDetail
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ChatConversationDetail
     */
    'title'?: string;
    /**
     * 
     * @type {ChatTypeEnum}
     * @memberof ChatConversationDetail
     */
    'chat_type'?: ChatTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ChatConversationDetail
     */
    'messages': string;
    /**
     * 
     * @type {string}
     * @memberof ChatConversationDetail
     */
    'other_participant_info': string;
    /**
     * 
     * @type {string}
     * @memberof ChatConversationDetail
     */
    'service_info': string;
    /**
     * 
     * @type {boolean}
     * @memberof ChatConversationDetail
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChatConversationDetail
     */
    'created_at': string;
}
/**
 * Serializer for sending messages via mobile API.
 * @export
 * @interface ChatSendMessage
 */
export interface ChatSendMessage {
    /**
     * Message content
     * @type {string}
     * @memberof ChatSendMessage
     */
    'message': string;
    /**
     * Message type  * `text` - Text * `image` - Image * `file` - File
     * @type {MessageTypeEnum}
     * @memberof ChatSendMessage
     */
    'message_type'?: MessageTypeEnum;
    /**
     * File attachment
     * @type {string}
     * @memberof ChatSendMessage
     */
    'attachment'?: string | null;
}
/**
 * * `order_chat` - Order Chat * `support_chat` - Support Chat * `general_chat` - General Chat
 * @export
 * @enum {string}
 */

export enum ChatTypeEnum {
    order_chat = 'order_chat',
    support_chat = 'support_chat',
    general_chat = 'general_chat'
}


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ClientUpdate
 */
export interface ClientUpdate {
    /**
     * 
     * @type {Array<number>}
     * @memberof ClientUpdate
     */
    'preferred_services'?: Array<number>;
}
/**
 * * `beginner` - Beginner * `intermediate` - Intermediate * `advanced` - Advanced * `expert` - Expert
 * @export
 * @enum {string}
 */

export enum ComplexityLevelEnum {
    beginner = 'beginner',
    intermediate = 'intermediate',
    advanced = 'advanced',
    expert = 'expert'
}


/**
 * Serializer for Firebase authentication request
 * @export
 * @interface FireBaseAuth
 */
export interface FireBaseAuth {
    /**
     * Firebase ID token
     * @type {string}
     * @memberof FireBaseAuth
     */
    'id_token': string;
}
/**
 * * `male` - Male * `female` - Female * `other` - Other * `prefer_not_to_say` - Prefer not to say
 * @export
 * @enum {string}
 */

export enum GenderEnum {
    male = 'male',
    female = 'female',
    other = 'other',
    prefer_not_to_say = 'prefer_not_to_say'
}


/**
 * Serializer for global search response.
 * @export
 * @interface GlobalSearchResponse
 */
export interface GlobalSearchResponse {
    /**
     * Search query
     * @type {string}
     * @memberof GlobalSearchResponse
     */
    'query': string;
    /**
     * Type of search performed
     * @type {string}
     * @memberof GlobalSearchResponse
     */
    'search_type': string;
    /**
     * Search results by category
     * @type {{ [key: string]: any; }}
     * @memberof GlobalSearchResponse
     */
    'results': { [key: string]: any; };
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'invoice_number': string;
    /**
     * 
     * @type {InvoiceStatusEnum}
     * @memberof Invoice
     */
    'status'?: InvoiceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'subtotal': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'platform_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'total_amount': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'due_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'paid_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface InvoiceCreate
 */
export interface InvoiceCreate {
    /**
     * 
     * @type {number}
     * @memberof InvoiceCreate
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCreate
     */
    'subtotal': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCreate
     */
    'platform_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCreate
     */
    'due_date'?: string | null;
}
/**
 * * `draft` - Draft * `sent` - Sent * `paid` - Paid * `overdue` - Overdue * `cancelled` - Cancelled
 * @export
 * @enum {string}
 */

export enum InvoiceStatusEnum {
    draft = 'draft',
    sent = 'sent',
    paid = 'paid',
    overdue = 'overdue',
    cancelled = 'cancelled'
}


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {number}
     * @memberof Language
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'native_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'flag_icon'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    'rtl_support'?: boolean;
}
/**
 * Serializer for logout response
 * @export
 * @interface LogoutResponse
 */
export interface LogoutResponse {
    /**
     * Logout confirmation message
     * @type {string}
     * @memberof LogoutResponse
     */
    'message': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface MasterSkill
 */
export interface MasterSkill {
    /**
     * 
     * @type {number}
     * @memberof MasterSkill
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof MasterSkill
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MasterSkill
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof MasterSkill
     */
    'category': number;
    /**
     * 
     * @type {boolean}
     * @memberof MasterSkill
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MasterSkill
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof MasterSkill
     */
    'updated_at': string;
}
/**
 * * `text` - Text * `image` - Image * `file` - File
 * @export
 * @enum {string}
 */

export enum MessageTypeEnum {
    text = 'text',
    image = 'image',
    file = 'file'
}


/**
 * * `credit_card` - Credit Card * `debit_card` - Debit Card * `bank_transfer` - Bank Transfer * `digital_wallet` - Digital Wallet
 * @export
 * @enum {string}
 */

export enum MethodTypeEnum {
    credit_card = 'credit_card',
    debit_card = 'debit_card',
    bank_transfer = 'bank_transfer',
    digital_wallet = 'digital_wallet'
}


/**
 * Serializer for UserNotification model.
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'user': number;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'message': string;
    /**
     * 
     * @type {NotificationTypeEnum}
     * @memberof Notification
     */
    'notification_type': NotificationTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'is_read'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'read_at': string | null;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'order'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'bid'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'created_at': string;
}
/**
 * Serializer for creating notifications.
 * @export
 * @interface NotificationCreate
 */
export interface NotificationCreate {
    /**
     * 
     * @type {number}
     * @memberof NotificationCreate
     */
    'user': number;
    /**
     * 
     * @type {string}
     * @memberof NotificationCreate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCreate
     */
    'message': string;
    /**
     * 
     * @type {NotificationTypeEnum}
     * @memberof NotificationCreate
     */
    'notification_type': NotificationTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof NotificationCreate
     */
    'order'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationCreate
     */
    'bid'?: number | null;
}
/**
 * * `bid_received` - Bid Received * `bid_accepted` - Bid Accepted * `bid_rejected` - Bid Rejected * `order_assigned` - Order Assigned * `order_completed` - Order Completed * `chat_message` - Chat Message * `system_alert` - System Alert
 * @export
 * @enum {string}
 */

export enum NotificationTypeEnum {
    bid_received = 'bid_received',
    bid_accepted = 'bid_accepted',
    bid_rejected = 'bid_rejected',
    order_assigned = 'order_assigned',
    order_completed = 'order_completed',
    chat_message = 'chat_message',
    system_alert = 'system_alert'
}


/**
 * Serializer for updating notification read status.
 * @export
 * @interface NotificationUpdate
 */
export interface NotificationUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof NotificationUpdate
     */
    'is_read'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationUpdate
     */
    'read_at'?: string | null;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'client': number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'client_name': string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'service_subcategory': number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'description': string;
    /**
     * 
     * @type {Status638Enum}
     * @memberof Order
     */
    'status'?: Status638Enum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'postal_code': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'service_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'service_time'?: string | null;
    /**
     * 
     * @type {UrgencyEnum}
     * @memberof Order
     */
    'urgency'?: UrgencyEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'budget_min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'budget_max'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'final_price'?: string | null;
    /**
     * 
     * @type {Array<Bid>}
     * @memberof Order
     */
    'bids': Array<Bid>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Order
     */
    'attachments'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'special_requirements'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'is_featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderAssignment
 */
export interface OrderAssignment {
    /**
     * 
     * @type {number}
     * @memberof OrderAssignment
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof OrderAssignment
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof OrderAssignment
     */
    'order_title': string;
    /**
     * 
     * @type {number}
     * @memberof OrderAssignment
     */
    'provider': number;
    /**
     * 
     * @type {string}
     * @memberof OrderAssignment
     */
    'provider_name': string;
    /**
     * 
     * @type {number}
     * @memberof OrderAssignment
     */
    'accepted_bid': number;
    /**
     * 
     * @type {string}
     * @memberof OrderAssignment
     */
    'assigned_at': string;
    /**
     * 
     * @type {string}
     * @memberof OrderAssignment
     */
    'start_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderAssignment
     */
    'start_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderAssignment
     */
    'progress_notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAssignment
     */
    'completion_notes'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderAssignment
     */
    'client_rating'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OrderAssignment
     */
    'client_review'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAssignment
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderCreate
 */
export interface OrderCreate {
    /**
     * 
     * @type {number}
     * @memberof OrderCreate
     */
    'service_subcategory': number;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'postal_code': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'service_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'service_time'?: string | null;
    /**
     * 
     * @type {UrgencyEnum}
     * @memberof OrderCreate
     */
    'urgency'?: UrgencyEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'budget_min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'budget_max'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'special_requirements'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderUpdate
 */
export interface OrderUpdate {
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'postal_code': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'service_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'service_time'?: string | null;
    /**
     * 
     * @type {UrgencyEnum}
     * @memberof OrderUpdate
     */
    'urgency'?: UrgencyEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'budget_min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'budget_max'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'special_requirements'?: string;
    /**
     * 
     * @type {Status638Enum}
     * @memberof OrderUpdate
     */
    'status'?: Status638Enum;
}
/**
 * 
 * @export
 * @interface PaginatedBidList
 */
export interface PaginatedBidList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBidList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBidList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBidList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Bid>}
     * @memberof PaginatedBidList
     */
    'results'?: Array<Bid>;
}
/**
 * 
 * @export
 * @interface PaginatedCertificateList
 */
export interface PaginatedCertificateList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCertificateList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCertificateList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCertificateList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Certificate>}
     * @memberof PaginatedCertificateList
     */
    'results'?: Array<Certificate>;
}
/**
 * 
 * @export
 * @interface PaginatedChatConversationList
 */
export interface PaginatedChatConversationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedChatConversationList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedChatConversationList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedChatConversationList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ChatConversation>}
     * @memberof PaginatedChatConversationList
     */
    'results'?: Array<ChatConversation>;
}
/**
 * 
 * @export
 * @interface PaginatedInvoiceList
 */
export interface PaginatedInvoiceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedInvoiceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInvoiceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInvoiceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof PaginatedInvoiceList
     */
    'results'?: Array<Invoice>;
}
/**
 * 
 * @export
 * @interface PaginatedLanguageList
 */
export interface PaginatedLanguageList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLanguageList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLanguageList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLanguageList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Language>}
     * @memberof PaginatedLanguageList
     */
    'results'?: Array<Language>;
}
/**
 * 
 * @export
 * @interface PaginatedMasterSkillList
 */
export interface PaginatedMasterSkillList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMasterSkillList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMasterSkillList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMasterSkillList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<MasterSkill>}
     * @memberof PaginatedMasterSkillList
     */
    'results'?: Array<MasterSkill>;
}
/**
 * 
 * @export
 * @interface PaginatedNotificationList
 */
export interface PaginatedNotificationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedNotificationList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotificationList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotificationList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof PaginatedNotificationList
     */
    'results'?: Array<Notification>;
}
/**
 * 
 * @export
 * @interface PaginatedOrderAssignmentList
 */
export interface PaginatedOrderAssignmentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOrderAssignmentList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderAssignmentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderAssignmentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OrderAssignment>}
     * @memberof PaginatedOrderAssignmentList
     */
    'results'?: Array<OrderAssignment>;
}
/**
 * 
 * @export
 * @interface PaginatedOrderList
 */
export interface PaginatedOrderList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOrderList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Order>}
     * @memberof PaginatedOrderList
     */
    'results'?: Array<Order>;
}
/**
 * 
 * @export
 * @interface PaginatedPaymentList
 */
export interface PaginatedPaymentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPaymentList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPaymentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPaymentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof PaginatedPaymentList
     */
    'results'?: Array<Payment>;
}
/**
 * 
 * @export
 * @interface PaginatedPaymentMethodList
 */
export interface PaginatedPaymentMethodList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPaymentMethodList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPaymentMethodList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPaymentMethodList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PaymentMethod>}
     * @memberof PaginatedPaymentMethodList
     */
    'results'?: Array<PaymentMethod>;
}
/**
 * 
 * @export
 * @interface PaginatedPortfolioItemList
 */
export interface PaginatedPortfolioItemList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPortfolioItemList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPortfolioItemList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPortfolioItemList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PortfolioItem>}
     * @memberof PaginatedPortfolioItemList
     */
    'results'?: Array<PortfolioItem>;
}
/**
 * 
 * @export
 * @interface PaginatedProfessionList
 */
export interface PaginatedProfessionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedProfessionList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProfessionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProfessionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Profession>}
     * @memberof PaginatedProfessionList
     */
    'results'?: Array<Profession>;
}
/**
 * 
 * @export
 * @interface PaginatedReviewList
 */
export interface PaginatedReviewList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedReviewList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedReviewList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedReviewList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Review>}
     * @memberof PaginatedReviewList
     */
    'results'?: Array<Review>;
}
/**
 * 
 * @export
 * @interface PaginatedServiceAreaList
 */
export interface PaginatedServiceAreaList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedServiceAreaList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceAreaList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceAreaList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ServiceArea>}
     * @memberof PaginatedServiceAreaList
     */
    'results'?: Array<ServiceArea>;
}
/**
 * 
 * @export
 * @interface PaginatedServiceCategoryList
 */
export interface PaginatedServiceCategoryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedServiceCategoryList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceCategoryList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceCategoryList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ServiceCategory>}
     * @memberof PaginatedServiceCategoryList
     */
    'results'?: Array<ServiceCategory>;
}
/**
 * 
 * @export
 * @interface PaginatedServiceProviderList
 */
export interface PaginatedServiceProviderList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedServiceProviderList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceProviderList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceProviderList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ServiceProvider>}
     * @memberof PaginatedServiceProviderList
     */
    'results'?: Array<ServiceProvider>;
}
/**
 * 
 * @export
 * @interface PaginatedServiceProviderSkillList
 */
export interface PaginatedServiceProviderSkillList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedServiceProviderSkillList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceProviderSkillList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceProviderSkillList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ServiceProviderSkill>}
     * @memberof PaginatedServiceProviderSkillList
     */
    'results'?: Array<ServiceProviderSkill>;
}
/**
 * 
 * @export
 * @interface PaginatedServiceSubcategoryList
 */
export interface PaginatedServiceSubcategoryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedServiceSubcategoryList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceSubcategoryList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceSubcategoryList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ServiceSubcategory>}
     * @memberof PaginatedServiceSubcategoryList
     */
    'results'?: Array<ServiceSubcategory>;
}
/**
 * 
 * @export
 * @interface PaginatedSupportFAQList
 */
export interface PaginatedSupportFAQList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupportFAQList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupportFAQList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupportFAQList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SupportFAQ>}
     * @memberof PaginatedSupportFAQList
     */
    'results'?: Array<SupportFAQ>;
}
/**
 * 
 * @export
 * @interface PaginatedSystemSettingsList
 */
export interface PaginatedSystemSettingsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSystemSettingsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSystemSettingsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSystemSettingsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SystemSettings>}
     * @memberof PaginatedSystemSettingsList
     */
    'results'?: Array<SystemSettings>;
}
/**
 * 
 * @export
 * @interface PaginatedUserListList
 */
export interface PaginatedUserListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<UserList>}
     * @memberof PaginatedUserListList
     */
    'results'?: Array<UserList>;
}
/**
 * Combined serializer for updating both user account and job portal profile.
 * @export
 * @interface PatchedAdvancedProfileUpdate
 */
export interface PatchedAdvancedProfileUpdate {
    /**
     * 
     * @type {UserUpdate}
     * @memberof PatchedAdvancedProfileUpdate
     */
    'user_data'?: UserUpdate;
    /**
     * 
     * @type {UserProfileUpdate}
     * @memberof PatchedAdvancedProfileUpdate
     */
    'job_portal_profile'?: UserProfileUpdate;
}
/**
 * Unified serializer for bid creation and updates.
 * @export
 * @interface PatchedBidCreateUpdate
 */
export interface PatchedBidCreateUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedBidCreateUpdate
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedBidCreateUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedBidCreateUpdate
     */
    'estimated_duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedBidCreateUpdate
     */
    'terms_conditions'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedBidCreateUpdate
     */
    'is_negotiable'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedClientUpdate
 */
export interface PatchedClientUpdate {
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedClientUpdate
     */
    'preferred_services'?: Array<number>;
}
/**
 * Serializer for updating notification read status.
 * @export
 * @interface PatchedNotificationUpdate
 */
export interface PatchedNotificationUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationUpdate
     */
    'is_read'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedNotificationUpdate
     */
    'read_at'?: string | null;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedOrderAssignment
 */
export interface PatchedOrderAssignment {
    /**
     * 
     * @type {number}
     * @memberof PatchedOrderAssignment
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedOrderAssignment
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderAssignment
     */
    'order_title'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOrderAssignment
     */
    'provider'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderAssignment
     */
    'provider_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOrderAssignment
     */
    'accepted_bid'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderAssignment
     */
    'assigned_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderAssignment
     */
    'start_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderAssignment
     */
    'start_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderAssignment
     */
    'progress_notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderAssignment
     */
    'completion_notes'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOrderAssignment
     */
    'client_rating'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderAssignment
     */
    'client_review'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderAssignment
     */
    'created_at'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedOrderUpdate
 */
export interface PatchedOrderUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'service_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'service_time'?: string | null;
    /**
     * 
     * @type {UrgencyEnum}
     * @memberof PatchedOrderUpdate
     */
    'urgency'?: UrgencyEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'budget_min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'budget_max'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'special_requirements'?: string;
    /**
     * 
     * @type {Status638Enum}
     * @memberof PatchedOrderUpdate
     */
    'status'?: Status638Enum;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedPaymentCreate
 */
export interface PatchedPaymentCreate {
    /**
     * 
     * @type {number}
     * @memberof PatchedPaymentCreate
     */
    'invoice'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPaymentCreate
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPaymentCreate
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPaymentCreate
     */
    'payment_method'?: number;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedPaymentMethodUpdate
 */
export interface PatchedPaymentMethodUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPaymentMethodUpdate
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPaymentMethodUpdate
     */
    'is_active'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedProviderStatistics
 */
export interface PatchedProviderStatistics {
    /**
     * 
     * @type {number}
     * @memberof PatchedProviderStatistics
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedProviderStatistics
     */
    'provider'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedProviderStatistics
     */
    'total_jobs_completed'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedProviderStatistics
     */
    'on_time_percentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedProviderStatistics
     */
    'repeat_customer_percentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedProviderStatistics
     */
    'average_rating'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedProviderStatistics
     */
    'total_reviews'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedProviderStatistics
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedProviderStatistics
     */
    'updated_at'?: string;
}
/**
 * Serializer for updating existing reviews.
 * @export
 * @interface PatchedReviewUpdate
 */
export interface PatchedReviewUpdate {
    /**
     * Overall rating from 1 to 5 stars
     * @type {number}
     * @memberof PatchedReviewUpdate
     */
    'overall_rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedReviewUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedReviewUpdate
     */
    'comment'?: string;
}
/**
 * Serializer for creating and updating service areas.
 * @export
 * @interface PatchedServiceAreaCreateUpdate
 */
export interface PatchedServiceAreaCreateUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'latitude'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'longitude'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'postal_codes'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'service_categories'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'base_price_multiplier'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceAreaCreateUpdate
     */
    'travel_fee'?: string;
}
/**
 * Serializer for creating and updating service categories.
 * @export
 * @interface PatchedServiceCategoryCreateUpdate
 */
export interface PatchedServiceCategoryCreateUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'icon'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'color'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'sort_order'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'banner_image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'min_price'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'max_price'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'estimated_duration_min'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'estimated_duration_max'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'meta_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'meta_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'keywords'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'slug'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'requires_license'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'requires_insurance'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceCategoryCreateUpdate
     */
    'requires_background_check'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedServiceProviderUpdate
 */
export interface PatchedServiceProviderUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceProviderUpdate
     */
    'business_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceProviderUpdate
     */
    'business_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceProviderUpdate
     */
    'profession'?: number | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedServiceProviderUpdate
     */
    'service_areas'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedServiceProviderUpdate
     */
    'services_offered'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceProviderUpdate
     */
    'works_remotely'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceProviderUpdate
     */
    'accepts_clients_at_location'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceProviderUpdate
     */
    'travels_to_clients'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceProviderUpdate
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceProviderUpdate
     */
    'hourly_rate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceProviderUpdate
     */
    'response_time_hours'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceProviderUpdate
     */
    'work_experience_start_year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceProviderUpdate
     */
    'education_institution'?: string;
    /**
     * e.g., 2005-2009
     * @type {string}
     * @memberof PatchedServiceProviderUpdate
     */
    'education_years'?: string;
    /**
     * List of languages spoken
     * @type {any}
     * @memberof PatchedServiceProviderUpdate
     */
    'languages'?: any;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceProviderUpdate
     */
    'about_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceProviderUpdate
     */
    'current_location'?: string;
}
/**
 * Serializer for creating and updating service subcategories.
 * @export
 * @interface PatchedServiceSubcategoryCreateUpdate
 */
export interface PatchedServiceSubcategoryCreateUpdate {
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'category'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'icon'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'sort_order'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'base_price'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'price_range_min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'price_range_max'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'estimated_duration'?: number | null;
    /**
     * 
     * @type {ComplexityLevelEnum}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'complexity_level'?: ComplexityLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'safety_requirements'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'meta_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceSubcategoryCreateUpdate
     */
    'meta_description'?: string;
}
/**
 * Serializer for creating and updating support FAQ items.
 * @export
 * @interface PatchedSupportFAQCreateUpdate
 */
export interface PatchedSupportFAQCreateUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedSupportFAQCreateUpdate
     */
    'question'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupportFAQCreateUpdate
     */
    'answer'?: string;
    /**
     * 
     * @type {CategoryEnum}
     * @memberof PatchedSupportFAQCreateUpdate
     */
    'category'?: CategoryEnum;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupportFAQCreateUpdate
     */
    'sort_order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSupportFAQCreateUpdate
     */
    'is_popular'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSupportFAQCreateUpdate
     */
    'is_active'?: boolean;
}
/**
 * Serializer for creating and updating system settings.
 * @export
 * @interface PatchedSystemSettingsCreateUpdate
 */
export interface PatchedSystemSettingsCreateUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedSystemSettingsCreateUpdate
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSystemSettingsCreateUpdate
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSystemSettingsCreateUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSystemSettingsCreateUpdate
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {SettingTypeEnum}
     * @memberof PatchedSystemSettingsCreateUpdate
     */
    'setting_type'?: SettingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedSystemSettingsCreateUpdate
     */
    'validation_regex'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSystemSettingsCreateUpdate
     */
    'min_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSystemSettingsCreateUpdate
     */
    'max_value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSystemSettingsCreateUpdate
     */
    'requires_admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedSystemSettingsCreateUpdate
     */
    'category'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedUserProfileUpdate
 */
export interface PatchedUserProfileUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'date_of_birth'?: string | null;
    /**
     * 
     * @type {PatchedUserProfileUpdateGender}
     * @memberof PatchedUserProfileUpdate
     */
    'gender'?: PatchedUserProfileUpdateGender;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'postal_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserProfileUpdate
     */
    'preferred_language'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof PatchedUserProfileUpdate
     */
    'notification_preferences'?: any;
}
/**
 * @type PatchedUserProfileUpdateGender
 * @export
 */
export type PatchedUserProfileUpdateGender = BlankEnum | GenderEnum;

/**
 * Serializer for updating user profile - enhanced version of api_users EditUserSettingsView
 * @export
 * @interface PatchedUserUpdate
 */
export interface PatchedUserUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'photo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'last_name'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'invoice': number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'currency'?: string;
    /**
     * 
     * @type {PaymentStatusEnum}
     * @memberof Payment
     */
    'status'?: PaymentStatusEnum;
    /**
     * 
     * @type {PaymentPaymentMethod}
     * @memberof Payment
     */
    'payment_method': PaymentPaymentMethod;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'stripe_payment_intent_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'stripe_charge_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'processed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PaymentCreate
 */
export interface PaymentCreate {
    /**
     * 
     * @type {number}
     * @memberof PaymentCreate
     */
    'invoice': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentCreate
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCreate
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentCreate
     */
    'payment_method': number;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    'user': number;
    /**
     * 
     * @type {MethodTypeEnum}
     * @memberof PaymentMethod
     */
    'method_type': MethodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'method_type_display': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'card_last4'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'card_brand'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    'card_exp_month'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    'card_exp_year'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    'is_active'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PaymentMethodCreate
 */
export interface PaymentMethodCreate {
    /**
     * 
     * @type {MethodTypeEnum}
     * @memberof PaymentMethodCreate
     */
    'method_type': MethodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCreate
     */
    'card_last4'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCreate
     */
    'card_brand'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodCreate
     */
    'card_exp_month'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodCreate
     */
    'card_exp_year'?: number | null;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PaymentMethodUpdate
 */
export interface PaymentMethodUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodUpdate
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodUpdate
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentPaymentMethod
 */
export interface PaymentPaymentMethod {
    /**
     * 
     * @type {number}
     * @memberof PaymentPaymentMethod
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentPaymentMethod
     */
    'user': number;
    /**
     * 
     * @type {MethodTypeEnum}
     * @memberof PaymentPaymentMethod
     */
    'method_type': MethodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentPaymentMethod
     */
    'method_type_display': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentPaymentMethod
     */
    'card_last4'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentPaymentMethod
     */
    'card_brand'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentPaymentMethod
     */
    'card_exp_month'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentPaymentMethod
     */
    'card_exp_year'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentPaymentMethod
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentPaymentMethod
     */
    'is_active'?: boolean;
}
/**
 * * `pending` - Pending * `processing` - Processing * `completed` - Completed * `failed` - Failed * `cancelled` - Cancelled * `refunded` - Refunded
 * @export
 * @enum {string}
 */

export enum PaymentStatusEnum {
    pending = 'pending',
    processing = 'processing',
    completed = 'completed',
    failed = 'failed',
    cancelled = 'cancelled',
    refunded = 'refunded'
}


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PortfolioItem
 */
export interface PortfolioItem {
    /**
     * 
     * @type {number}
     * @memberof PortfolioItem
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PortfolioItem
     */
    'service_provider': number;
    /**
     * 
     * @type {string}
     * @memberof PortfolioItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioItem
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioItem
     */
    'image': string;
    /**
     * 
     * @type {number}
     * @memberof PortfolioItem
     */
    'skill_used'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PortfolioItem
     */
    'is_featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortfolioItem
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioItem
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Profession
 */
export interface Profession {
    /**
     * 
     * @type {number}
     * @memberof Profession
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Profession
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Profession
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Profession
     */
    'category': number;
    /**
     * 
     * @type {boolean}
     * @memberof Profession
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Profession
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Profession
     */
    'updated_at': string;
}
/**
 * * `beginner` - Beginner * `intermediate` - Intermediate * `advanced` - Advanced * `expert` - Expert
 * @export
 * @enum {string}
 */

export enum ProficiencyLevelEnum {
    beginner = 'beginner',
    intermediate = 'intermediate',
    advanced = 'advanced',
    expert = 'expert'
}


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ProviderStatistics
 */
export interface ProviderStatistics {
    /**
     * 
     * @type {number}
     * @memberof ProviderStatistics
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ProviderStatistics
     */
    'provider': number;
    /**
     * 
     * @type {number}
     * @memberof ProviderStatistics
     */
    'total_jobs_completed'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProviderStatistics
     */
    'on_time_percentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderStatistics
     */
    'repeat_customer_percentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderStatistics
     */
    'average_rating'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProviderStatistics
     */
    'total_reviews'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProviderStatistics
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ProviderStatistics
     */
    'updated_at': string;
}
/**
 * Serializer for reading review data.
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'order_id': number;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'order_title': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'reviewer_name': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'reviewer_email': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'provider_name': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'provider_email': string;
    /**
     * Overall rating from 1 to 5 stars
     * @type {number}
     * @memberof Review
     */
    'overall_rating': number;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Review
     */
    'is_verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'updated_at': string;
}
/**
 * Serializer for review analytics data.
 * @export
 * @interface ReviewAnalytics
 */
export interface ReviewAnalytics {
    /**
     * 
     * @type {number}
     * @memberof ReviewAnalytics
     */
    'total_reviews': number;
    /**
     * 
     * @type {string}
     * @memberof ReviewAnalytics
     */
    'average_rating': string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ReviewAnalytics
     */
    'rating_distribution': Array<{ [key: string]: any; }>;
}
/**
 * Serializer for creating new reviews.
 * @export
 * @interface ReviewCreate
 */
export interface ReviewCreate {
    /**
     * 
     * @type {number}
     * @memberof ReviewCreate
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof ReviewCreate
     */
    'provider': number;
    /**
     * Overall rating from 1 to 5 stars
     * @type {number}
     * @memberof ReviewCreate
     */
    'overall_rating': number;
    /**
     * 
     * @type {string}
     * @memberof ReviewCreate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewCreate
     */
    'comment'?: string;
}
/**
 * Serializer for updating existing reviews.
 * @export
 * @interface ReviewUpdate
 */
export interface ReviewUpdate {
    /**
     * Overall rating from 1 to 5 stars
     * @type {number}
     * @memberof ReviewUpdate
     */
    'overall_rating': number;
    /**
     * 
     * @type {string}
     * @memberof ReviewUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewUpdate
     */
    'comment'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceArea
 */
export interface ServiceArea {
    /**
     * 
     * @type {number}
     * @memberof ServiceArea
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'latitude'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'longitude'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceArea
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'base_price_multiplier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'travel_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'coordinates': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ServiceArea
     */
    'service_categories': Array<number>;
}
/**
 * Serializer for creating and updating service areas.
 * @export
 * @interface ServiceAreaCreateUpdate
 */
export interface ServiceAreaCreateUpdate {
    /**
     * 
     * @type {string}
     * @memberof ServiceAreaCreateUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAreaCreateUpdate
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAreaCreateUpdate
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAreaCreateUpdate
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAreaCreateUpdate
     */
    'latitude'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServiceAreaCreateUpdate
     */
    'longitude'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ServiceAreaCreateUpdate
     */
    'postal_codes'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceAreaCreateUpdate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ServiceAreaCreateUpdate
     */
    'service_categories': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ServiceAreaCreateUpdate
     */
    'base_price_multiplier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAreaCreateUpdate
     */
    'travel_fee'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceCategory
 */
export interface ServiceCategory {
    /**
     * 
     * @type {number}
     * @memberof ServiceCategory
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'icon'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'color'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCategory
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategory
     */
    'sort_order'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'banner_image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCategory
     */
    'featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'slug'?: string;
    /**
     * 
     * @type {Array<ServiceSubcategory>}
     * @memberof ServiceCategory
     */
    'subcategories': Array<ServiceSubcategory>;
}
/**
 * Serializer for creating and updating service categories.
 * @export
 * @interface ServiceCategoryCreateUpdate
 */
export interface ServiceCategoryCreateUpdate {
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'icon'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'color'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCategoryCreateUpdate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategoryCreateUpdate
     */
    'sort_order'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'banner_image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCategoryCreateUpdate
     */
    'featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'min_price'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'max_price'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategoryCreateUpdate
     */
    'estimated_duration_min'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategoryCreateUpdate
     */
    'estimated_duration_max'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'meta_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'meta_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'keywords'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryCreateUpdate
     */
    'slug'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCategoryCreateUpdate
     */
    'requires_license'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCategoryCreateUpdate
     */
    'requires_insurance'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCategoryCreateUpdate
     */
    'requires_background_check'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceProvider
 */
export interface ServiceProvider {
    /**
     * 
     * @type {number}
     * @memberof ServiceProvider
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ServiceProvider
     */
    'user_profile': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'business_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'business_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceProvider
     */
    'profession'?: number | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof ServiceProvider
     */
    'service_areas'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ServiceProvider
     */
    'services_offered'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProvider
     */
    'works_remotely'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProvider
     */
    'accepts_clients_at_location'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProvider
     */
    'travels_to_clients'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProvider
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'hourly_rate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ServiceProvider
     */
    'response_time_hours'?: number;
    /**
     * 
     * @type {number}
     * @memberof ServiceProvider
     */
    'work_experience_start_year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'education_institution'?: string;
    /**
     * e.g., 2005-2009
     * @type {string}
     * @memberof ServiceProvider
     */
    'education_years'?: string;
    /**
     * List of languages spoken
     * @type {any}
     * @memberof ServiceProvider
     */
    'languages'?: any;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'about_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'current_location'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProvider
     */
    'is_online'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'last_seen'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProvider
     */
    'is_verified_provider': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProvider
     */
    'is_top_master': boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'updated_at': string;
}
/**
 * Enhanced serializer for detailed provider view with related data.
 * @export
 * @interface ServiceProviderDetail
 */
export interface ServiceProviderDetail {
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderDetail
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderDetail
     */
    'user_profile': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetail
     */
    'business_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetail
     */
    'business_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderDetail
     */
    'profession'?: number | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof ServiceProviderDetail
     */
    'service_areas'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ServiceProviderDetail
     */
    'services_offered'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderDetail
     */
    'works_remotely'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderDetail
     */
    'accepts_clients_at_location'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderDetail
     */
    'travels_to_clients'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderDetail
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetail
     */
    'hourly_rate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderDetail
     */
    'response_time_hours'?: number;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderDetail
     */
    'work_experience_start_year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetail
     */
    'education_institution'?: string;
    /**
     * e.g., 2005-2009
     * @type {string}
     * @memberof ServiceProviderDetail
     */
    'education_years'?: string;
    /**
     * List of languages spoken
     * @type {any}
     * @memberof ServiceProviderDetail
     */
    'languages'?: any;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetail
     */
    'about_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetail
     */
    'current_location'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderDetail
     */
    'is_online'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetail
     */
    'last_seen'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderDetail
     */
    'is_verified_provider': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderDetail
     */
    'is_top_master': boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetail
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<ServiceProviderSkill>}
     * @memberof ServiceProviderDetail
     */
    'provider_skills': Array<ServiceProviderSkill>;
    /**
     * 
     * @type {Array<PortfolioItem>}
     * @memberof ServiceProviderDetail
     */
    'portfolio_items': Array<PortfolioItem>;
    /**
     * 
     * @type {Array<Certificate>}
     * @memberof ServiceProviderDetail
     */
    'certificates': Array<Certificate>;
    /**
     * 
     * @type {ServiceProviderDetailStatistics}
     * @memberof ServiceProviderDetail
     */
    'statistics': ServiceProviderDetailStatistics;
}
/**
 * 
 * @export
 * @interface ServiceProviderDetailStatistics
 */
export interface ServiceProviderDetailStatistics {
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderDetailStatistics
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderDetailStatistics
     */
    'provider': number;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderDetailStatistics
     */
    'total_jobs_completed'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetailStatistics
     */
    'on_time_percentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetailStatistics
     */
    'repeat_customer_percentage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetailStatistics
     */
    'average_rating'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderDetailStatistics
     */
    'total_reviews'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetailStatistics
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderDetailStatistics
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceProviderSkill
 */
export interface ServiceProviderSkill {
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderSkill
     */
    'id': number;
    /**
     * 
     * @type {ServiceProviderSkillSkill}
     * @memberof ServiceProviderSkill
     */
    'skill': ServiceProviderSkillSkill;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderSkill
     */
    'skill_id': number;
    /**
     * 
     * @type {ProficiencyLevelEnum}
     * @memberof ServiceProviderSkill
     */
    'proficiency_level'?: ProficiencyLevelEnum;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderSkill
     */
    'years_of_experience'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderSkill
     */
    'is_primary_skill'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderSkill
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderSkill
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ServiceProviderSkillSkill
 */
export interface ServiceProviderSkillSkill {
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderSkillSkill
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderSkillSkill
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderSkillSkill
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderSkillSkill
     */
    'category': number;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderSkillSkill
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderSkillSkill
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderSkillSkill
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceProviderUpdate
 */
export interface ServiceProviderUpdate {
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderUpdate
     */
    'business_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderUpdate
     */
    'business_description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderUpdate
     */
    'profession'?: number | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof ServiceProviderUpdate
     */
    'service_areas'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ServiceProviderUpdate
     */
    'services_offered'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderUpdate
     */
    'works_remotely'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderUpdate
     */
    'accepts_clients_at_location'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderUpdate
     */
    'travels_to_clients'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderUpdate
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderUpdate
     */
    'hourly_rate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderUpdate
     */
    'response_time_hours'?: number;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderUpdate
     */
    'work_experience_start_year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderUpdate
     */
    'education_institution'?: string;
    /**
     * e.g., 2005-2009
     * @type {string}
     * @memberof ServiceProviderUpdate
     */
    'education_years'?: string;
    /**
     * List of languages spoken
     * @type {any}
     * @memberof ServiceProviderUpdate
     */
    'languages'?: any;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderUpdate
     */
    'about_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderUpdate
     */
    'current_location'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceSubcategory
 */
export interface ServiceSubcategory {
    /**
     * 
     * @type {number}
     * @memberof ServiceSubcategory
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'icon'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceSubcategory
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServiceSubcategory
     */
    'sort_order'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceSubcategory
     */
    'featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'base_price'?: string | null;
    /**
     * 
     * @type {ComplexityLevelEnum}
     * @memberof ServiceSubcategory
     */
    'complexity_level'?: ComplexityLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'complexity_level_display': string;
}
/**
 * Serializer for creating and updating service subcategories.
 * @export
 * @interface ServiceSubcategoryCreateUpdate
 */
export interface ServiceSubcategoryCreateUpdate {
    /**
     * 
     * @type {number}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'category': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'icon'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'sort_order'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'base_price'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'price_range_min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'price_range_max'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'estimated_duration'?: number | null;
    /**
     * 
     * @type {ComplexityLevelEnum}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'complexity_level'?: ComplexityLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'safety_requirements'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'meta_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategoryCreateUpdate
     */
    'meta_description'?: string;
}
/**
 * * `string` - String * `integer` - Целое * `boolean` - Boolean * `json` - JSON * `file` - Файл
 * @export
 * @enum {string}
 */

export enum SettingTypeEnum {
    string = 'string',
    integer = 'integer',
    boolean = 'boolean',
    json = 'json',
    file = 'file'
}


/**
 * * `draft` - Draft * `published` - Published * `bidding` - Bidding * `assigned` - Assigned * `in_progress` - In Progress * `completed` - Completed * `cancelled` - Cancelled * `disputed` - Disputed
 * @export
 * @enum {string}
 */

export enum Status638Enum {
    draft = 'draft',
    published = 'published',
    bidding = 'bidding',
    assigned = 'assigned',
    in_progress = 'in_progress',
    completed = 'completed',
    cancelled = 'cancelled',
    disputed = 'disputed'
}


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface StripeWebhookEvent
 */
export interface StripeWebhookEvent {
    /**
     * 
     * @type {number}
     * @memberof StripeWebhookEvent
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StripeWebhookEvent
     */
    'stripe_event_id': string;
    /**
     * 
     * @type {string}
     * @memberof StripeWebhookEvent
     */
    'event_type': string;
    /**
     * 
     * @type {any}
     * @memberof StripeWebhookEvent
     */
    'event_data'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof StripeWebhookEvent
     */
    'processed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StripeWebhookEvent
     */
    'processed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StripeWebhookEvent
     */
    'error_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripeWebhookEvent
     */
    'created_at': string;
}
/**
 * Serializer for support FAQ items.
 * @export
 * @interface SupportFAQ
 */
export interface SupportFAQ {
    /**
     * 
     * @type {number}
     * @memberof SupportFAQ
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SupportFAQ
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof SupportFAQ
     */
    'answer': string;
    /**
     * 
     * @type {CategoryEnum}
     * @memberof SupportFAQ
     */
    'category'?: CategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof SupportFAQ
     */
    'category_display': string;
    /**
     * 
     * @type {number}
     * @memberof SupportFAQ
     */
    'language'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SupportFAQ
     */
    'sort_order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SupportFAQ
     */
    'is_popular'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupportFAQ
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SupportFAQ
     */
    'view_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof SupportFAQ
     */
    'created_at': string;
}
/**
 * Serializer for creating and updating support FAQ items.
 * @export
 * @interface SupportFAQCreateUpdate
 */
export interface SupportFAQCreateUpdate {
    /**
     * 
     * @type {string}
     * @memberof SupportFAQCreateUpdate
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof SupportFAQCreateUpdate
     */
    'answer': string;
    /**
     * 
     * @type {CategoryEnum}
     * @memberof SupportFAQCreateUpdate
     */
    'category'?: CategoryEnum;
    /**
     * 
     * @type {number}
     * @memberof SupportFAQCreateUpdate
     */
    'sort_order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SupportFAQCreateUpdate
     */
    'is_popular'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SupportFAQCreateUpdate
     */
    'is_active'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface SystemSettings
 */
export interface SystemSettings {
    /**
     * 
     * @type {number}
     * @memberof SystemSettings
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SystemSettings
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemSettings
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {SettingTypeEnum}
     * @memberof SystemSettings
     */
    'setting_type'?: SettingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    'setting_type_display': string;
}
/**
 * Serializer for creating and updating system settings.
 * @export
 * @interface SystemSettingsCreateUpdate
 */
export interface SystemSettingsCreateUpdate {
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsCreateUpdate
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsCreateUpdate
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsCreateUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SystemSettingsCreateUpdate
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {SettingTypeEnum}
     * @memberof SystemSettingsCreateUpdate
     */
    'setting_type'?: SettingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsCreateUpdate
     */
    'validation_regex'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsCreateUpdate
     */
    'min_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsCreateUpdate
     */
    'max_value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SystemSettingsCreateUpdate
     */
    'requires_admin'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemSettingsCreateUpdate
     */
    'category'?: string;
}
/**
 * * `low` - Low * `medium` - Medium * `high` - High * `urgent` - Urgent
 * @export
 * @enum {string}
 */

export enum UrgencyEnum {
    low = 'low',
    medium = 'medium',
    high = 'high',
    urgent = 'urgent'
}


/**
 * Serializer for listing users - not in api_users, useful for admin
 * @export
 * @interface UserList
 */
export interface UserList {
    /**
     * 
     * @type {number}
     * @memberof UserList
     */
    'id': number;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof UserList
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'email': string;
    /**
     * Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи.
     * @type {boolean}
     * @memberof UserList
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'date_joined': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'groups': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'photo_url'?: string | null;
    /**
     * 
     * @type {UserTypeEnum}
     * @memberof UserList
     */
    'user_type'?: UserTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserList
     */
    'blocked'?: boolean;
}
/**
 * Serializer for user profile information - enhanced version of api_users
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    'id': number;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof UserProfile
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'date_joined': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'last_login': string | null;
    /**
     * Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи.
     * @type {boolean}
     * @memberof UserProfile
     */
    'is_active'?: boolean;
    /**
     * Отметьте, если пользователь может входить в административную часть сайта.
     * @type {boolean}
     * @memberof UserProfile
     */
    'is_staff': boolean;
    /**
     * Указывает, что пользователь имеет все права без явного их назначения.
     * @type {boolean}
     * @memberof UserProfile
     */
    'is_superuser': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'groups': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'permissions': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'photo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'photo_url'?: string | null;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface UserProfileDetail
 */
export interface UserProfileDetail {
    /**
     * 
     * @type {number}
     * @memberof UserProfileDetail
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof UserProfileDetail
     */
    'user': number;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'date_of_birth'?: string | null;
    /**
     * 
     * @type {PatchedUserProfileUpdateGender}
     * @memberof UserProfileDetail
     */
    'gender'?: PatchedUserProfileUpdateGender;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'postal_code'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileDetail
     */
    'terms_accepted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'terms_accepted_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserProfileDetail
     */
    'preferred_language'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof UserProfileDetail
     */
    'notification_preferences'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileDetail
     */
    'is_verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'verification_date': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface UserProfileUpdate
 */
export interface UserProfileUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'date_of_birth'?: string | null;
    /**
     * 
     * @type {PatchedUserProfileUpdateGender}
     * @memberof UserProfileUpdate
     */
    'gender'?: PatchedUserProfileUpdateGender;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'postal_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserProfileUpdate
     */
    'preferred_language'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof UserProfileUpdate
     */
    'notification_preferences'?: any;
}
/**
 * * `free` - Бесплатный * `paid` - Оплаченный * `premium_paid` - Премиум оплаченный
 * @export
 * @enum {string}
 */

export enum UserTypeEnum {
    free = 'free',
    paid = 'paid',
    premium_paid = 'premium_paid'
}


/**
 * Serializer for updating user profile - enhanced version of api_users EditUserSettingsView
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'photo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'last_name'?: string;
}
/**
 * Serializer for WebSocket connection information.
 * @export
 * @interface WebSocketInfo
 */
export interface WebSocketInfo {
    /**
     * Base WebSocket URL
     * @type {string}
     * @memberof WebSocketInfo
     */
    'websocket_url': string;
    /**
     * Temporary token for WebSocket connection
     * @type {string}
     * @memberof WebSocketInfo
     */
    'temp_token': string;
    /**
     * User ID for WebSocket connection
     * @type {number}
     * @memberof WebSocketInfo
     */
    'user_id': number;
}
/**
 * Serializer for webhook response.
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * Webhook processing status
     * @type {string}
     * @memberof WebhookResponse
     */
    'status': string;
    /**
     * Additional message
     * @type {string}
     * @memberof WebhookResponse
     */
    'message'?: string;
}
/**
 * Serializer for webhook retry response.
 * @export
 * @interface WebhookRetryResponse
 */
export interface WebhookRetryResponse {
    /**
     * Retry processing status
     * @type {string}
     * @memberof WebhookRetryResponse
     */
    'status': string;
    /**
     * Additional message
     * @type {string}
     * @memberof WebhookRetryResponse
     */
    'message'?: string;
}

/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve dashboard data specific to clients including top providers, service categories, and recent orders.
         * @summary Get client dashboard data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientDashboard: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dashboard/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve dashboard data specific to service providers including statistics, portfolio, reviews, and professional information.
         * @summary Get provider dashboard data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerDashboard: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dashboard/provider/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve dashboard data specific to clients including top providers, service categories, and recent orders.
         * @summary Get client dashboard data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientDashboard(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientDashboard(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve dashboard data specific to service providers including statistics, portfolio, reviews, and professional information.
         * @summary Get provider dashboard data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerDashboard(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerDashboard(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * Retrieve dashboard data specific to clients including top providers, service categories, and recent orders.
         * @summary Get client dashboard data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientDashboard(options?: any): AxiosPromise<void> {
            return localVarFp.clientDashboard(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve dashboard data specific to service providers including statistics, portfolio, reviews, and professional information.
         * @summary Get provider dashboard data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerDashboard(options?: any): AxiosPromise<void> {
            return localVarFp.providerDashboard(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - interface
 * @export
 * @interface DashboardApi
 */
export interface DashboardApiInterface {
    /**
     * Retrieve dashboard data specific to clients including top providers, service categories, and recent orders.
     * @summary Get client dashboard data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApiInterface
     */
    clientDashboard(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve dashboard data specific to service providers including statistics, portfolio, reviews, and professional information.
     * @summary Get provider dashboard data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApiInterface
     */
    providerDashboard(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI implements DashboardApiInterface {
    /**
     * Retrieve dashboard data specific to clients including top providers, service categories, and recent orders.
     * @summary Get client dashboard data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public clientDashboard(options?: AxiosRequestConfig) {
        return DashboardApiFp(this.configuration).clientDashboard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve dashboard data specific to service providers including statistics, portfolio, reviews, and professional information.
     * @summary Get provider dashboard data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public providerDashboard(options?: AxiosRequestConfig) {
        return DashboardApiFp(this.configuration).providerDashboard(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(format, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.schemaRetrieve(format, lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - interface
 * @export
 * @interface SchemaApi
 */
export interface SchemaApiInterface {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'json' | 'yaml'} [format] 
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApiInterface
     */
    schemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

}

/**
 * Request parameters for schemaRetrieve operation in SchemaApi.
 * @export
 * @interface SchemaApiSchemaRetrieveRequest
 */
export interface SchemaApiSchemaRetrieveRequest {
    /**
     * 
     * @type {'json' | 'yaml'}
     * @memberof SchemaApiSchemaRetrieve
     */
    readonly format?: 'json' | 'yaml'

    /**
     * 
     * @type {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'}
     * @memberof SchemaApiSchemaRetrieve
     */
    readonly lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'
}

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI implements SchemaApiInterface {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {SchemaApiSchemaRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(requestParameters: SchemaApiSchemaRetrieveRequest = {}, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaRetrieve(requestParameters.format, requestParameters.lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1Api - axios parameter creator
 * @export
 */
export const V1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate user with Firebase ID token or register new user if verified.
         * @param {FireBaseAuth} fireBaseAuth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthFirebaseCreate: async (fireBaseAuth: FireBaseAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fireBaseAuth' is not null or undefined
            assertParamExists('v1AuthFirebaseCreate', 'fireBaseAuth', fireBaseAuth)
            const localVarPath = `/api/v1/auth/firebase/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fireBaseAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User logout view - enhanced version of api_users LogOutView
         * @param {LogoutResponse} logoutResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLogoutCreate: async (logoutResponse: LogoutResponse, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logoutResponse' is not null or undefined
            assertParamExists('v1AuthLogoutCreate', 'logoutResponse', logoutResponse)
            const localVarPath = `/api/v1/auth/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logoutResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mobile-optimized view for chat conversation list.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatConversationsList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/conversations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mobile-optimized view for chat conversation details with messages.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatConversationsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatConversationsRetrieve', 'id', id)
            const localVarPath = `/api/v1/chat/conversations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a message to a chat room.
         * @param {number} id 
         * @param {ChatSendMessage} chatSendMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatConversationsSendCreate: async (id: number, chatSendMessage: ChatSendMessage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatConversationsSendCreate', 'id', id)
            // verify required parameter 'chatSendMessage' is not null or undefined
            assertParamExists('v1ChatConversationsSendCreate', 'chatSendMessage', chatSendMessage)
            const localVarPath = `/api/v1/chat/conversations/{id}/send/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatSendMessage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get WebSocket connection info for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatWebsocketInfoRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/websocket-info/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Languages - Read-only (managed via admin/fixtures).
         * @param {boolean} [isActive] 
         * @param {boolean} [isDefault] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreLanguagesList: async (isActive?: boolean, isDefault?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/languages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['is_default'] = isDefault;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Languages - Read-only (managed via admin/fixtures).
         * @param {number} id A unique integer value identifying this Language.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreLanguagesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreLanguagesRetrieve', 'id', id)
            const localVarPath = `/api/v1/core/languages/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {ServiceAreaCreateUpdate} serviceAreaCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasCreate: async (serviceAreaCreateUpdate: ServiceAreaCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAreaCreateUpdate' is not null or undefined
            assertParamExists('v1CoreServiceAreasCreate', 'serviceAreaCreateUpdate', serviceAreaCreateUpdate)
            const localVarPath = `/api/v1/core/service-areas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceAreaCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceAreasDestroy', 'id', id)
            const localVarPath = `/api/v1/core/service-areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasList: async (isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/service-areas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {PatchedServiceAreaCreateUpdate} [patchedServiceAreaCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasPartialUpdate: async (id: number, patchedServiceAreaCreateUpdate?: PatchedServiceAreaCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceAreasPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/core/service-areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedServiceAreaCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceAreasRetrieve', 'id', id)
            const localVarPath = `/api/v1/core/service-areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {ServiceAreaCreateUpdate} serviceAreaCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasUpdate: async (id: number, serviceAreaCreateUpdate: ServiceAreaCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceAreasUpdate', 'id', id)
            // verify required parameter 'serviceAreaCreateUpdate' is not null or undefined
            assertParamExists('v1CoreServiceAreasUpdate', 'serviceAreaCreateUpdate', serviceAreaCreateUpdate)
            const localVarPath = `/api/v1/core/service-areas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceAreaCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {ServiceCategoryCreateUpdate} serviceCategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesCreate: async (serviceCategoryCreateUpdate: ServiceCategoryCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCategoryCreateUpdate' is not null or undefined
            assertParamExists('v1CoreServiceCategoriesCreate', 'serviceCategoryCreateUpdate', serviceCategoryCreateUpdate)
            const localVarPath = `/api/v1/core/service-categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceCategoryCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceCategoriesDestroy', 'id', id)
            const localVarPath = `/api/v1/core/service-categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesList: async (featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/service-categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {PatchedServiceCategoryCreateUpdate} [patchedServiceCategoryCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesPartialUpdate: async (id: number, patchedServiceCategoryCreateUpdate?: PatchedServiceCategoryCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceCategoriesPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/core/service-categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedServiceCategoryCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceCategoriesRetrieve', 'id', id)
            const localVarPath = `/api/v1/core/service-categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {ServiceCategoryCreateUpdate} serviceCategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesUpdate: async (id: number, serviceCategoryCreateUpdate: ServiceCategoryCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceCategoriesUpdate', 'id', id)
            // verify required parameter 'serviceCategoryCreateUpdate' is not null or undefined
            assertParamExists('v1CoreServiceCategoriesUpdate', 'serviceCategoryCreateUpdate', serviceCategoryCreateUpdate)
            const localVarPath = `/api/v1/core/service-categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceCategoryCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {ServiceSubcategoryCreateUpdate} serviceSubcategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesCreate: async (serviceSubcategoryCreateUpdate: ServiceSubcategoryCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceSubcategoryCreateUpdate' is not null or undefined
            assertParamExists('v1CoreServiceSubcategoriesCreate', 'serviceSubcategoryCreateUpdate', serviceSubcategoryCreateUpdate)
            const localVarPath = `/api/v1/core/service-subcategories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceSubcategoryCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceSubcategoriesDestroy', 'id', id)
            const localVarPath = `/api/v1/core/service-subcategories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} [category] 
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesList: async (category?: number, featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/service-subcategories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {PatchedServiceSubcategoryCreateUpdate} [patchedServiceSubcategoryCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesPartialUpdate: async (id: number, patchedServiceSubcategoryCreateUpdate?: PatchedServiceSubcategoryCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceSubcategoriesPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/core/service-subcategories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedServiceSubcategoryCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceSubcategoriesRetrieve', 'id', id)
            const localVarPath = `/api/v1/core/service-subcategories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {ServiceSubcategoryCreateUpdate} serviceSubcategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesUpdate: async (id: number, serviceSubcategoryCreateUpdate: ServiceSubcategoryCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreServiceSubcategoriesUpdate', 'id', id)
            // verify required parameter 'serviceSubcategoryCreateUpdate' is not null or undefined
            assertParamExists('v1CoreServiceSubcategoriesUpdate', 'serviceSubcategoryCreateUpdate', serviceSubcategoryCreateUpdate)
            const localVarPath = `/api/v1/core/service-subcategories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceSubcategoryCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {SupportFAQCreateUpdate} supportFAQCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqCreate: async (supportFAQCreateUpdate: SupportFAQCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supportFAQCreateUpdate' is not null or undefined
            assertParamExists('v1CoreSupportFaqCreate', 'supportFAQCreateUpdate', supportFAQCreateUpdate)
            const localVarPath = `/api/v1/core/support/faq/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supportFAQCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreSupportFaqDestroy', 'id', id)
            const localVarPath = `/api/v1/core/support/faq/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {'account' | 'general' | 'reviews' | 'safety' | 'search' | 'specialist'} [category] * &#x60;general&#x60; - General * &#x60;specialist&#x60; - Specialist * &#x60;reviews&#x60; - Reviews * &#x60;account&#x60; - Account * &#x60;search&#x60; - Найти * &#x60;safety&#x60; - Safety
         * @param {boolean} [isActive] 
         * @param {number} [language] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqList: async (category?: 'account' | 'general' | 'reviews' | 'safety' | 'search' | 'specialist', isActive?: boolean, language?: number, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/support/faq/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {PatchedSupportFAQCreateUpdate} [patchedSupportFAQCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqPartialUpdate: async (id: number, patchedSupportFAQCreateUpdate?: PatchedSupportFAQCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreSupportFaqPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/core/support/faq/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupportFAQCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreSupportFaqRetrieve', 'id', id)
            const localVarPath = `/api/v1/core/support/faq/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {SupportFAQCreateUpdate} supportFAQCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqUpdate: async (id: number, supportFAQCreateUpdate: SupportFAQCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreSupportFaqUpdate', 'id', id)
            // verify required parameter 'supportFAQCreateUpdate' is not null or undefined
            assertParamExists('v1CoreSupportFaqUpdate', 'supportFAQCreateUpdate', supportFAQCreateUpdate)
            const localVarPath = `/api/v1/core/support/faq/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supportFAQCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {SystemSettingsCreateUpdate} systemSettingsCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsCreate: async (systemSettingsCreateUpdate: SystemSettingsCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemSettingsCreateUpdate' is not null or undefined
            assertParamExists('v1CoreSystemSettingsCreate', 'systemSettingsCreateUpdate', systemSettingsCreateUpdate)
            const localVarPath = `/api/v1/core/system-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemSettingsCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreSystemSettingsDestroy', 'id', id)
            const localVarPath = `/api/v1/core/system-settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {string} [category] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsList: async (category?: string, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/system-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {PatchedSystemSettingsCreateUpdate} [patchedSystemSettingsCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsPartialUpdate: async (id: number, patchedSystemSettingsCreateUpdate?: PatchedSystemSettingsCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreSystemSettingsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/core/system-settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSystemSettingsCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreSystemSettingsRetrieve', 'id', id)
            const localVarPath = `/api/v1/core/system-settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {SystemSettingsCreateUpdate} systemSettingsCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsUpdate: async (id: number, systemSettingsCreateUpdate: SystemSettingsCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CoreSystemSettingsUpdate', 'id', id)
            // verify required parameter 'systemSettingsCreateUpdate' is not null or undefined
            assertParamExists('v1CoreSystemSettingsUpdate', 'systemSettingsCreateUpdate', systemSettingsCreateUpdate)
            const localVarPath = `/api/v1/core/system-settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemSettingsCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get notification counts for current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsCountRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/count/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new notifications (admin only).
         * @param {NotificationCreate} notificationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsCreateCreate: async (notificationCreate: NotificationCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationCreate' is not null or undefined
            assertParamExists('v1NotificationsCreateCreate', 'notificationCreate', notificationCreate)
            const localVarPath = `/api/v1/notifications/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List notifications for the current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all notifications as read for current user.
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsMarkAllReadCreate: async (notification: Notification, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('v1NotificationsMarkAllReadCreate', 'notification', notification)
            const localVarPath = `/api/v1/notifications/mark-all-read/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve and update individual notifications.
         * @param {number} id 
         * @param {PatchedNotificationUpdate} [patchedNotificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsPartialUpdate: async (id: number, patchedNotificationUpdate?: PatchedNotificationUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotificationsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/notifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedNotificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent notifications (last 7 days).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsRecentList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/recent/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve and update individual notifications.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotificationsRetrieve', 'id', id)
            const localVarPath = `/api/v1/notifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get unread notifications for current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsUnreadList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/unread/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve and update individual notifications.
         * @param {number} id 
         * @param {NotificationUpdate} [notificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsUpdate: async (id: number, notificationUpdate?: NotificationUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotificationsUpdate', 'id', id)
            const localVarPath = `/api/v1/notifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all order assignments (admin view).
         * @param {number} [order] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [provider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersAssignmentsList: async (order?: number, ordering?: string, page?: number, pageSize?: number, provider?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/assignments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View and update order assignment details.
         * @param {number} id 
         * @param {PatchedOrderAssignment} [patchedOrderAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersAssignmentsPartialUpdate: async (id: number, patchedOrderAssignment?: PatchedOrderAssignment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersAssignmentsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/orders/assignments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOrderAssignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View and update order assignment details.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersAssignmentsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersAssignmentsRetrieve', 'id', id)
            const localVarPath = `/api/v1/orders/assignments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View and update order assignment details.
         * @param {number} id 
         * @param {OrderAssignment} orderAssignment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersAssignmentsUpdate: async (id: number, orderAssignment: OrderAssignment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersAssignmentsUpdate', 'id', id)
            // verify required parameter 'orderAssignment' is not null or undefined
            assertParamExists('v1OrdersAssignmentsUpdate', 'orderAssignment', orderAssignment)
            const localVarPath = `/api/v1/orders/assignments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderAssignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept a bid and create order assignment.
         * @param {number} bidId 
         * @param {BidAction} [bidAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsAcceptCreate: async (bidId: number, bidAction?: BidAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bidId' is not null or undefined
            assertParamExists('v1OrdersBidsAcceptCreate', 'bidId', bidId)
            const localVarPath = `/api/v1/orders/bids/{bid_id}/accept/`
                .replace(`{${"bid_id"}}`, encodeURIComponent(String(bidId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bidAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} orderId 
         * @param {BidCreateUpdate} bidCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsCreate: async (orderId: number, bidCreateUpdate: BidCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1OrdersBidsCreate', 'orderId', orderId)
            // verify required parameter 'bidCreateUpdate' is not null or undefined
            assertParamExists('v1OrdersBidsCreate', 'bidCreateUpdate', bidCreateUpdate)
            const localVarPath = `/api/v1/orders/{order_id}/bids/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bidCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersBidsDestroy', 'id', id)
            const localVarPath = `/api/v1/orders/bids/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all bids (admin view).
         * @param {boolean} [isNegotiable] 
         * @param {number} [order] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'accepted' | 'pending' | 'rejected' | 'withdrawn'} [status] * &#x60;pending&#x60; - Pending * &#x60;accepted&#x60; - Accepted * &#x60;rejected&#x60; - Rejected * &#x60;withdrawn&#x60; - Withdrawn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsList: async (isNegotiable?: boolean, order?: number, ordering?: string, page?: number, pageSize?: number, status?: 'accepted' | 'pending' | 'rejected' | 'withdrawn', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/bids/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isNegotiable !== undefined) {
                localVarQueryParameter['is_negotiable'] = isNegotiable;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedBidCreateUpdate} [patchedBidCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsPartialUpdate: async (id: number, patchedBidCreateUpdate?: PatchedBidCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersBidsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/orders/bids/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBidCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reject a bid.
         * @param {number} bidId 
         * @param {BidAction} [bidAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsRejectCreate: async (bidId: number, bidAction?: BidAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bidId' is not null or undefined
            assertParamExists('v1OrdersBidsRejectCreate', 'bidId', bidId)
            const localVarPath = `/api/v1/orders/bids/{bid_id}/reject/`
                .replace(`{${"bid_id"}}`, encodeURIComponent(String(bidId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bidAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersBidsRetrieve', 'id', id)
            const localVarPath = `/api/v1/orders/bids/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {BidCreateUpdate} bidCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsUpdate: async (id: number, bidCreateUpdate: BidCreateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersBidsUpdate', 'id', id)
            // verify required parameter 'bidCreateUpdate' is not null or undefined
            assertParamExists('v1OrdersBidsUpdate', 'bidCreateUpdate', bidCreateUpdate)
            const localVarPath = `/api/v1/orders/bids/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bidCreateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw a bid (by provider).
         * @param {number} bidId 
         * @param {BidAction} [bidAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsWithdrawCreate: async (bidId: number, bidAction?: BidAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bidId' is not null or undefined
            assertParamExists('v1OrdersBidsWithdrawCreate', 'bidId', bidId)
            const localVarPath = `/api/v1/orders/bids/{bid_id}/withdraw/`
                .replace(`{${"bid_id"}}`, encodeURIComponent(String(bidId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bidAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersCreateCreate: async (orderCreate: OrderCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderCreate' is not null or undefined
            assertParamExists('v1OrdersCreateCreate', 'orderCreate', orderCreate)
            const localVarPath = `/api/v1/orders/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all orders (admin view).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {number} [serviceSubcategory] 
         * @param {'assigned' | 'bidding' | 'cancelled' | 'completed' | 'disputed' | 'draft' | 'in_progress' | 'published'} [status] * &#x60;draft&#x60; - Draft * &#x60;published&#x60; - Published * &#x60;bidding&#x60; - Bidding * &#x60;assigned&#x60; - Assigned * &#x60;in_progress&#x60; - In Progress * &#x60;completed&#x60; - Completed * &#x60;cancelled&#x60; - Cancelled * &#x60;disputed&#x60; - Disputed
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersList: async (ordering?: string, page?: number, pageSize?: number, search?: string, serviceSubcategory?: number, status?: 'assigned' | 'bidding' | 'cancelled' | 'completed' | 'disputed' | 'draft' | 'in_progress' | 'published', urgency?: 'high' | 'low' | 'medium' | 'urgent', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (serviceSubcategory !== undefined) {
                localVarQueryParameter['service_subcategory'] = serviceSubcategory;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (urgency !== undefined) {
                localVarQueryParameter['urgency'] = urgency;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user\'s assignments (as service provider).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersMyAssignmentsList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/my-assignments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user\'s bids (as service provider).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersMyBidsList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/my-bids/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user\'s orders (as client).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersMyList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/my/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get assignments for current user\'s orders (as client).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersMyOrdersAssignmentsList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/my-orders/assignments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get bids for current user\'s orders (as client).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersMyOrdersBidsList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/my-orders/bids/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedOrderUpdate} [patchedOrderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersPartialUpdate: async (id: number, patchedOrderUpdate?: PatchedOrderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/orders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOrderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersRetrieve', 'id', id)
            const localVarPath = `/api/v1/orders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {OrderUpdate} orderUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersUpdate: async (id: number, orderUpdate: OrderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersUpdate', 'id', id)
            // verify required parameter 'orderUpdate' is not null or undefined
            assertParamExists('v1OrdersUpdate', 'orderUpdate', orderUpdate)
            const localVarPath = `/api/v1/orders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsCreateCreate: async (paymentCreate: PaymentCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentCreate' is not null or undefined
            assertParamExists('v1PaymentsCreateCreate', 'paymentCreate', paymentCreate)
            const localVarPath = `/api/v1/payments/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {InvoiceCreate} invoiceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesCreateCreate: async (invoiceCreate: InvoiceCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceCreate' is not null or undefined
            assertParamExists('v1PaymentsInvoicesCreateCreate', 'invoiceCreate', invoiceCreate)
            const localVarPath = `/api/v1/payments/invoices/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/invoices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsInvoicesRetrieve', 'id', id)
            const localVarPath = `/api/v1/payments/invoices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PaymentMethodCreate} paymentMethodCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsCreateCreate: async (paymentMethodCreate: PaymentMethodCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodCreate' is not null or undefined
            assertParamExists('v1PaymentsMethodsCreateCreate', 'paymentMethodCreate', paymentMethodCreate)
            const localVarPath = `/api/v1/payments/methods/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentMethodCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsMethodsDestroy', 'id', id)
            const localVarPath = `/api/v1/payments/methods/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/methods/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedPaymentMethodUpdate} [patchedPaymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsPartialUpdate: async (id: number, patchedPaymentMethodUpdate?: PatchedPaymentMethodUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsMethodsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/payments/methods/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPaymentMethodUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsMethodsRetrieve', 'id', id)
            const localVarPath = `/api/v1/payments/methods/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PaymentMethodUpdate} [paymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsUpdate: async (id: number, paymentMethodUpdate?: PaymentMethodUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsMethodsUpdate', 'id', id)
            const localVarPath = `/api/v1/payments/methods/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentMethodUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedPaymentCreate} [patchedPaymentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsPartialUpdate: async (id: number, patchedPaymentCreate?: PatchedPaymentCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/payments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPaymentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsRetrieve', 'id', id)
            const localVarPath = `/api/v1/payments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsUpdate: async (id: number, paymentCreate: PaymentCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsUpdate', 'id', id)
            // verify required parameter 'paymentCreate' is not null or undefined
            assertParamExists('v1PaymentsUpdate', 'paymentCreate', paymentCreate)
            const localVarPath = `/api/v1/payments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List webhook events.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksEventsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/webhooks/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retry processing a webhook event.
         * @param {number} eventId 
         * @param {WebhookRetryResponse} webhookRetryResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksEventsRetryCreate: async (eventId: number, webhookRetryResponse: WebhookRetryResponse, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('v1PaymentsWebhooksEventsRetryCreate', 'eventId', eventId)
            // verify required parameter 'webhookRetryResponse' is not null or undefined
            assertParamExists('v1PaymentsWebhooksEventsRetryCreate', 'webhookRetryResponse', webhookRetryResponse)
            const localVarPath = `/api/v1/payments/webhooks/events/{event_id}/retry/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRetryResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API view for Stripe webhook handling.
         * @param {WebhookResponse} webhookResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksStripeDrfCreate: async (webhookResponse: WebhookResponse, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookResponse' is not null or undefined
            assertParamExists('v1PaymentsWebhooksStripeDrfCreate', 'webhookResponse', webhookResponse)
            const localVarPath = `/api/v1/payments/webhooks/stripe/drf/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload profile image
         * @param {UserUpdate} [userUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileCreate: async (userUpdate?: UserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User profile view with image upload
         * @param {PatchedUserUpdate} [patchedUserUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfilePartialUpdate: async (patchedUserUpdate?: PatchedUserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User profile view with image upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User profile view with image upload
         * @param {UserUpdate} [userUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileUpdate: async (userUpdate?: UserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get review analytics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsAnalyticsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/reviews/analytics/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List and create reviews.
         * @param {ReviewCreate} reviewCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsCreate: async (reviewCreate: ReviewCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewCreate' is not null or undefined
            assertParamExists('v1ReviewsCreate', 'reviewCreate', reviewCreate)
            const localVarPath = `/api/v1/reviews/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ReviewsDestroy', 'id', id)
            const localVarPath = `/api/v1/reviews/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List and create reviews.
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsList: async (isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/reviews/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isVerified !== undefined) {
                localVarQueryParameter['is_verified'] = isVerified;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (overallRating !== undefined) {
                localVarQueryParameter['overall_rating'] = overallRating;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get reviews for a specific order.
         * @param {number} orderId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsOrderList: async (orderId: number, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1ReviewsOrderList', 'orderId', orderId)
            const localVarPath = `/api/v1/reviews/order/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {PatchedReviewUpdate} [patchedReviewUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsPartialUpdate: async (id: number, patchedReviewUpdate?: PatchedReviewUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ReviewsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/reviews/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedReviewUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get reviews for a specific service provider.
         * @param {number} providerId 
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsProviderList: async (providerId: number, isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('v1ReviewsProviderList', 'providerId', providerId)
            const localVarPath = `/api/v1/reviews/provider/{provider_id}/`
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isVerified !== undefined) {
                localVarQueryParameter['is_verified'] = isVerified;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (overallRating !== undefined) {
                localVarQueryParameter['overall_rating'] = overallRating;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ReviewsRetrieve', 'id', id)
            const localVarPath = `/api/v1/reviews/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {ReviewUpdate} reviewUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsUpdate: async (id: number, reviewUpdate: ReviewUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ReviewsUpdate', 'id', id)
            // verify required parameter 'reviewUpdate' is not null or undefined
            assertParamExists('v1ReviewsUpdate', 'reviewUpdate', reviewUpdate)
            const localVarPath = `/api/v1/reviews/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple global search across all content types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchGlobalRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/global/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search specifically for orders (job vacancies).
         * @param {string} [city] Filter by city
         * @param {number} [maxBudget] Maximum budget
         * @param {number} [minBudget] Minimum budget
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {number} [serviceCategory] Filter by service category ID
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchOrdersList: async (city?: string, maxBudget?: number, minBudget?: number, ordering?: string, page?: number, pageSize?: number, q?: string, serviceCategory?: number, urgency?: 'high' | 'low' | 'medium' | 'urgent', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (maxBudget !== undefined) {
                localVarQueryParameter['max_budget'] = maxBudget;
            }

            if (minBudget !== undefined) {
                localVarQueryParameter['min_budget'] = minBudget;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (serviceCategory !== undefined) {
                localVarQueryParameter['service_category'] = serviceCategory;
            }

            if (urgency !== undefined) {
                localVarQueryParameter['urgency'] = urgency;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search specifically for service providers.
         * @param {string} [city] Filter by city
         * @param {number} [minRating] Minimum rating
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchProvidersList: async (city?: string, minRating?: number, ordering?: string, page?: number, pageSize?: number, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (minRating !== undefined) {
                localVarQueryParameter['min_rating'] = minRating;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all users - not in api_users, useful for admin
         * @param {boolean} [blocked] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {'free' | 'paid' | 'premium_paid'} [userType] * &#x60;free&#x60; - Бесплатный * &#x60;paid&#x60; - Оплаченный * &#x60;premium_paid&#x60; - Премиум оплаченный
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersList: async (blocked?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, userType?: 'free' | 'paid' | 'premium_paid', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (blocked !== undefined) {
                localVarQueryParameter['blocked'] = blocked;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (userType !== undefined) {
                localVarQueryParameter['user_type'] = userType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage my service provider certificates.
         * @param {Certificate} certificate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyCertificatesCreate: async (certificate: Certificate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificate' is not null or undefined
            assertParamExists('v1UsersMyCertificatesCreate', 'certificate', certificate)
            const localVarPath = `/api/v1/users/my/certificates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(certificate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage my service provider certificates.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyCertificatesList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/certificates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ClientUpdate} [clientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyClientCreateCreate: async (clientUpdate?: ClientUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/client/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedClientUpdate} [patchedClientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyClientUpdatePartialUpdate: async (patchedClientUpdate?: PatchedClientUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/client/update/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedClientUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ClientUpdate} [clientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyClientUpdateUpdate: async (clientUpdate?: ClientUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/client/update/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage my service provider portfolio items.
         * @param {PortfolioItem} portfolioItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyPortfolioCreate: async (portfolioItem: PortfolioItem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioItem' is not null or undefined
            assertParamExists('v1UsersMyPortfolioCreate', 'portfolioItem', portfolioItem)
            const localVarPath = `/api/v1/users/my/portfolio/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(portfolioItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage my service provider portfolio items.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyPortfolioList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/portfolio/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedAdvancedProfileUpdate} [patchedAdvancedProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfileAdvancedPartialUpdate: async (patchedAdvancedProfileUpdate?: PatchedAdvancedProfileUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/profile/advanced/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAdvancedProfileUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfileAdvancedRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/profile/advanced/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {AdvancedProfileUpdate} [advancedProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfileAdvancedUpdate: async (advancedProfileUpdate?: AdvancedProfileUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/profile/advanced/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(advancedProfileUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedUserProfileUpdate} [patchedUserProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfilePartialUpdate: async (patchedUserProfileUpdate?: PatchedUserProfileUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserProfileUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfileRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {UserProfileUpdate} [userProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfileUpdate: async (userProfileUpdate?: UserProfileUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProviderCreateCreate: async (serviceProviderUpdate?: ServiceProviderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/provider/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceProviderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProviderUpdatePartialUpdate: async (patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/provider/update/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedServiceProviderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProviderUpdateUpdate: async (serviceProviderUpdate?: ServiceProviderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/provider/update/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceProviderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage my service provider skills.
         * @param {ServiceProviderSkill} serviceProviderSkill 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMySkillsCreate: async (serviceProviderSkill: ServiceProviderSkill, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceProviderSkill' is not null or undefined
            assertParamExists('v1UsersMySkillsCreate', 'serviceProviderSkill', serviceProviderSkill)
            const localVarPath = `/api/v1/users/my/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceProviderSkill, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage my service provider skills.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMySkillsList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage my provider statistics.
         * @param {PatchedProviderStatistics} [patchedProviderStatistics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyStatisticsPartialUpdate: async (patchedProviderStatistics?: PatchedProviderStatistics, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/statistics/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedProviderStatistics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage my provider statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyStatisticsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/statistics/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manage my provider statistics.
         * @param {ProviderStatistics} [providerStatistics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyStatisticsUpdate: async (providerStatistics?: ProviderStatistics, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/my/statistics/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(providerStatistics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available professions.
         * @param {number} [category] 
         * @param {boolean} [isActive] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfessionsList: async (category?: number, isActive?: boolean, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/professions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProvidersDetailsPartialUpdate: async (id: number, patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1UsersProvidersDetailsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/users/providers/{id}/details/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedServiceProviderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProvidersDetailsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1UsersProvidersDetailsRetrieve', 'id', id)
            const localVarPath = `/api/v1/users/providers/{id}/details/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProvidersDetailsUpdate: async (id: number, serviceProviderUpdate?: ServiceProviderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1UsersProvidersDetailsUpdate', 'id', id)
            const localVarPath = `/api/v1/users/providers/{id}/details/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceProviderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available skills for service providers.
         * @param {number} [category] 
         * @param {boolean} [isActive] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersSkillsList: async (category?: number, isActive?: boolean, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/skills/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1Api - functional programming interface
 * @export
 */
export const V1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate user with Firebase ID token or register new user if verified.
         * @param {FireBaseAuth} fireBaseAuth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthFirebaseCreate(fireBaseAuth: FireBaseAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireBaseAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthFirebaseCreate(fireBaseAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User logout view - enhanced version of api_users LogOutView
         * @param {LogoutResponse} logoutResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthLogoutCreate(logoutResponse: LogoutResponse, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthLogoutCreate(logoutResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mobile-optimized view for chat conversation list.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatConversationsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChatConversationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatConversationsList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mobile-optimized view for chat conversation details with messages.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatConversationsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatConversationDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatConversationsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a message to a chat room.
         * @param {number} id 
         * @param {ChatSendMessage} chatSendMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatConversationsSendCreate(id: number, chatSendMessage: ChatSendMessage, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatSendMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatConversationsSendCreate(id, chatSendMessage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get WebSocket connection info for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatWebsocketInfoRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebSocketInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatWebsocketInfoRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Languages - Read-only (managed via admin/fixtures).
         * @param {boolean} [isActive] 
         * @param {boolean} [isDefault] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreLanguagesList(isActive?: boolean, isDefault?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLanguageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreLanguagesList(isActive, isDefault, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Languages - Read-only (managed via admin/fixtures).
         * @param {number} id A unique integer value identifying this Language.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreLanguagesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Language>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreLanguagesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {ServiceAreaCreateUpdate} serviceAreaCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceAreasCreate(serviceAreaCreateUpdate: ServiceAreaCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAreaCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceAreasCreate(serviceAreaCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceAreasDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceAreasDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceAreasList(isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedServiceAreaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceAreasList(isActive, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {PatchedServiceAreaCreateUpdate} [patchedServiceAreaCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceAreasPartialUpdate(id: number, patchedServiceAreaCreateUpdate?: PatchedServiceAreaCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAreaCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceAreasPartialUpdate(id, patchedServiceAreaCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceAreasRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceArea>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceAreasRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {ServiceAreaCreateUpdate} serviceAreaCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceAreasUpdate(id: number, serviceAreaCreateUpdate: ServiceAreaCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAreaCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceAreasUpdate(id, serviceAreaCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {ServiceCategoryCreateUpdate} serviceCategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceCategoriesCreate(serviceCategoryCreateUpdate: ServiceCategoryCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceCategoryCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceCategoriesCreate(serviceCategoryCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceCategoriesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceCategoriesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceCategoriesList(featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedServiceCategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceCategoriesList(featured, isActive, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {PatchedServiceCategoryCreateUpdate} [patchedServiceCategoryCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceCategoriesPartialUpdate(id: number, patchedServiceCategoryCreateUpdate?: PatchedServiceCategoryCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceCategoryCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceCategoriesPartialUpdate(id, patchedServiceCategoryCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceCategoriesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceCategoriesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {ServiceCategoryCreateUpdate} serviceCategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceCategoriesUpdate(id: number, serviceCategoryCreateUpdate: ServiceCategoryCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceCategoryCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceCategoriesUpdate(id, serviceCategoryCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {ServiceSubcategoryCreateUpdate} serviceSubcategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceSubcategoriesCreate(serviceSubcategoryCreateUpdate: ServiceSubcategoryCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceSubcategoryCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceSubcategoriesCreate(serviceSubcategoryCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceSubcategoriesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceSubcategoriesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} [category] 
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceSubcategoriesList(category?: number, featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedServiceSubcategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceSubcategoriesList(category, featured, isActive, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {PatchedServiceSubcategoryCreateUpdate} [patchedServiceSubcategoryCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceSubcategoriesPartialUpdate(id: number, patchedServiceSubcategoryCreateUpdate?: PatchedServiceSubcategoryCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceSubcategoryCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceSubcategoriesPartialUpdate(id, patchedServiceSubcategoryCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceSubcategoriesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceSubcategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceSubcategoriesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {ServiceSubcategoryCreateUpdate} serviceSubcategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceSubcategoriesUpdate(id: number, serviceSubcategoryCreateUpdate: ServiceSubcategoryCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceSubcategoryCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceSubcategoriesUpdate(id, serviceSubcategoryCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {SupportFAQCreateUpdate} supportFAQCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSupportFaqCreate(supportFAQCreateUpdate: SupportFAQCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportFAQCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSupportFaqCreate(supportFAQCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSupportFaqDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSupportFaqDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {'account' | 'general' | 'reviews' | 'safety' | 'search' | 'specialist'} [category] * &#x60;general&#x60; - General * &#x60;specialist&#x60; - Specialist * &#x60;reviews&#x60; - Reviews * &#x60;account&#x60; - Account * &#x60;search&#x60; - Найти * &#x60;safety&#x60; - Safety
         * @param {boolean} [isActive] 
         * @param {number} [language] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSupportFaqList(category?: 'account' | 'general' | 'reviews' | 'safety' | 'search' | 'specialist', isActive?: boolean, language?: number, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupportFAQList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSupportFaqList(category, isActive, language, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {PatchedSupportFAQCreateUpdate} [patchedSupportFAQCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSupportFaqPartialUpdate(id: number, patchedSupportFAQCreateUpdate?: PatchedSupportFAQCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportFAQCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSupportFaqPartialUpdate(id, patchedSupportFAQCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSupportFaqRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportFAQ>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSupportFaqRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {SupportFAQCreateUpdate} supportFAQCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSupportFaqUpdate(id: number, supportFAQCreateUpdate: SupportFAQCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportFAQCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSupportFaqUpdate(id, supportFAQCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {SystemSettingsCreateUpdate} systemSettingsCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSystemSettingsCreate(systemSettingsCreateUpdate: SystemSettingsCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemSettingsCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSystemSettingsCreate(systemSettingsCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSystemSettingsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSystemSettingsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {string} [category] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSystemSettingsList(category?: string, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSystemSettingsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSystemSettingsList(category, isActive, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {PatchedSystemSettingsCreateUpdate} [patchedSystemSettingsCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSystemSettingsPartialUpdate(id: number, patchedSystemSettingsCreateUpdate?: PatchedSystemSettingsCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemSettingsCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSystemSettingsPartialUpdate(id, patchedSystemSettingsCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSystemSettingsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSystemSettingsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {SystemSettingsCreateUpdate} systemSettingsCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSystemSettingsUpdate(id: number, systemSettingsCreateUpdate: SystemSettingsCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemSettingsCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSystemSettingsUpdate(id, systemSettingsCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get notification counts for current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsCountRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsCountRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new notifications (admin only).
         * @param {NotificationCreate} notificationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsCreateCreate(notificationCreate: NotificationCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsCreateCreate(notificationCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List notifications for the current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNotificationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark all notifications as read for current user.
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsMarkAllReadCreate(notification: Notification, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsMarkAllReadCreate(notification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve and update individual notifications.
         * @param {number} id 
         * @param {PatchedNotificationUpdate} [patchedNotificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsPartialUpdate(id: number, patchedNotificationUpdate?: PatchedNotificationUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsPartialUpdate(id, patchedNotificationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recent notifications (last 7 days).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsRecentList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNotificationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsRecentList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve and update individual notifications.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get unread notifications for current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsUnreadList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNotificationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsUnreadList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve and update individual notifications.
         * @param {number} id 
         * @param {NotificationUpdate} [notificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsUpdate(id: number, notificationUpdate?: NotificationUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsUpdate(id, notificationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all order assignments (admin view).
         * @param {number} [order] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [provider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersAssignmentsList(order?: number, ordering?: string, page?: number, pageSize?: number, provider?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderAssignmentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersAssignmentsList(order, ordering, page, pageSize, provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View and update order assignment details.
         * @param {number} id 
         * @param {PatchedOrderAssignment} [patchedOrderAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersAssignmentsPartialUpdate(id: number, patchedOrderAssignment?: PatchedOrderAssignment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderAssignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersAssignmentsPartialUpdate(id, patchedOrderAssignment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View and update order assignment details.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersAssignmentsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderAssignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersAssignmentsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View and update order assignment details.
         * @param {number} id 
         * @param {OrderAssignment} orderAssignment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersAssignmentsUpdate(id: number, orderAssignment: OrderAssignment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderAssignment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersAssignmentsUpdate(id, orderAssignment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accept a bid and create order assignment.
         * @param {number} bidId 
         * @param {BidAction} [bidAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsAcceptCreate(bidId: number, bidAction?: BidAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsAcceptCreate(bidId, bidAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} orderId 
         * @param {BidCreateUpdate} bidCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsCreate(orderId: number, bidCreateUpdate: BidCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsCreate(orderId, bidCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all bids (admin view).
         * @param {boolean} [isNegotiable] 
         * @param {number} [order] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'accepted' | 'pending' | 'rejected' | 'withdrawn'} [status] * &#x60;pending&#x60; - Pending * &#x60;accepted&#x60; - Accepted * &#x60;rejected&#x60; - Rejected * &#x60;withdrawn&#x60; - Withdrawn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsList(isNegotiable?: boolean, order?: number, ordering?: string, page?: number, pageSize?: number, status?: 'accepted' | 'pending' | 'rejected' | 'withdrawn', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBidList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsList(isNegotiable, order, ordering, page, pageSize, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedBidCreateUpdate} [patchedBidCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsPartialUpdate(id: number, patchedBidCreateUpdate?: PatchedBidCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsPartialUpdate(id, patchedBidCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reject a bid.
         * @param {number} bidId 
         * @param {BidAction} [bidAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsRejectCreate(bidId: number, bidAction?: BidAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsRejectCreate(bidId, bidAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {BidCreateUpdate} bidCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsUpdate(id: number, bidCreateUpdate: BidCreateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidCreateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsUpdate(id, bidCreateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Withdraw a bid (by provider).
         * @param {number} bidId 
         * @param {BidAction} [bidAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsWithdrawCreate(bidId: number, bidAction?: BidAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidAction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsWithdrawCreate(bidId, bidAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersCreateCreate(orderCreate: OrderCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersCreateCreate(orderCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all orders (admin view).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {number} [serviceSubcategory] 
         * @param {'assigned' | 'bidding' | 'cancelled' | 'completed' | 'disputed' | 'draft' | 'in_progress' | 'published'} [status] * &#x60;draft&#x60; - Draft * &#x60;published&#x60; - Published * &#x60;bidding&#x60; - Bidding * &#x60;assigned&#x60; - Assigned * &#x60;in_progress&#x60; - In Progress * &#x60;completed&#x60; - Completed * &#x60;cancelled&#x60; - Cancelled * &#x60;disputed&#x60; - Disputed
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersList(ordering?: string, page?: number, pageSize?: number, search?: string, serviceSubcategory?: number, status?: 'assigned' | 'bidding' | 'cancelled' | 'completed' | 'disputed' | 'draft' | 'in_progress' | 'published', urgency?: 'high' | 'low' | 'medium' | 'urgent', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersList(ordering, page, pageSize, search, serviceSubcategory, status, urgency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current user\'s assignments (as service provider).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersMyAssignmentsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderAssignmentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersMyAssignmentsList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current user\'s bids (as service provider).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersMyBidsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBidList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersMyBidsList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current user\'s orders (as client).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersMyList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersMyList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get assignments for current user\'s orders (as client).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersMyOrdersAssignmentsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderAssignmentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersMyOrdersAssignmentsList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get bids for current user\'s orders (as client).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersMyOrdersBidsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBidList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersMyOrdersBidsList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedOrderUpdate} [patchedOrderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersPartialUpdate(id: number, patchedOrderUpdate?: PatchedOrderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersPartialUpdate(id, patchedOrderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {OrderUpdate} orderUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersUpdate(id: number, orderUpdate: OrderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersUpdate(id, orderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsCreateCreate(paymentCreate: PaymentCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsCreateCreate(paymentCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {InvoiceCreate} invoiceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsInvoicesCreateCreate(invoiceCreate: InvoiceCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsInvoicesCreateCreate(invoiceCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsInvoicesList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInvoiceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsInvoicesList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsInvoicesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsInvoicesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPaymentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PaymentMethodCreate} paymentMethodCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsCreateCreate(paymentMethodCreate: PaymentMethodCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsCreateCreate(paymentMethodCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPaymentMethodList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedPaymentMethodUpdate} [patchedPaymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsPartialUpdate(id: number, patchedPaymentMethodUpdate?: PatchedPaymentMethodUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsPartialUpdate(id, patchedPaymentMethodUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PaymentMethodUpdate} [paymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsUpdate(id: number, paymentMethodUpdate?: PaymentMethodUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsUpdate(id, paymentMethodUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedPaymentCreate} [patchedPaymentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsPartialUpdate(id: number, patchedPaymentCreate?: PatchedPaymentCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsPartialUpdate(id, patchedPaymentCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsUpdate(id: number, paymentCreate: PaymentCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsUpdate(id, paymentCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List webhook events.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsWebhooksEventsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeWebhookEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsWebhooksEventsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retry processing a webhook event.
         * @param {number} eventId 
         * @param {WebhookRetryResponse} webhookRetryResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsWebhooksEventsRetryCreate(eventId: number, webhookRetryResponse: WebhookRetryResponse, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookRetryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsWebhooksEventsRetryCreate(eventId, webhookRetryResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API view for Stripe webhook handling.
         * @param {WebhookResponse} webhookResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsWebhooksStripeDrfCreate(webhookResponse: WebhookResponse, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsWebhooksStripeDrfCreate(webhookResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload profile image
         * @param {UserUpdate} [userUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileCreate(userUpdate?: UserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileCreate(userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User profile view with image upload
         * @param {PatchedUserUpdate} [patchedUserUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfilePartialUpdate(patchedUserUpdate?: PatchedUserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfilePartialUpdate(patchedUserUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User profile view with image upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User profile view with image upload
         * @param {UserUpdate} [userUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileUpdate(userUpdate?: UserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileUpdate(userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get review analytics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsAnalyticsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewAnalytics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsAnalyticsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List and create reviews.
         * @param {ReviewCreate} reviewCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsCreate(reviewCreate: ReviewCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsCreate(reviewCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List and create reviews.
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsList(isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReviewList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsList(isVerified, ordering, overallRating, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get reviews for a specific order.
         * @param {number} orderId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsOrderList(orderId: number, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReviewList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsOrderList(orderId, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {PatchedReviewUpdate} [patchedReviewUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsPartialUpdate(id: number, patchedReviewUpdate?: PatchedReviewUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsPartialUpdate(id, patchedReviewUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get reviews for a specific service provider.
         * @param {number} providerId 
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsProviderList(providerId: number, isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReviewList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsProviderList(providerId, isVerified, ordering, overallRating, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Review>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {ReviewUpdate} reviewUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsUpdate(id: number, reviewUpdate: ReviewUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsUpdate(id, reviewUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Simple global search across all content types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SearchGlobalRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlobalSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SearchGlobalRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search specifically for orders (job vacancies).
         * @param {string} [city] Filter by city
         * @param {number} [maxBudget] Maximum budget
         * @param {number} [minBudget] Minimum budget
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {number} [serviceCategory] Filter by service category ID
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SearchOrdersList(city?: string, maxBudget?: number, minBudget?: number, ordering?: string, page?: number, pageSize?: number, q?: string, serviceCategory?: number, urgency?: 'high' | 'low' | 'medium' | 'urgent', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SearchOrdersList(city, maxBudget, minBudget, ordering, page, pageSize, q, serviceCategory, urgency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search specifically for service providers.
         * @param {string} [city] Filter by city
         * @param {number} [minRating] Minimum rating
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SearchProvidersList(city?: string, minRating?: number, ordering?: string, page?: number, pageSize?: number, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedServiceProviderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SearchProvidersList(city, minRating, ordering, page, pageSize, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all users - not in api_users, useful for admin
         * @param {boolean} [blocked] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {'free' | 'paid' | 'premium_paid'} [userType] * &#x60;free&#x60; - Бесплатный * &#x60;paid&#x60; - Оплаченный * &#x60;premium_paid&#x60; - Премиум оплаченный
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersList(blocked?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, userType?: 'free' | 'paid' | 'premium_paid', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersList(blocked, isActive, ordering, page, pageSize, search, userType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Manage my service provider certificates.
         * @param {Certificate} certificate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyCertificatesCreate(certificate: Certificate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Certificate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyCertificatesCreate(certificate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Manage my service provider certificates.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyCertificatesList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCertificateList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyCertificatesList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ClientUpdate} [clientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyClientCreateCreate(clientUpdate?: ClientUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyClientCreateCreate(clientUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedClientUpdate} [patchedClientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyClientUpdatePartialUpdate(patchedClientUpdate?: PatchedClientUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyClientUpdatePartialUpdate(patchedClientUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ClientUpdate} [clientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyClientUpdateUpdate(clientUpdate?: ClientUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyClientUpdateUpdate(clientUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Manage my service provider portfolio items.
         * @param {PortfolioItem} portfolioItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyPortfolioCreate(portfolioItem: PortfolioItem, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyPortfolioCreate(portfolioItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Manage my service provider portfolio items.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyPortfolioList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPortfolioItemList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyPortfolioList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedAdvancedProfileUpdate} [patchedAdvancedProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyProfileAdvancedPartialUpdate(patchedAdvancedProfileUpdate?: PatchedAdvancedProfileUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdvancedProfileUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyProfileAdvancedPartialUpdate(patchedAdvancedProfileUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyProfileAdvancedRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdvancedProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyProfileAdvancedRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {AdvancedProfileUpdate} [advancedProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyProfileAdvancedUpdate(advancedProfileUpdate?: AdvancedProfileUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdvancedProfileUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyProfileAdvancedUpdate(advancedProfileUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedUserProfileUpdate} [patchedUserProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyProfilePartialUpdate(patchedUserProfileUpdate?: PatchedUserProfileUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyProfilePartialUpdate(patchedUserProfileUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyProfileRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyProfileRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {UserProfileUpdate} [userProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyProfileUpdate(userProfileUpdate?: UserProfileUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyProfileUpdate(userProfileUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyProviderCreateCreate(serviceProviderUpdate?: ServiceProviderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyProviderCreateCreate(serviceProviderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyProviderUpdatePartialUpdate(patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyProviderUpdatePartialUpdate(patchedServiceProviderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyProviderUpdateUpdate(serviceProviderUpdate?: ServiceProviderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyProviderUpdateUpdate(serviceProviderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Manage my service provider skills.
         * @param {ServiceProviderSkill} serviceProviderSkill 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMySkillsCreate(serviceProviderSkill: ServiceProviderSkill, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderSkill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMySkillsCreate(serviceProviderSkill, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Manage my service provider skills.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMySkillsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedServiceProviderSkillList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMySkillsList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Manage my provider statistics.
         * @param {PatchedProviderStatistics} [patchedProviderStatistics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyStatisticsPartialUpdate(patchedProviderStatistics?: PatchedProviderStatistics, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyStatisticsPartialUpdate(patchedProviderStatistics, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Manage my provider statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyStatisticsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyStatisticsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Manage my provider statistics.
         * @param {ProviderStatistics} [providerStatistics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersMyStatisticsUpdate(providerStatistics?: ProviderStatistics, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersMyStatisticsUpdate(providerStatistics, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List available professions.
         * @param {number} [category] 
         * @param {boolean} [isActive] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProfessionsList(category?: number, isActive?: boolean, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProfessionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProfessionsList(category, isActive, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProvidersDetailsPartialUpdate(id: number, patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProvidersDetailsPartialUpdate(id, patchedServiceProviderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProvidersDetailsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProvidersDetailsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProvidersDetailsUpdate(id: number, serviceProviderUpdate?: ServiceProviderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProvidersDetailsUpdate(id, serviceProviderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List available skills for service providers.
         * @param {number} [category] 
         * @param {boolean} [isActive] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersSkillsList(category?: number, isActive?: boolean, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMasterSkillList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersSkillsList(category, isActive, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1Api - factory interface
 * @export
 */
export const V1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1ApiFp(configuration)
    return {
        /**
         * Authenticate user with Firebase ID token or register new user if verified.
         * @param {FireBaseAuth} fireBaseAuth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthFirebaseCreate(fireBaseAuth: FireBaseAuth, options?: any): AxiosPromise<FireBaseAuth> {
            return localVarFp.v1AuthFirebaseCreate(fireBaseAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * User logout view - enhanced version of api_users LogOutView
         * @param {LogoutResponse} logoutResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLogoutCreate(logoutResponse: LogoutResponse, options?: any): AxiosPromise<LogoutResponse> {
            return localVarFp.v1AuthLogoutCreate(logoutResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * Mobile-optimized view for chat conversation list.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatConversationsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedChatConversationList> {
            return localVarFp.v1ChatConversationsList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Mobile-optimized view for chat conversation details with messages.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatConversationsRetrieve(id: number, options?: any): AxiosPromise<ChatConversationDetail> {
            return localVarFp.v1ChatConversationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a message to a chat room.
         * @param {number} id 
         * @param {ChatSendMessage} chatSendMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatConversationsSendCreate(id: number, chatSendMessage: ChatSendMessage, options?: any): AxiosPromise<ChatSendMessage> {
            return localVarFp.v1ChatConversationsSendCreate(id, chatSendMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get WebSocket connection info for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatWebsocketInfoRetrieve(options?: any): AxiosPromise<WebSocketInfo> {
            return localVarFp.v1ChatWebsocketInfoRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Languages - Read-only (managed via admin/fixtures).
         * @param {boolean} [isActive] 
         * @param {boolean} [isDefault] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreLanguagesList(isActive?: boolean, isDefault?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedLanguageList> {
            return localVarFp.v1CoreLanguagesList(isActive, isDefault, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Languages - Read-only (managed via admin/fixtures).
         * @param {number} id A unique integer value identifying this Language.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreLanguagesRetrieve(id: number, options?: any): AxiosPromise<Language> {
            return localVarFp.v1CoreLanguagesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {ServiceAreaCreateUpdate} serviceAreaCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasCreate(serviceAreaCreateUpdate: ServiceAreaCreateUpdate, options?: any): AxiosPromise<ServiceAreaCreateUpdate> {
            return localVarFp.v1CoreServiceAreasCreate(serviceAreaCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1CoreServiceAreasDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasList(isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedServiceAreaList> {
            return localVarFp.v1CoreServiceAreasList(isActive, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {PatchedServiceAreaCreateUpdate} [patchedServiceAreaCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasPartialUpdate(id: number, patchedServiceAreaCreateUpdate?: PatchedServiceAreaCreateUpdate, options?: any): AxiosPromise<ServiceAreaCreateUpdate> {
            return localVarFp.v1CoreServiceAreasPartialUpdate(id, patchedServiceAreaCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasRetrieve(id: number, options?: any): AxiosPromise<ServiceArea> {
            return localVarFp.v1CoreServiceAreasRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Areas - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Area.
         * @param {ServiceAreaCreateUpdate} serviceAreaCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasUpdate(id: number, serviceAreaCreateUpdate: ServiceAreaCreateUpdate, options?: any): AxiosPromise<ServiceAreaCreateUpdate> {
            return localVarFp.v1CoreServiceAreasUpdate(id, serviceAreaCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {ServiceCategoryCreateUpdate} serviceCategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesCreate(serviceCategoryCreateUpdate: ServiceCategoryCreateUpdate, options?: any): AxiosPromise<ServiceCategoryCreateUpdate> {
            return localVarFp.v1CoreServiceCategoriesCreate(serviceCategoryCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1CoreServiceCategoriesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesList(featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedServiceCategoryList> {
            return localVarFp.v1CoreServiceCategoriesList(featured, isActive, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {PatchedServiceCategoryCreateUpdate} [patchedServiceCategoryCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesPartialUpdate(id: number, patchedServiceCategoryCreateUpdate?: PatchedServiceCategoryCreateUpdate, options?: any): AxiosPromise<ServiceCategoryCreateUpdate> {
            return localVarFp.v1CoreServiceCategoriesPartialUpdate(id, patchedServiceCategoryCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesRetrieve(id: number, options?: any): AxiosPromise<ServiceCategory> {
            return localVarFp.v1CoreServiceCategoriesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Categories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Category.
         * @param {ServiceCategoryCreateUpdate} serviceCategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesUpdate(id: number, serviceCategoryCreateUpdate: ServiceCategoryCreateUpdate, options?: any): AxiosPromise<ServiceCategoryCreateUpdate> {
            return localVarFp.v1CoreServiceCategoriesUpdate(id, serviceCategoryCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {ServiceSubcategoryCreateUpdate} serviceSubcategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesCreate(serviceSubcategoryCreateUpdate: ServiceSubcategoryCreateUpdate, options?: any): AxiosPromise<ServiceSubcategoryCreateUpdate> {
            return localVarFp.v1CoreServiceSubcategoriesCreate(serviceSubcategoryCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1CoreServiceSubcategoriesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} [category] 
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesList(category?: number, featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedServiceSubcategoryList> {
            return localVarFp.v1CoreServiceSubcategoriesList(category, featured, isActive, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {PatchedServiceSubcategoryCreateUpdate} [patchedServiceSubcategoryCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesPartialUpdate(id: number, patchedServiceSubcategoryCreateUpdate?: PatchedServiceSubcategoryCreateUpdate, options?: any): AxiosPromise<ServiceSubcategoryCreateUpdate> {
            return localVarFp.v1CoreServiceSubcategoriesPartialUpdate(id, patchedServiceSubcategoryCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesRetrieve(id: number, options?: any): AxiosPromise<ServiceSubcategory> {
            return localVarFp.v1CoreServiceSubcategoriesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Service Subcategories - Full CRUD with authenticated access.
         * @param {number} id A unique integer value identifying this Service Subcategory.
         * @param {ServiceSubcategoryCreateUpdate} serviceSubcategoryCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesUpdate(id: number, serviceSubcategoryCreateUpdate: ServiceSubcategoryCreateUpdate, options?: any): AxiosPromise<ServiceSubcategoryCreateUpdate> {
            return localVarFp.v1CoreServiceSubcategoriesUpdate(id, serviceSubcategoryCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {SupportFAQCreateUpdate} supportFAQCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqCreate(supportFAQCreateUpdate: SupportFAQCreateUpdate, options?: any): AxiosPromise<SupportFAQCreateUpdate> {
            return localVarFp.v1CoreSupportFaqCreate(supportFAQCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1CoreSupportFaqDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {'account' | 'general' | 'reviews' | 'safety' | 'search' | 'specialist'} [category] * &#x60;general&#x60; - General * &#x60;specialist&#x60; - Specialist * &#x60;reviews&#x60; - Reviews * &#x60;account&#x60; - Account * &#x60;search&#x60; - Найти * &#x60;safety&#x60; - Safety
         * @param {boolean} [isActive] 
         * @param {number} [language] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqList(category?: 'account' | 'general' | 'reviews' | 'safety' | 'search' | 'specialist', isActive?: boolean, language?: number, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedSupportFAQList> {
            return localVarFp.v1CoreSupportFaqList(category, isActive, language, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {PatchedSupportFAQCreateUpdate} [patchedSupportFAQCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqPartialUpdate(id: number, patchedSupportFAQCreateUpdate?: PatchedSupportFAQCreateUpdate, options?: any): AxiosPromise<SupportFAQCreateUpdate> {
            return localVarFp.v1CoreSupportFaqPartialUpdate(id, patchedSupportFAQCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqRetrieve(id: number, options?: any): AxiosPromise<SupportFAQ> {
            return localVarFp.v1CoreSupportFaqRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Support FAQ - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this Support FAQ.
         * @param {SupportFAQCreateUpdate} supportFAQCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSupportFaqUpdate(id: number, supportFAQCreateUpdate: SupportFAQCreateUpdate, options?: any): AxiosPromise<SupportFAQCreateUpdate> {
            return localVarFp.v1CoreSupportFaqUpdate(id, supportFAQCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {SystemSettingsCreateUpdate} systemSettingsCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsCreate(systemSettingsCreateUpdate: SystemSettingsCreateUpdate, options?: any): AxiosPromise<SystemSettingsCreateUpdate> {
            return localVarFp.v1CoreSystemSettingsCreate(systemSettingsCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1CoreSystemSettingsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {string} [category] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsList(category?: string, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedSystemSettingsList> {
            return localVarFp.v1CoreSystemSettingsList(category, isActive, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {PatchedSystemSettingsCreateUpdate} [patchedSystemSettingsCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsPartialUpdate(id: number, patchedSystemSettingsCreateUpdate?: PatchedSystemSettingsCreateUpdate, options?: any): AxiosPromise<SystemSettingsCreateUpdate> {
            return localVarFp.v1CoreSystemSettingsPartialUpdate(id, patchedSystemSettingsCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsRetrieve(id: number, options?: any): AxiosPromise<SystemSettings> {
            return localVarFp.v1CoreSystemSettingsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * System Settings - Full CRUD with admin access.
         * @param {number} id A unique integer value identifying this System Setting.
         * @param {SystemSettingsCreateUpdate} systemSettingsCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsUpdate(id: number, systemSettingsCreateUpdate: SystemSettingsCreateUpdate, options?: any): AxiosPromise<SystemSettingsCreateUpdate> {
            return localVarFp.v1CoreSystemSettingsUpdate(id, systemSettingsCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get notification counts for current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsCountRetrieve(options?: any): AxiosPromise<Notification> {
            return localVarFp.v1NotificationsCountRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Create new notifications (admin only).
         * @param {NotificationCreate} notificationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsCreateCreate(notificationCreate: NotificationCreate, options?: any): AxiosPromise<NotificationCreate> {
            return localVarFp.v1NotificationsCreateCreate(notificationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List notifications for the current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedNotificationList> {
            return localVarFp.v1NotificationsList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark all notifications as read for current user.
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsMarkAllReadCreate(notification: Notification, options?: any): AxiosPromise<Notification> {
            return localVarFp.v1NotificationsMarkAllReadCreate(notification, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve and update individual notifications.
         * @param {number} id 
         * @param {PatchedNotificationUpdate} [patchedNotificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsPartialUpdate(id: number, patchedNotificationUpdate?: PatchedNotificationUpdate, options?: any): AxiosPromise<NotificationUpdate> {
            return localVarFp.v1NotificationsPartialUpdate(id, patchedNotificationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent notifications (last 7 days).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsRecentList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedNotificationList> {
            return localVarFp.v1NotificationsRecentList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve and update individual notifications.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsRetrieve(id: number, options?: any): AxiosPromise<Notification> {
            return localVarFp.v1NotificationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get unread notifications for current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsUnreadList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedNotificationList> {
            return localVarFp.v1NotificationsUnreadList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve and update individual notifications.
         * @param {number} id 
         * @param {NotificationUpdate} [notificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsUpdate(id: number, notificationUpdate?: NotificationUpdate, options?: any): AxiosPromise<NotificationUpdate> {
            return localVarFp.v1NotificationsUpdate(id, notificationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * List all order assignments (admin view).
         * @param {number} [order] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [provider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersAssignmentsList(order?: number, ordering?: string, page?: number, pageSize?: number, provider?: number, options?: any): AxiosPromise<PaginatedOrderAssignmentList> {
            return localVarFp.v1OrdersAssignmentsList(order, ordering, page, pageSize, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * View and update order assignment details.
         * @param {number} id 
         * @param {PatchedOrderAssignment} [patchedOrderAssignment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersAssignmentsPartialUpdate(id: number, patchedOrderAssignment?: PatchedOrderAssignment, options?: any): AxiosPromise<OrderAssignment> {
            return localVarFp.v1OrdersAssignmentsPartialUpdate(id, patchedOrderAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * View and update order assignment details.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersAssignmentsRetrieve(id: number, options?: any): AxiosPromise<OrderAssignment> {
            return localVarFp.v1OrdersAssignmentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * View and update order assignment details.
         * @param {number} id 
         * @param {OrderAssignment} orderAssignment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersAssignmentsUpdate(id: number, orderAssignment: OrderAssignment, options?: any): AxiosPromise<OrderAssignment> {
            return localVarFp.v1OrdersAssignmentsUpdate(id, orderAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * Accept a bid and create order assignment.
         * @param {number} bidId 
         * @param {BidAction} [bidAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsAcceptCreate(bidId: number, bidAction?: BidAction, options?: any): AxiosPromise<BidAction> {
            return localVarFp.v1OrdersBidsAcceptCreate(bidId, bidAction, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} orderId 
         * @param {BidCreateUpdate} bidCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsCreate(orderId: number, bidCreateUpdate: BidCreateUpdate, options?: any): AxiosPromise<BidCreateUpdate> {
            return localVarFp.v1OrdersBidsCreate(orderId, bidCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1OrdersBidsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all bids (admin view).
         * @param {boolean} [isNegotiable] 
         * @param {number} [order] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'accepted' | 'pending' | 'rejected' | 'withdrawn'} [status] * &#x60;pending&#x60; - Pending * &#x60;accepted&#x60; - Accepted * &#x60;rejected&#x60; - Rejected * &#x60;withdrawn&#x60; - Withdrawn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsList(isNegotiable?: boolean, order?: number, ordering?: string, page?: number, pageSize?: number, status?: 'accepted' | 'pending' | 'rejected' | 'withdrawn', options?: any): AxiosPromise<PaginatedBidList> {
            return localVarFp.v1OrdersBidsList(isNegotiable, order, ordering, page, pageSize, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedBidCreateUpdate} [patchedBidCreateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsPartialUpdate(id: number, patchedBidCreateUpdate?: PatchedBidCreateUpdate, options?: any): AxiosPromise<BidCreateUpdate> {
            return localVarFp.v1OrdersBidsPartialUpdate(id, patchedBidCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Reject a bid.
         * @param {number} bidId 
         * @param {BidAction} [bidAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsRejectCreate(bidId: number, bidAction?: BidAction, options?: any): AxiosPromise<BidAction> {
            return localVarFp.v1OrdersBidsRejectCreate(bidId, bidAction, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsRetrieve(id: number, options?: any): AxiosPromise<Bid> {
            return localVarFp.v1OrdersBidsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {BidCreateUpdate} bidCreateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsUpdate(id: number, bidCreateUpdate: BidCreateUpdate, options?: any): AxiosPromise<BidCreateUpdate> {
            return localVarFp.v1OrdersBidsUpdate(id, bidCreateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw a bid (by provider).
         * @param {number} bidId 
         * @param {BidAction} [bidAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsWithdrawCreate(bidId: number, bidAction?: BidAction, options?: any): AxiosPromise<BidAction> {
            return localVarFp.v1OrdersBidsWithdrawCreate(bidId, bidAction, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersCreateCreate(orderCreate: OrderCreate, options?: any): AxiosPromise<OrderCreate> {
            return localVarFp.v1OrdersCreateCreate(orderCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List all orders (admin view).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {number} [serviceSubcategory] 
         * @param {'assigned' | 'bidding' | 'cancelled' | 'completed' | 'disputed' | 'draft' | 'in_progress' | 'published'} [status] * &#x60;draft&#x60; - Draft * &#x60;published&#x60; - Published * &#x60;bidding&#x60; - Bidding * &#x60;assigned&#x60; - Assigned * &#x60;in_progress&#x60; - In Progress * &#x60;completed&#x60; - Completed * &#x60;cancelled&#x60; - Cancelled * &#x60;disputed&#x60; - Disputed
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersList(ordering?: string, page?: number, pageSize?: number, search?: string, serviceSubcategory?: number, status?: 'assigned' | 'bidding' | 'cancelled' | 'completed' | 'disputed' | 'draft' | 'in_progress' | 'published', urgency?: 'high' | 'low' | 'medium' | 'urgent', options?: any): AxiosPromise<PaginatedOrderList> {
            return localVarFp.v1OrdersList(ordering, page, pageSize, search, serviceSubcategory, status, urgency, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user\'s assignments (as service provider).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersMyAssignmentsList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedOrderAssignmentList> {
            return localVarFp.v1OrdersMyAssignmentsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user\'s bids (as service provider).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersMyBidsList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedBidList> {
            return localVarFp.v1OrdersMyBidsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user\'s orders (as client).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersMyList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedOrderList> {
            return localVarFp.v1OrdersMyList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Get assignments for current user\'s orders (as client).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersMyOrdersAssignmentsList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedOrderAssignmentList> {
            return localVarFp.v1OrdersMyOrdersAssignmentsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get bids for current user\'s orders (as client).
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersMyOrdersBidsList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedBidList> {
            return localVarFp.v1OrdersMyOrdersBidsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedOrderUpdate} [patchedOrderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersPartialUpdate(id: number, patchedOrderUpdate?: PatchedOrderUpdate, options?: any): AxiosPromise<OrderUpdate> {
            return localVarFp.v1OrdersPartialUpdate(id, patchedOrderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersRetrieve(id: number, options?: any): AxiosPromise<Order> {
            return localVarFp.v1OrdersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {OrderUpdate} orderUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersUpdate(id: number, orderUpdate: OrderUpdate, options?: any): AxiosPromise<OrderUpdate> {
            return localVarFp.v1OrdersUpdate(id, orderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsCreateCreate(paymentCreate: PaymentCreate, options?: any): AxiosPromise<PaymentCreate> {
            return localVarFp.v1PaymentsCreateCreate(paymentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {InvoiceCreate} invoiceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesCreateCreate(invoiceCreate: InvoiceCreate, options?: any): AxiosPromise<InvoiceCreate> {
            return localVarFp.v1PaymentsInvoicesCreateCreate(invoiceCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedInvoiceList> {
            return localVarFp.v1PaymentsInvoicesList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesRetrieve(id: number, options?: any): AxiosPromise<Invoice> {
            return localVarFp.v1PaymentsInvoicesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedPaymentList> {
            return localVarFp.v1PaymentsList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PaymentMethodCreate} paymentMethodCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsCreateCreate(paymentMethodCreate: PaymentMethodCreate, options?: any): AxiosPromise<PaymentMethodCreate> {
            return localVarFp.v1PaymentsMethodsCreateCreate(paymentMethodCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1PaymentsMethodsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPaymentMethodList> {
            return localVarFp.v1PaymentsMethodsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedPaymentMethodUpdate} [patchedPaymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsPartialUpdate(id: number, patchedPaymentMethodUpdate?: PatchedPaymentMethodUpdate, options?: any): AxiosPromise<PaymentMethodUpdate> {
            return localVarFp.v1PaymentsMethodsPartialUpdate(id, patchedPaymentMethodUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsRetrieve(id: number, options?: any): AxiosPromise<PaymentMethod> {
            return localVarFp.v1PaymentsMethodsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PaymentMethodUpdate} [paymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsUpdate(id: number, paymentMethodUpdate?: PaymentMethodUpdate, options?: any): AxiosPromise<PaymentMethodUpdate> {
            return localVarFp.v1PaymentsMethodsUpdate(id, paymentMethodUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedPaymentCreate} [patchedPaymentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsPartialUpdate(id: number, patchedPaymentCreate?: PatchedPaymentCreate, options?: any): AxiosPromise<PaymentCreate> {
            return localVarFp.v1PaymentsPartialUpdate(id, patchedPaymentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsRetrieve(id: number, options?: any): AxiosPromise<Payment> {
            return localVarFp.v1PaymentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsUpdate(id: number, paymentCreate: PaymentCreate, options?: any): AxiosPromise<PaymentCreate> {
            return localVarFp.v1PaymentsUpdate(id, paymentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List webhook events.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksEventsRetrieve(options?: any): AxiosPromise<StripeWebhookEvent> {
            return localVarFp.v1PaymentsWebhooksEventsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Retry processing a webhook event.
         * @param {number} eventId 
         * @param {WebhookRetryResponse} webhookRetryResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksEventsRetryCreate(eventId: number, webhookRetryResponse: WebhookRetryResponse, options?: any): AxiosPromise<WebhookRetryResponse> {
            return localVarFp.v1PaymentsWebhooksEventsRetryCreate(eventId, webhookRetryResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * API view for Stripe webhook handling.
         * @param {WebhookResponse} webhookResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksStripeDrfCreate(webhookResponse: WebhookResponse, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.v1PaymentsWebhooksStripeDrfCreate(webhookResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload profile image
         * @param {UserUpdate} [userUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileCreate(userUpdate?: UserUpdate, options?: any): AxiosPromise<UserUpdate> {
            return localVarFp.v1ProfileCreate(userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * User profile view with image upload
         * @param {PatchedUserUpdate} [patchedUserUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfilePartialUpdate(patchedUserUpdate?: PatchedUserUpdate, options?: any): AxiosPromise<UserUpdate> {
            return localVarFp.v1ProfilePartialUpdate(patchedUserUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * User profile view with image upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileRetrieve(options?: any): AxiosPromise<UserProfile> {
            return localVarFp.v1ProfileRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * User profile view with image upload
         * @param {UserUpdate} [userUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileUpdate(userUpdate?: UserUpdate, options?: any): AxiosPromise<UserUpdate> {
            return localVarFp.v1ProfileUpdate(userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get review analytics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsAnalyticsRetrieve(options?: any): AxiosPromise<ReviewAnalytics> {
            return localVarFp.v1ReviewsAnalyticsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * List and create reviews.
         * @param {ReviewCreate} reviewCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsCreate(reviewCreate: ReviewCreate, options?: any): AxiosPromise<ReviewCreate> {
            return localVarFp.v1ReviewsCreate(reviewCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1ReviewsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List and create reviews.
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsList(isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedReviewList> {
            return localVarFp.v1ReviewsList(isVerified, ordering, overallRating, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Get reviews for a specific order.
         * @param {number} orderId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsOrderList(orderId: number, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedReviewList> {
            return localVarFp.v1ReviewsOrderList(orderId, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {PatchedReviewUpdate} [patchedReviewUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsPartialUpdate(id: number, patchedReviewUpdate?: PatchedReviewUpdate, options?: any): AxiosPromise<ReviewUpdate> {
            return localVarFp.v1ReviewsPartialUpdate(id, patchedReviewUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get reviews for a specific service provider.
         * @param {number} providerId 
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsProviderList(providerId: number, isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedReviewList> {
            return localVarFp.v1ReviewsProviderList(providerId, isVerified, ordering, overallRating, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsRetrieve(id: number, options?: any): AxiosPromise<Review> {
            return localVarFp.v1ReviewsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {ReviewUpdate} reviewUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsUpdate(id: number, reviewUpdate: ReviewUpdate, options?: any): AxiosPromise<ReviewUpdate> {
            return localVarFp.v1ReviewsUpdate(id, reviewUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple global search across all content types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchGlobalRetrieve(options?: any): AxiosPromise<GlobalSearchResponse> {
            return localVarFp.v1SearchGlobalRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Search specifically for orders (job vacancies).
         * @param {string} [city] Filter by city
         * @param {number} [maxBudget] Maximum budget
         * @param {number} [minBudget] Minimum budget
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {number} [serviceCategory] Filter by service category ID
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchOrdersList(city?: string, maxBudget?: number, minBudget?: number, ordering?: string, page?: number, pageSize?: number, q?: string, serviceCategory?: number, urgency?: 'high' | 'low' | 'medium' | 'urgent', options?: any): AxiosPromise<PaginatedOrderList> {
            return localVarFp.v1SearchOrdersList(city, maxBudget, minBudget, ordering, page, pageSize, q, serviceCategory, urgency, options).then((request) => request(axios, basePath));
        },
        /**
         * Search specifically for service providers.
         * @param {string} [city] Filter by city
         * @param {number} [minRating] Minimum rating
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchProvidersList(city?: string, minRating?: number, ordering?: string, page?: number, pageSize?: number, q?: string, options?: any): AxiosPromise<PaginatedServiceProviderList> {
            return localVarFp.v1SearchProvidersList(city, minRating, ordering, page, pageSize, q, options).then((request) => request(axios, basePath));
        },
        /**
         * List all users - not in api_users, useful for admin
         * @param {boolean} [blocked] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {'free' | 'paid' | 'premium_paid'} [userType] * &#x60;free&#x60; - Бесплатный * &#x60;paid&#x60; - Оплаченный * &#x60;premium_paid&#x60; - Премиум оплаченный
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersList(blocked?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, userType?: 'free' | 'paid' | 'premium_paid', options?: any): AxiosPromise<PaginatedUserListList> {
            return localVarFp.v1UsersList(blocked, isActive, ordering, page, pageSize, search, userType, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage my service provider certificates.
         * @param {Certificate} certificate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyCertificatesCreate(certificate: Certificate, options?: any): AxiosPromise<Certificate> {
            return localVarFp.v1UsersMyCertificatesCreate(certificate, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage my service provider certificates.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyCertificatesList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedCertificateList> {
            return localVarFp.v1UsersMyCertificatesList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ClientUpdate} [clientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyClientCreateCreate(clientUpdate?: ClientUpdate, options?: any): AxiosPromise<ClientUpdate> {
            return localVarFp.v1UsersMyClientCreateCreate(clientUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedClientUpdate} [patchedClientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyClientUpdatePartialUpdate(patchedClientUpdate?: PatchedClientUpdate, options?: any): AxiosPromise<ClientUpdate> {
            return localVarFp.v1UsersMyClientUpdatePartialUpdate(patchedClientUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ClientUpdate} [clientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyClientUpdateUpdate(clientUpdate?: ClientUpdate, options?: any): AxiosPromise<ClientUpdate> {
            return localVarFp.v1UsersMyClientUpdateUpdate(clientUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage my service provider portfolio items.
         * @param {PortfolioItem} portfolioItem 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyPortfolioCreate(portfolioItem: PortfolioItem, options?: any): AxiosPromise<PortfolioItem> {
            return localVarFp.v1UsersMyPortfolioCreate(portfolioItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage my service provider portfolio items.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyPortfolioList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPortfolioItemList> {
            return localVarFp.v1UsersMyPortfolioList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedAdvancedProfileUpdate} [patchedAdvancedProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfileAdvancedPartialUpdate(patchedAdvancedProfileUpdate?: PatchedAdvancedProfileUpdate, options?: any): AxiosPromise<AdvancedProfileUpdate> {
            return localVarFp.v1UsersMyProfileAdvancedPartialUpdate(patchedAdvancedProfileUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfileAdvancedRetrieve(options?: any): AxiosPromise<AdvancedProfile> {
            return localVarFp.v1UsersMyProfileAdvancedRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {AdvancedProfileUpdate} [advancedProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfileAdvancedUpdate(advancedProfileUpdate?: AdvancedProfileUpdate, options?: any): AxiosPromise<AdvancedProfileUpdate> {
            return localVarFp.v1UsersMyProfileAdvancedUpdate(advancedProfileUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedUserProfileUpdate} [patchedUserProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfilePartialUpdate(patchedUserProfileUpdate?: PatchedUserProfileUpdate, options?: any): AxiosPromise<UserProfileUpdate> {
            return localVarFp.v1UsersMyProfilePartialUpdate(patchedUserProfileUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfileRetrieve(options?: any): AxiosPromise<UserProfileDetail> {
            return localVarFp.v1UsersMyProfileRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {UserProfileUpdate} [userProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProfileUpdate(userProfileUpdate?: UserProfileUpdate, options?: any): AxiosPromise<UserProfileUpdate> {
            return localVarFp.v1UsersMyProfileUpdate(userProfileUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProviderCreateCreate(serviceProviderUpdate?: ServiceProviderUpdate, options?: any): AxiosPromise<ServiceProviderUpdate> {
            return localVarFp.v1UsersMyProviderCreateCreate(serviceProviderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProviderUpdatePartialUpdate(patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options?: any): AxiosPromise<ServiceProviderUpdate> {
            return localVarFp.v1UsersMyProviderUpdatePartialUpdate(patchedServiceProviderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyProviderUpdateUpdate(serviceProviderUpdate?: ServiceProviderUpdate, options?: any): AxiosPromise<ServiceProviderUpdate> {
            return localVarFp.v1UsersMyProviderUpdateUpdate(serviceProviderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage my service provider skills.
         * @param {ServiceProviderSkill} serviceProviderSkill 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMySkillsCreate(serviceProviderSkill: ServiceProviderSkill, options?: any): AxiosPromise<ServiceProviderSkill> {
            return localVarFp.v1UsersMySkillsCreate(serviceProviderSkill, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage my service provider skills.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMySkillsList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedServiceProviderSkillList> {
            return localVarFp.v1UsersMySkillsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage my provider statistics.
         * @param {PatchedProviderStatistics} [patchedProviderStatistics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyStatisticsPartialUpdate(patchedProviderStatistics?: PatchedProviderStatistics, options?: any): AxiosPromise<ProviderStatistics> {
            return localVarFp.v1UsersMyStatisticsPartialUpdate(patchedProviderStatistics, options).then((request) => request(axios, basePath));
        },
        /**
         * Manage my provider statistics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyStatisticsRetrieve(options?: any): AxiosPromise<ProviderStatistics> {
            return localVarFp.v1UsersMyStatisticsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Manage my provider statistics.
         * @param {ProviderStatistics} [providerStatistics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersMyStatisticsUpdate(providerStatistics?: ProviderStatistics, options?: any): AxiosPromise<ProviderStatistics> {
            return localVarFp.v1UsersMyStatisticsUpdate(providerStatistics, options).then((request) => request(axios, basePath));
        },
        /**
         * List available professions.
         * @param {number} [category] 
         * @param {boolean} [isActive] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfessionsList(category?: number, isActive?: boolean, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedProfessionList> {
            return localVarFp.v1UsersProfessionsList(category, isActive, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProvidersDetailsPartialUpdate(id: number, patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options?: any): AxiosPromise<ServiceProviderUpdate> {
            return localVarFp.v1UsersProvidersDetailsPartialUpdate(id, patchedServiceProviderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProvidersDetailsRetrieve(id: number, options?: any): AxiosPromise<ServiceProviderDetail> {
            return localVarFp.v1UsersProvidersDetailsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProvidersDetailsUpdate(id: number, serviceProviderUpdate?: ServiceProviderUpdate, options?: any): AxiosPromise<ServiceProviderUpdate> {
            return localVarFp.v1UsersProvidersDetailsUpdate(id, serviceProviderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * List available skills for service providers.
         * @param {number} [category] 
         * @param {boolean} [isActive] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersSkillsList(category?: number, isActive?: boolean, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedMasterSkillList> {
            return localVarFp.v1UsersSkillsList(category, isActive, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1Api - interface
 * @export
 * @interface V1Api
 */
export interface V1ApiInterface {
    /**
     * Authenticate user with Firebase ID token or register new user if verified.
     * @param {FireBaseAuth} fireBaseAuth 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1AuthFirebaseCreate(fireBaseAuth: FireBaseAuth, options?: AxiosRequestConfig): AxiosPromise<FireBaseAuth>;

    /**
     * User logout view - enhanced version of api_users LogOutView
     * @param {LogoutResponse} logoutResponse 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1AuthLogoutCreate(logoutResponse: LogoutResponse, options?: AxiosRequestConfig): AxiosPromise<LogoutResponse>;

    /**
     * Mobile-optimized view for chat conversation list.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ChatConversationsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedChatConversationList>;

    /**
     * Mobile-optimized view for chat conversation details with messages.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ChatConversationsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<ChatConversationDetail>;

    /**
     * Send a message to a chat room.
     * @param {number} id 
     * @param {ChatSendMessage} chatSendMessage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ChatConversationsSendCreate(id: number, chatSendMessage: ChatSendMessage, options?: AxiosRequestConfig): AxiosPromise<ChatSendMessage>;

    /**
     * Get WebSocket connection info for the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ChatWebsocketInfoRetrieve(options?: AxiosRequestConfig): AxiosPromise<WebSocketInfo>;

    /**
     * Languages - Read-only (managed via admin/fixtures).
     * @param {boolean} [isActive] 
     * @param {boolean} [isDefault] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreLanguagesList(isActive?: boolean, isDefault?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedLanguageList>;

    /**
     * Languages - Read-only (managed via admin/fixtures).
     * @param {number} id A unique integer value identifying this Language.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreLanguagesRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Language>;

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {ServiceAreaCreateUpdate} serviceAreaCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceAreasCreate(serviceAreaCreateUpdate: ServiceAreaCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceAreaCreateUpdate>;

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceAreasDestroy(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {boolean} [isActive] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceAreasList(isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedServiceAreaList>;

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Area.
     * @param {PatchedServiceAreaCreateUpdate} [patchedServiceAreaCreateUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceAreasPartialUpdate(id: number, patchedServiceAreaCreateUpdate?: PatchedServiceAreaCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceAreaCreateUpdate>;

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceAreasRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<ServiceArea>;

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Area.
     * @param {ServiceAreaCreateUpdate} serviceAreaCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceAreasUpdate(id: number, serviceAreaCreateUpdate: ServiceAreaCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceAreaCreateUpdate>;

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {ServiceCategoryCreateUpdate} serviceCategoryCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceCategoriesCreate(serviceCategoryCreateUpdate: ServiceCategoryCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceCategoryCreateUpdate>;

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceCategoriesDestroy(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {boolean} [featured] 
     * @param {boolean} [isActive] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceCategoriesList(featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedServiceCategoryList>;

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Category.
     * @param {PatchedServiceCategoryCreateUpdate} [patchedServiceCategoryCreateUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceCategoriesPartialUpdate(id: number, patchedServiceCategoryCreateUpdate?: PatchedServiceCategoryCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceCategoryCreateUpdate>;

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceCategoriesRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<ServiceCategory>;

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Category.
     * @param {ServiceCategoryCreateUpdate} serviceCategoryCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceCategoriesUpdate(id: number, serviceCategoryCreateUpdate: ServiceCategoryCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceCategoryCreateUpdate>;

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {ServiceSubcategoryCreateUpdate} serviceSubcategoryCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceSubcategoriesCreate(serviceSubcategoryCreateUpdate: ServiceSubcategoryCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceSubcategoryCreateUpdate>;

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Subcategory.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceSubcategoriesDestroy(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {number} [category] 
     * @param {boolean} [featured] 
     * @param {boolean} [isActive] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceSubcategoriesList(category?: number, featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedServiceSubcategoryList>;

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Subcategory.
     * @param {PatchedServiceSubcategoryCreateUpdate} [patchedServiceSubcategoryCreateUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceSubcategoriesPartialUpdate(id: number, patchedServiceSubcategoryCreateUpdate?: PatchedServiceSubcategoryCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceSubcategoryCreateUpdate>;

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Subcategory.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceSubcategoriesRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<ServiceSubcategory>;

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {number} id A unique integer value identifying this Service Subcategory.
     * @param {ServiceSubcategoryCreateUpdate} serviceSubcategoryCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreServiceSubcategoriesUpdate(id: number, serviceSubcategoryCreateUpdate: ServiceSubcategoryCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceSubcategoryCreateUpdate>;

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {SupportFAQCreateUpdate} supportFAQCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSupportFaqCreate(supportFAQCreateUpdate: SupportFAQCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<SupportFAQCreateUpdate>;

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {number} id A unique integer value identifying this Support FAQ.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSupportFaqDestroy(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {'account' | 'general' | 'reviews' | 'safety' | 'search' | 'specialist'} [category] * &#x60;general&#x60; - General * &#x60;specialist&#x60; - Specialist * &#x60;reviews&#x60; - Reviews * &#x60;account&#x60; - Account * &#x60;search&#x60; - Найти * &#x60;safety&#x60; - Safety
     * @param {boolean} [isActive] 
     * @param {number} [language] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSupportFaqList(category?: 'account' | 'general' | 'reviews' | 'safety' | 'search' | 'specialist', isActive?: boolean, language?: number, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedSupportFAQList>;

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {number} id A unique integer value identifying this Support FAQ.
     * @param {PatchedSupportFAQCreateUpdate} [patchedSupportFAQCreateUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSupportFaqPartialUpdate(id: number, patchedSupportFAQCreateUpdate?: PatchedSupportFAQCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<SupportFAQCreateUpdate>;

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {number} id A unique integer value identifying this Support FAQ.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSupportFaqRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<SupportFAQ>;

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {number} id A unique integer value identifying this Support FAQ.
     * @param {SupportFAQCreateUpdate} supportFAQCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSupportFaqUpdate(id: number, supportFAQCreateUpdate: SupportFAQCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<SupportFAQCreateUpdate>;

    /**
     * System Settings - Full CRUD with admin access.
     * @param {SystemSettingsCreateUpdate} systemSettingsCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSystemSettingsCreate(systemSettingsCreateUpdate: SystemSettingsCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<SystemSettingsCreateUpdate>;

    /**
     * System Settings - Full CRUD with admin access.
     * @param {number} id A unique integer value identifying this System Setting.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSystemSettingsDestroy(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * System Settings - Full CRUD with admin access.
     * @param {string} [category] 
     * @param {boolean} [isActive] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSystemSettingsList(category?: string, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedSystemSettingsList>;

    /**
     * System Settings - Full CRUD with admin access.
     * @param {number} id A unique integer value identifying this System Setting.
     * @param {PatchedSystemSettingsCreateUpdate} [patchedSystemSettingsCreateUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSystemSettingsPartialUpdate(id: number, patchedSystemSettingsCreateUpdate?: PatchedSystemSettingsCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<SystemSettingsCreateUpdate>;

    /**
     * System Settings - Full CRUD with admin access.
     * @param {number} id A unique integer value identifying this System Setting.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSystemSettingsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<SystemSettings>;

    /**
     * System Settings - Full CRUD with admin access.
     * @param {number} id A unique integer value identifying this System Setting.
     * @param {SystemSettingsCreateUpdate} systemSettingsCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1CoreSystemSettingsUpdate(id: number, systemSettingsCreateUpdate: SystemSettingsCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<SystemSettingsCreateUpdate>;

    /**
     * Get notification counts for current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1NotificationsCountRetrieve(options?: AxiosRequestConfig): AxiosPromise<Notification>;

    /**
     * Create new notifications (admin only).
     * @param {NotificationCreate} notificationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1NotificationsCreateCreate(notificationCreate: NotificationCreate, options?: AxiosRequestConfig): AxiosPromise<NotificationCreate>;

    /**
     * List notifications for the current user.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1NotificationsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedNotificationList>;

    /**
     * Mark all notifications as read for current user.
     * @param {Notification} notification 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1NotificationsMarkAllReadCreate(notification: Notification, options?: AxiosRequestConfig): AxiosPromise<Notification>;

    /**
     * Retrieve and update individual notifications.
     * @param {number} id 
     * @param {PatchedNotificationUpdate} [patchedNotificationUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1NotificationsPartialUpdate(id: number, patchedNotificationUpdate?: PatchedNotificationUpdate, options?: AxiosRequestConfig): AxiosPromise<NotificationUpdate>;

    /**
     * Get recent notifications (last 7 days).
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1NotificationsRecentList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedNotificationList>;

    /**
     * Retrieve and update individual notifications.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1NotificationsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Notification>;

    /**
     * Get unread notifications for current user.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1NotificationsUnreadList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedNotificationList>;

    /**
     * Retrieve and update individual notifications.
     * @param {number} id 
     * @param {NotificationUpdate} [notificationUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1NotificationsUpdate(id: number, notificationUpdate?: NotificationUpdate, options?: AxiosRequestConfig): AxiosPromise<NotificationUpdate>;

    /**
     * List all order assignments (admin view).
     * @param {number} [order] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [provider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersAssignmentsList(order?: number, ordering?: string, page?: number, pageSize?: number, provider?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOrderAssignmentList>;

    /**
     * View and update order assignment details.
     * @param {number} id 
     * @param {PatchedOrderAssignment} [patchedOrderAssignment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersAssignmentsPartialUpdate(id: number, patchedOrderAssignment?: PatchedOrderAssignment, options?: AxiosRequestConfig): AxiosPromise<OrderAssignment>;

    /**
     * View and update order assignment details.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersAssignmentsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<OrderAssignment>;

    /**
     * View and update order assignment details.
     * @param {number} id 
     * @param {OrderAssignment} orderAssignment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersAssignmentsUpdate(id: number, orderAssignment: OrderAssignment, options?: AxiosRequestConfig): AxiosPromise<OrderAssignment>;

    /**
     * Accept a bid and create order assignment.
     * @param {number} bidId 
     * @param {BidAction} [bidAction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersBidsAcceptCreate(bidId: number, bidAction?: BidAction, options?: AxiosRequestConfig): AxiosPromise<BidAction>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} orderId 
     * @param {BidCreateUpdate} bidCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersBidsCreate(orderId: number, bidCreateUpdate: BidCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<BidCreateUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersBidsDestroy(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * List all bids (admin view).
     * @param {boolean} [isNegotiable] 
     * @param {number} [order] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {'accepted' | 'pending' | 'rejected' | 'withdrawn'} [status] * &#x60;pending&#x60; - Pending * &#x60;accepted&#x60; - Accepted * &#x60;rejected&#x60; - Rejected * &#x60;withdrawn&#x60; - Withdrawn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersBidsList(isNegotiable?: boolean, order?: number, ordering?: string, page?: number, pageSize?: number, status?: 'accepted' | 'pending' | 'rejected' | 'withdrawn', options?: AxiosRequestConfig): AxiosPromise<PaginatedBidList>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {PatchedBidCreateUpdate} [patchedBidCreateUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersBidsPartialUpdate(id: number, patchedBidCreateUpdate?: PatchedBidCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<BidCreateUpdate>;

    /**
     * Reject a bid.
     * @param {number} bidId 
     * @param {BidAction} [bidAction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersBidsRejectCreate(bidId: number, bidAction?: BidAction, options?: AxiosRequestConfig): AxiosPromise<BidAction>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersBidsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Bid>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {BidCreateUpdate} bidCreateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersBidsUpdate(id: number, bidCreateUpdate: BidCreateUpdate, options?: AxiosRequestConfig): AxiosPromise<BidCreateUpdate>;

    /**
     * Withdraw a bid (by provider).
     * @param {number} bidId 
     * @param {BidAction} [bidAction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersBidsWithdrawCreate(bidId: number, bidAction?: BidAction, options?: AxiosRequestConfig): AxiosPromise<BidAction>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {OrderCreate} orderCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersCreateCreate(orderCreate: OrderCreate, options?: AxiosRequestConfig): AxiosPromise<OrderCreate>;

    /**
     * List all orders (admin view).
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {number} [serviceSubcategory] 
     * @param {'assigned' | 'bidding' | 'cancelled' | 'completed' | 'disputed' | 'draft' | 'in_progress' | 'published'} [status] * &#x60;draft&#x60; - Draft * &#x60;published&#x60; - Published * &#x60;bidding&#x60; - Bidding * &#x60;assigned&#x60; - Assigned * &#x60;in_progress&#x60; - In Progress * &#x60;completed&#x60; - Completed * &#x60;cancelled&#x60; - Cancelled * &#x60;disputed&#x60; - Disputed
     * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersList(ordering?: string, page?: number, pageSize?: number, search?: string, serviceSubcategory?: number, status?: 'assigned' | 'bidding' | 'cancelled' | 'completed' | 'disputed' | 'draft' | 'in_progress' | 'published', urgency?: 'high' | 'low' | 'medium' | 'urgent', options?: AxiosRequestConfig): AxiosPromise<PaginatedOrderList>;

    /**
     * Get current user\'s assignments (as service provider).
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersMyAssignmentsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOrderAssignmentList>;

    /**
     * Get current user\'s bids (as service provider).
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersMyBidsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedBidList>;

    /**
     * Get current user\'s orders (as client).
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersMyList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedOrderList>;

    /**
     * Get assignments for current user\'s orders (as client).
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersMyOrdersAssignmentsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOrderAssignmentList>;

    /**
     * Get bids for current user\'s orders (as client).
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersMyOrdersBidsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedBidList>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {PatchedOrderUpdate} [patchedOrderUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersPartialUpdate(id: number, patchedOrderUpdate?: PatchedOrderUpdate, options?: AxiosRequestConfig): AxiosPromise<OrderUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Order>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {OrderUpdate} orderUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1OrdersUpdate(id: number, orderUpdate: OrderUpdate, options?: AxiosRequestConfig): AxiosPromise<OrderUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {PaymentCreate} paymentCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsCreateCreate(paymentCreate: PaymentCreate, options?: AxiosRequestConfig): AxiosPromise<PaymentCreate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {InvoiceCreate} invoiceCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsInvoicesCreateCreate(invoiceCreate: InvoiceCreate, options?: AxiosRequestConfig): AxiosPromise<InvoiceCreate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsInvoicesList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedInvoiceList>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsInvoicesRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Invoice>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedPaymentList>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {PaymentMethodCreate} paymentMethodCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsMethodsCreateCreate(paymentMethodCreate: PaymentMethodCreate, options?: AxiosRequestConfig): AxiosPromise<PaymentMethodCreate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsMethodsDestroy(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsMethodsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPaymentMethodList>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {PatchedPaymentMethodUpdate} [patchedPaymentMethodUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsMethodsPartialUpdate(id: number, patchedPaymentMethodUpdate?: PatchedPaymentMethodUpdate, options?: AxiosRequestConfig): AxiosPromise<PaymentMethodUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsMethodsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<PaymentMethod>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {PaymentMethodUpdate} [paymentMethodUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsMethodsUpdate(id: number, paymentMethodUpdate?: PaymentMethodUpdate, options?: AxiosRequestConfig): AxiosPromise<PaymentMethodUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {PatchedPaymentCreate} [patchedPaymentCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsPartialUpdate(id: number, patchedPaymentCreate?: PatchedPaymentCreate, options?: AxiosRequestConfig): AxiosPromise<PaymentCreate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Payment>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {PaymentCreate} paymentCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsUpdate(id: number, paymentCreate: PaymentCreate, options?: AxiosRequestConfig): AxiosPromise<PaymentCreate>;

    /**
     * List webhook events.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsWebhooksEventsRetrieve(options?: AxiosRequestConfig): AxiosPromise<StripeWebhookEvent>;

    /**
     * Retry processing a webhook event.
     * @param {number} eventId 
     * @param {WebhookRetryResponse} webhookRetryResponse 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsWebhooksEventsRetryCreate(eventId: number, webhookRetryResponse: WebhookRetryResponse, options?: AxiosRequestConfig): AxiosPromise<WebhookRetryResponse>;

    /**
     * API view for Stripe webhook handling.
     * @param {WebhookResponse} webhookResponse 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1PaymentsWebhooksStripeDrfCreate(webhookResponse: WebhookResponse, options?: AxiosRequestConfig): AxiosPromise<WebhookResponse>;

    /**
     * Upload profile image
     * @param {UserUpdate} [userUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ProfileCreate(userUpdate?: UserUpdate, options?: AxiosRequestConfig): AxiosPromise<UserUpdate>;

    /**
     * User profile view with image upload
     * @param {PatchedUserUpdate} [patchedUserUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ProfilePartialUpdate(patchedUserUpdate?: PatchedUserUpdate, options?: AxiosRequestConfig): AxiosPromise<UserUpdate>;

    /**
     * User profile view with image upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ProfileRetrieve(options?: AxiosRequestConfig): AxiosPromise<UserProfile>;

    /**
     * User profile view with image upload
     * @param {UserUpdate} [userUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ProfileUpdate(userUpdate?: UserUpdate, options?: AxiosRequestConfig): AxiosPromise<UserUpdate>;

    /**
     * Get review analytics.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ReviewsAnalyticsRetrieve(options?: AxiosRequestConfig): AxiosPromise<ReviewAnalytics>;

    /**
     * List and create reviews.
     * @param {ReviewCreate} reviewCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ReviewsCreate(reviewCreate: ReviewCreate, options?: AxiosRequestConfig): AxiosPromise<ReviewCreate>;

    /**
     * Retrieve, update, and delete specific review.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ReviewsDestroy(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * List and create reviews.
     * @param {boolean} [isVerified] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [overallRating] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ReviewsList(isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedReviewList>;

    /**
     * Get reviews for a specific order.
     * @param {number} orderId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ReviewsOrderList(orderId: number, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedReviewList>;

    /**
     * Retrieve, update, and delete specific review.
     * @param {number} id 
     * @param {PatchedReviewUpdate} [patchedReviewUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ReviewsPartialUpdate(id: number, patchedReviewUpdate?: PatchedReviewUpdate, options?: AxiosRequestConfig): AxiosPromise<ReviewUpdate>;

    /**
     * Get reviews for a specific service provider.
     * @param {number} providerId 
     * @param {boolean} [isVerified] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [overallRating] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ReviewsProviderList(providerId: number, isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedReviewList>;

    /**
     * Retrieve, update, and delete specific review.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ReviewsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Review>;

    /**
     * Retrieve, update, and delete specific review.
     * @param {number} id 
     * @param {ReviewUpdate} reviewUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1ReviewsUpdate(id: number, reviewUpdate: ReviewUpdate, options?: AxiosRequestConfig): AxiosPromise<ReviewUpdate>;

    /**
     * Simple global search across all content types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1SearchGlobalRetrieve(options?: AxiosRequestConfig): AxiosPromise<GlobalSearchResponse>;

    /**
     * Search specifically for orders (job vacancies).
     * @param {string} [city] Filter by city
     * @param {number} [maxBudget] Maximum budget
     * @param {number} [minBudget] Minimum budget
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [q] Search query
     * @param {number} [serviceCategory] Filter by service category ID
     * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1SearchOrdersList(city?: string, maxBudget?: number, minBudget?: number, ordering?: string, page?: number, pageSize?: number, q?: string, serviceCategory?: number, urgency?: 'high' | 'low' | 'medium' | 'urgent', options?: AxiosRequestConfig): AxiosPromise<PaginatedOrderList>;

    /**
     * Search specifically for service providers.
     * @param {string} [city] Filter by city
     * @param {number} [minRating] Minimum rating
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [q] Search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1SearchProvidersList(city?: string, minRating?: number, ordering?: string, page?: number, pageSize?: number, q?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedServiceProviderList>;

    /**
     * List all users - not in api_users, useful for admin
     * @param {boolean} [blocked] 
     * @param {boolean} [isActive] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {'free' | 'paid' | 'premium_paid'} [userType] * &#x60;free&#x60; - Бесплатный * &#x60;paid&#x60; - Оплаченный * &#x60;premium_paid&#x60; - Премиум оплаченный
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersList(blocked?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, userType?: 'free' | 'paid' | 'premium_paid', options?: AxiosRequestConfig): AxiosPromise<PaginatedUserListList>;

    /**
     * Manage my service provider certificates.
     * @param {Certificate} certificate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyCertificatesCreate(certificate: Certificate, options?: AxiosRequestConfig): AxiosPromise<Certificate>;

    /**
     * Manage my service provider certificates.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyCertificatesList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedCertificateList>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {ClientUpdate} [clientUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyClientCreateCreate(clientUpdate?: ClientUpdate, options?: AxiosRequestConfig): AxiosPromise<ClientUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {PatchedClientUpdate} [patchedClientUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyClientUpdatePartialUpdate(patchedClientUpdate?: PatchedClientUpdate, options?: AxiosRequestConfig): AxiosPromise<ClientUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {ClientUpdate} [clientUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyClientUpdateUpdate(clientUpdate?: ClientUpdate, options?: AxiosRequestConfig): AxiosPromise<ClientUpdate>;

    /**
     * Manage my service provider portfolio items.
     * @param {PortfolioItem} portfolioItem 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyPortfolioCreate(portfolioItem: PortfolioItem, options?: AxiosRequestConfig): AxiosPromise<PortfolioItem>;

    /**
     * Manage my service provider portfolio items.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyPortfolioList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPortfolioItemList>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {PatchedAdvancedProfileUpdate} [patchedAdvancedProfileUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyProfileAdvancedPartialUpdate(patchedAdvancedProfileUpdate?: PatchedAdvancedProfileUpdate, options?: AxiosRequestConfig): AxiosPromise<AdvancedProfileUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyProfileAdvancedRetrieve(options?: AxiosRequestConfig): AxiosPromise<AdvancedProfile>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {AdvancedProfileUpdate} [advancedProfileUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyProfileAdvancedUpdate(advancedProfileUpdate?: AdvancedProfileUpdate, options?: AxiosRequestConfig): AxiosPromise<AdvancedProfileUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {PatchedUserProfileUpdate} [patchedUserProfileUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyProfilePartialUpdate(patchedUserProfileUpdate?: PatchedUserProfileUpdate, options?: AxiosRequestConfig): AxiosPromise<UserProfileUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyProfileRetrieve(options?: AxiosRequestConfig): AxiosPromise<UserProfileDetail>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {UserProfileUpdate} [userProfileUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyProfileUpdate(userProfileUpdate?: UserProfileUpdate, options?: AxiosRequestConfig): AxiosPromise<UserProfileUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyProviderCreateCreate(serviceProviderUpdate?: ServiceProviderUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceProviderUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyProviderUpdatePartialUpdate(patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceProviderUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyProviderUpdateUpdate(serviceProviderUpdate?: ServiceProviderUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceProviderUpdate>;

    /**
     * Manage my service provider skills.
     * @param {ServiceProviderSkill} serviceProviderSkill 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMySkillsCreate(serviceProviderSkill: ServiceProviderSkill, options?: AxiosRequestConfig): AxiosPromise<ServiceProviderSkill>;

    /**
     * Manage my service provider skills.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMySkillsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedServiceProviderSkillList>;

    /**
     * Manage my provider statistics.
     * @param {PatchedProviderStatistics} [patchedProviderStatistics] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyStatisticsPartialUpdate(patchedProviderStatistics?: PatchedProviderStatistics, options?: AxiosRequestConfig): AxiosPromise<ProviderStatistics>;

    /**
     * Manage my provider statistics.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyStatisticsRetrieve(options?: AxiosRequestConfig): AxiosPromise<ProviderStatistics>;

    /**
     * Manage my provider statistics.
     * @param {ProviderStatistics} [providerStatistics] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersMyStatisticsUpdate(providerStatistics?: ProviderStatistics, options?: AxiosRequestConfig): AxiosPromise<ProviderStatistics>;

    /**
     * List available professions.
     * @param {number} [category] 
     * @param {boolean} [isActive] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersProfessionsList(category?: number, isActive?: boolean, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedProfessionList>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersProvidersDetailsPartialUpdate(id: number, patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceProviderUpdate>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersProvidersDetailsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<ServiceProviderDetail>;

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {number} id 
     * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersProvidersDetailsUpdate(id: number, serviceProviderUpdate?: ServiceProviderUpdate, options?: AxiosRequestConfig): AxiosPromise<ServiceProviderUpdate>;

    /**
     * List available skills for service providers.
     * @param {number} [category] 
     * @param {boolean} [isActive] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [search] A search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ApiInterface
     */
    v1UsersSkillsList(category?: number, isActive?: boolean, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): AxiosPromise<PaginatedMasterSkillList>;

}

/**
 * Request parameters for v1AuthFirebaseCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AuthFirebaseCreateRequest
 */
export interface V1ApiV1AuthFirebaseCreateRequest {
    /**
     * 
     * @type {FireBaseAuth}
     * @memberof V1ApiV1AuthFirebaseCreate
     */
    readonly fireBaseAuth: FireBaseAuth
}

/**
 * Request parameters for v1AuthLogoutCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AuthLogoutCreateRequest
 */
export interface V1ApiV1AuthLogoutCreateRequest {
    /**
     * 
     * @type {LogoutResponse}
     * @memberof V1ApiV1AuthLogoutCreate
     */
    readonly logoutResponse: LogoutResponse
}

/**
 * Request parameters for v1ChatConversationsList operation in V1Api.
 * @export
 * @interface V1ApiV1ChatConversationsListRequest
 */
export interface V1ApiV1ChatConversationsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ChatConversationsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ChatConversationsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ChatConversationsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1ChatConversationsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1ChatConversationsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1ChatConversationsRetrieveRequest
 */
export interface V1ApiV1ChatConversationsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatConversationsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1ChatConversationsSendCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ChatConversationsSendCreateRequest
 */
export interface V1ApiV1ChatConversationsSendCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatConversationsSendCreate
     */
    readonly id: number

    /**
     * 
     * @type {ChatSendMessage}
     * @memberof V1ApiV1ChatConversationsSendCreate
     */
    readonly chatSendMessage: ChatSendMessage
}

/**
 * Request parameters for v1CoreLanguagesList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreLanguagesListRequest
 */
export interface V1ApiV1CoreLanguagesListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly isDefault?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly search?: string
}

/**
 * Request parameters for v1CoreLanguagesRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1CoreLanguagesRetrieveRequest
 */
export interface V1ApiV1CoreLanguagesRetrieveRequest {
    /**
     * A unique integer value identifying this Language.
     * @type {number}
     * @memberof V1ApiV1CoreLanguagesRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreServiceAreasCreate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceAreasCreateRequest
 */
export interface V1ApiV1CoreServiceAreasCreateRequest {
    /**
     * 
     * @type {ServiceAreaCreateUpdate}
     * @memberof V1ApiV1CoreServiceAreasCreate
     */
    readonly serviceAreaCreateUpdate: ServiceAreaCreateUpdate
}

/**
 * Request parameters for v1CoreServiceAreasDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceAreasDestroyRequest
 */
export interface V1ApiV1CoreServiceAreasDestroyRequest {
    /**
     * A unique integer value identifying this Service Area.
     * @type {number}
     * @memberof V1ApiV1CoreServiceAreasDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreServiceAreasList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceAreasListRequest
 */
export interface V1ApiV1CoreServiceAreasListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly isActive?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly search?: string
}

/**
 * Request parameters for v1CoreServiceAreasPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceAreasPartialUpdateRequest
 */
export interface V1ApiV1CoreServiceAreasPartialUpdateRequest {
    /**
     * A unique integer value identifying this Service Area.
     * @type {number}
     * @memberof V1ApiV1CoreServiceAreasPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedServiceAreaCreateUpdate}
     * @memberof V1ApiV1CoreServiceAreasPartialUpdate
     */
    readonly patchedServiceAreaCreateUpdate?: PatchedServiceAreaCreateUpdate
}

/**
 * Request parameters for v1CoreServiceAreasRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceAreasRetrieveRequest
 */
export interface V1ApiV1CoreServiceAreasRetrieveRequest {
    /**
     * A unique integer value identifying this Service Area.
     * @type {number}
     * @memberof V1ApiV1CoreServiceAreasRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreServiceAreasUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceAreasUpdateRequest
 */
export interface V1ApiV1CoreServiceAreasUpdateRequest {
    /**
     * A unique integer value identifying this Service Area.
     * @type {number}
     * @memberof V1ApiV1CoreServiceAreasUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ServiceAreaCreateUpdate}
     * @memberof V1ApiV1CoreServiceAreasUpdate
     */
    readonly serviceAreaCreateUpdate: ServiceAreaCreateUpdate
}

/**
 * Request parameters for v1CoreServiceCategoriesCreate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceCategoriesCreateRequest
 */
export interface V1ApiV1CoreServiceCategoriesCreateRequest {
    /**
     * 
     * @type {ServiceCategoryCreateUpdate}
     * @memberof V1ApiV1CoreServiceCategoriesCreate
     */
    readonly serviceCategoryCreateUpdate: ServiceCategoryCreateUpdate
}

/**
 * Request parameters for v1CoreServiceCategoriesDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceCategoriesDestroyRequest
 */
export interface V1ApiV1CoreServiceCategoriesDestroyRequest {
    /**
     * A unique integer value identifying this Service Category.
     * @type {number}
     * @memberof V1ApiV1CoreServiceCategoriesDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreServiceCategoriesList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceCategoriesListRequest
 */
export interface V1ApiV1CoreServiceCategoriesListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly featured?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly isActive?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly search?: string
}

/**
 * Request parameters for v1CoreServiceCategoriesPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceCategoriesPartialUpdateRequest
 */
export interface V1ApiV1CoreServiceCategoriesPartialUpdateRequest {
    /**
     * A unique integer value identifying this Service Category.
     * @type {number}
     * @memberof V1ApiV1CoreServiceCategoriesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedServiceCategoryCreateUpdate}
     * @memberof V1ApiV1CoreServiceCategoriesPartialUpdate
     */
    readonly patchedServiceCategoryCreateUpdate?: PatchedServiceCategoryCreateUpdate
}

/**
 * Request parameters for v1CoreServiceCategoriesRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceCategoriesRetrieveRequest
 */
export interface V1ApiV1CoreServiceCategoriesRetrieveRequest {
    /**
     * A unique integer value identifying this Service Category.
     * @type {number}
     * @memberof V1ApiV1CoreServiceCategoriesRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreServiceCategoriesUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceCategoriesUpdateRequest
 */
export interface V1ApiV1CoreServiceCategoriesUpdateRequest {
    /**
     * A unique integer value identifying this Service Category.
     * @type {number}
     * @memberof V1ApiV1CoreServiceCategoriesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ServiceCategoryCreateUpdate}
     * @memberof V1ApiV1CoreServiceCategoriesUpdate
     */
    readonly serviceCategoryCreateUpdate: ServiceCategoryCreateUpdate
}

/**
 * Request parameters for v1CoreServiceSubcategoriesCreate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceSubcategoriesCreateRequest
 */
export interface V1ApiV1CoreServiceSubcategoriesCreateRequest {
    /**
     * 
     * @type {ServiceSubcategoryCreateUpdate}
     * @memberof V1ApiV1CoreServiceSubcategoriesCreate
     */
    readonly serviceSubcategoryCreateUpdate: ServiceSubcategoryCreateUpdate
}

/**
 * Request parameters for v1CoreServiceSubcategoriesDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceSubcategoriesDestroyRequest
 */
export interface V1ApiV1CoreServiceSubcategoriesDestroyRequest {
    /**
     * A unique integer value identifying this Service Subcategory.
     * @type {number}
     * @memberof V1ApiV1CoreServiceSubcategoriesDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreServiceSubcategoriesList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceSubcategoriesListRequest
 */
export interface V1ApiV1CoreServiceSubcategoriesListRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly category?: number

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly featured?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly isActive?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly search?: string
}

/**
 * Request parameters for v1CoreServiceSubcategoriesPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceSubcategoriesPartialUpdateRequest
 */
export interface V1ApiV1CoreServiceSubcategoriesPartialUpdateRequest {
    /**
     * A unique integer value identifying this Service Subcategory.
     * @type {number}
     * @memberof V1ApiV1CoreServiceSubcategoriesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedServiceSubcategoryCreateUpdate}
     * @memberof V1ApiV1CoreServiceSubcategoriesPartialUpdate
     */
    readonly patchedServiceSubcategoryCreateUpdate?: PatchedServiceSubcategoryCreateUpdate
}

/**
 * Request parameters for v1CoreServiceSubcategoriesRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceSubcategoriesRetrieveRequest
 */
export interface V1ApiV1CoreServiceSubcategoriesRetrieveRequest {
    /**
     * A unique integer value identifying this Service Subcategory.
     * @type {number}
     * @memberof V1ApiV1CoreServiceSubcategoriesRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreServiceSubcategoriesUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceSubcategoriesUpdateRequest
 */
export interface V1ApiV1CoreServiceSubcategoriesUpdateRequest {
    /**
     * A unique integer value identifying this Service Subcategory.
     * @type {number}
     * @memberof V1ApiV1CoreServiceSubcategoriesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ServiceSubcategoryCreateUpdate}
     * @memberof V1ApiV1CoreServiceSubcategoriesUpdate
     */
    readonly serviceSubcategoryCreateUpdate: ServiceSubcategoryCreateUpdate
}

/**
 * Request parameters for v1CoreSupportFaqCreate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSupportFaqCreateRequest
 */
export interface V1ApiV1CoreSupportFaqCreateRequest {
    /**
     * 
     * @type {SupportFAQCreateUpdate}
     * @memberof V1ApiV1CoreSupportFaqCreate
     */
    readonly supportFAQCreateUpdate: SupportFAQCreateUpdate
}

/**
 * Request parameters for v1CoreSupportFaqDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSupportFaqDestroyRequest
 */
export interface V1ApiV1CoreSupportFaqDestroyRequest {
    /**
     * A unique integer value identifying this Support FAQ.
     * @type {number}
     * @memberof V1ApiV1CoreSupportFaqDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreSupportFaqList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSupportFaqListRequest
 */
export interface V1ApiV1CoreSupportFaqListRequest {
    /**
     * * &#x60;general&#x60; - General * &#x60;specialist&#x60; - Specialist * &#x60;reviews&#x60; - Reviews * &#x60;account&#x60; - Account * &#x60;search&#x60; - Найти * &#x60;safety&#x60; - Safety
     * @type {'account' | 'general' | 'reviews' | 'safety' | 'search' | 'specialist'}
     * @memberof V1ApiV1CoreSupportFaqList
     */
    readonly category?: 'account' | 'general' | 'reviews' | 'safety' | 'search' | 'specialist'

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreSupportFaqList
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1CoreSupportFaqList
     */
    readonly language?: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreSupportFaqList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreSupportFaqList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreSupportFaqList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreSupportFaqList
     */
    readonly search?: string
}

/**
 * Request parameters for v1CoreSupportFaqPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSupportFaqPartialUpdateRequest
 */
export interface V1ApiV1CoreSupportFaqPartialUpdateRequest {
    /**
     * A unique integer value identifying this Support FAQ.
     * @type {number}
     * @memberof V1ApiV1CoreSupportFaqPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedSupportFAQCreateUpdate}
     * @memberof V1ApiV1CoreSupportFaqPartialUpdate
     */
    readonly patchedSupportFAQCreateUpdate?: PatchedSupportFAQCreateUpdate
}

/**
 * Request parameters for v1CoreSupportFaqRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSupportFaqRetrieveRequest
 */
export interface V1ApiV1CoreSupportFaqRetrieveRequest {
    /**
     * A unique integer value identifying this Support FAQ.
     * @type {number}
     * @memberof V1ApiV1CoreSupportFaqRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreSupportFaqUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSupportFaqUpdateRequest
 */
export interface V1ApiV1CoreSupportFaqUpdateRequest {
    /**
     * A unique integer value identifying this Support FAQ.
     * @type {number}
     * @memberof V1ApiV1CoreSupportFaqUpdate
     */
    readonly id: number

    /**
     * 
     * @type {SupportFAQCreateUpdate}
     * @memberof V1ApiV1CoreSupportFaqUpdate
     */
    readonly supportFAQCreateUpdate: SupportFAQCreateUpdate
}

/**
 * Request parameters for v1CoreSystemSettingsCreate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSystemSettingsCreateRequest
 */
export interface V1ApiV1CoreSystemSettingsCreateRequest {
    /**
     * 
     * @type {SystemSettingsCreateUpdate}
     * @memberof V1ApiV1CoreSystemSettingsCreate
     */
    readonly systemSettingsCreateUpdate: SystemSettingsCreateUpdate
}

/**
 * Request parameters for v1CoreSystemSettingsDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSystemSettingsDestroyRequest
 */
export interface V1ApiV1CoreSystemSettingsDestroyRequest {
    /**
     * A unique integer value identifying this System Setting.
     * @type {number}
     * @memberof V1ApiV1CoreSystemSettingsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreSystemSettingsList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSystemSettingsListRequest
 */
export interface V1ApiV1CoreSystemSettingsListRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly category?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly isActive?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1CoreSystemSettingsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSystemSettingsPartialUpdateRequest
 */
export interface V1ApiV1CoreSystemSettingsPartialUpdateRequest {
    /**
     * A unique integer value identifying this System Setting.
     * @type {number}
     * @memberof V1ApiV1CoreSystemSettingsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedSystemSettingsCreateUpdate}
     * @memberof V1ApiV1CoreSystemSettingsPartialUpdate
     */
    readonly patchedSystemSettingsCreateUpdate?: PatchedSystemSettingsCreateUpdate
}

/**
 * Request parameters for v1CoreSystemSettingsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSystemSettingsRetrieveRequest
 */
export interface V1ApiV1CoreSystemSettingsRetrieveRequest {
    /**
     * A unique integer value identifying this System Setting.
     * @type {number}
     * @memberof V1ApiV1CoreSystemSettingsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1CoreSystemSettingsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSystemSettingsUpdateRequest
 */
export interface V1ApiV1CoreSystemSettingsUpdateRequest {
    /**
     * A unique integer value identifying this System Setting.
     * @type {number}
     * @memberof V1ApiV1CoreSystemSettingsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {SystemSettingsCreateUpdate}
     * @memberof V1ApiV1CoreSystemSettingsUpdate
     */
    readonly systemSettingsCreateUpdate: SystemSettingsCreateUpdate
}

/**
 * Request parameters for v1NotificationsCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsCreateCreateRequest
 */
export interface V1ApiV1NotificationsCreateCreateRequest {
    /**
     * 
     * @type {NotificationCreate}
     * @memberof V1ApiV1NotificationsCreateCreate
     */
    readonly notificationCreate: NotificationCreate
}

/**
 * Request parameters for v1NotificationsList operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsListRequest
 */
export interface V1ApiV1NotificationsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1NotificationsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1NotificationsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1NotificationsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1NotificationsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1NotificationsMarkAllReadCreate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsMarkAllReadCreateRequest
 */
export interface V1ApiV1NotificationsMarkAllReadCreateRequest {
    /**
     * 
     * @type {Notification}
     * @memberof V1ApiV1NotificationsMarkAllReadCreate
     */
    readonly notification: Notification
}

/**
 * Request parameters for v1NotificationsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsPartialUpdateRequest
 */
export interface V1ApiV1NotificationsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1NotificationsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedNotificationUpdate}
     * @memberof V1ApiV1NotificationsPartialUpdate
     */
    readonly patchedNotificationUpdate?: PatchedNotificationUpdate
}

/**
 * Request parameters for v1NotificationsRecentList operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsRecentListRequest
 */
export interface V1ApiV1NotificationsRecentListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1NotificationsRecentList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1NotificationsRecentList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1NotificationsRecentList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1NotificationsRecentList
     */
    readonly search?: string
}

/**
 * Request parameters for v1NotificationsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsRetrieveRequest
 */
export interface V1ApiV1NotificationsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1NotificationsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1NotificationsUnreadList operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsUnreadListRequest
 */
export interface V1ApiV1NotificationsUnreadListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1NotificationsUnreadList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1NotificationsUnreadList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1NotificationsUnreadList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1NotificationsUnreadList
     */
    readonly search?: string
}

/**
 * Request parameters for v1NotificationsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsUpdateRequest
 */
export interface V1ApiV1NotificationsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1NotificationsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {NotificationUpdate}
     * @memberof V1ApiV1NotificationsUpdate
     */
    readonly notificationUpdate?: NotificationUpdate
}

/**
 * Request parameters for v1OrdersAssignmentsList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersAssignmentsListRequest
 */
export interface V1ApiV1OrdersAssignmentsListRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersAssignmentsList
     */
    readonly order?: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersAssignmentsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersAssignmentsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersAssignmentsList
     */
    readonly pageSize?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersAssignmentsList
     */
    readonly provider?: number
}

/**
 * Request parameters for v1OrdersAssignmentsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersAssignmentsPartialUpdateRequest
 */
export interface V1ApiV1OrdersAssignmentsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersAssignmentsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedOrderAssignment}
     * @memberof V1ApiV1OrdersAssignmentsPartialUpdate
     */
    readonly patchedOrderAssignment?: PatchedOrderAssignment
}

/**
 * Request parameters for v1OrdersAssignmentsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersAssignmentsRetrieveRequest
 */
export interface V1ApiV1OrdersAssignmentsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersAssignmentsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1OrdersAssignmentsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersAssignmentsUpdateRequest
 */
export interface V1ApiV1OrdersAssignmentsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersAssignmentsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {OrderAssignment}
     * @memberof V1ApiV1OrdersAssignmentsUpdate
     */
    readonly orderAssignment: OrderAssignment
}

/**
 * Request parameters for v1OrdersBidsAcceptCreate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsAcceptCreateRequest
 */
export interface V1ApiV1OrdersBidsAcceptCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersBidsAcceptCreate
     */
    readonly bidId: number

    /**
     * 
     * @type {BidAction}
     * @memberof V1ApiV1OrdersBidsAcceptCreate
     */
    readonly bidAction?: BidAction
}

/**
 * Request parameters for v1OrdersBidsCreate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsCreateRequest
 */
export interface V1ApiV1OrdersBidsCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersBidsCreate
     */
    readonly orderId: number

    /**
     * 
     * @type {BidCreateUpdate}
     * @memberof V1ApiV1OrdersBidsCreate
     */
    readonly bidCreateUpdate: BidCreateUpdate
}

/**
 * Request parameters for v1OrdersBidsDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsDestroyRequest
 */
export interface V1ApiV1OrdersBidsDestroyRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersBidsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1OrdersBidsList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsListRequest
 */
export interface V1ApiV1OrdersBidsListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1OrdersBidsList
     */
    readonly isNegotiable?: boolean

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersBidsList
     */
    readonly order?: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersBidsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersBidsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersBidsList
     */
    readonly pageSize?: number

    /**
     * * &#x60;pending&#x60; - Pending * &#x60;accepted&#x60; - Accepted * &#x60;rejected&#x60; - Rejected * &#x60;withdrawn&#x60; - Withdrawn
     * @type {'accepted' | 'pending' | 'rejected' | 'withdrawn'}
     * @memberof V1ApiV1OrdersBidsList
     */
    readonly status?: 'accepted' | 'pending' | 'rejected' | 'withdrawn'
}

/**
 * Request parameters for v1OrdersBidsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsPartialUpdateRequest
 */
export interface V1ApiV1OrdersBidsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersBidsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedBidCreateUpdate}
     * @memberof V1ApiV1OrdersBidsPartialUpdate
     */
    readonly patchedBidCreateUpdate?: PatchedBidCreateUpdate
}

/**
 * Request parameters for v1OrdersBidsRejectCreate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsRejectCreateRequest
 */
export interface V1ApiV1OrdersBidsRejectCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersBidsRejectCreate
     */
    readonly bidId: number

    /**
     * 
     * @type {BidAction}
     * @memberof V1ApiV1OrdersBidsRejectCreate
     */
    readonly bidAction?: BidAction
}

/**
 * Request parameters for v1OrdersBidsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsRetrieveRequest
 */
export interface V1ApiV1OrdersBidsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersBidsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1OrdersBidsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsUpdateRequest
 */
export interface V1ApiV1OrdersBidsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersBidsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {BidCreateUpdate}
     * @memberof V1ApiV1OrdersBidsUpdate
     */
    readonly bidCreateUpdate: BidCreateUpdate
}

/**
 * Request parameters for v1OrdersBidsWithdrawCreate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsWithdrawCreateRequest
 */
export interface V1ApiV1OrdersBidsWithdrawCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersBidsWithdrawCreate
     */
    readonly bidId: number

    /**
     * 
     * @type {BidAction}
     * @memberof V1ApiV1OrdersBidsWithdrawCreate
     */
    readonly bidAction?: BidAction
}

/**
 * Request parameters for v1OrdersCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersCreateCreateRequest
 */
export interface V1ApiV1OrdersCreateCreateRequest {
    /**
     * 
     * @type {OrderCreate}
     * @memberof V1ApiV1OrdersCreateCreate
     */
    readonly orderCreate: OrderCreate
}

/**
 * Request parameters for v1OrdersList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersListRequest
 */
export interface V1ApiV1OrdersListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1OrdersList
     */
    readonly search?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersList
     */
    readonly serviceSubcategory?: number

    /**
     * * &#x60;draft&#x60; - Draft * &#x60;published&#x60; - Published * &#x60;bidding&#x60; - Bidding * &#x60;assigned&#x60; - Assigned * &#x60;in_progress&#x60; - In Progress * &#x60;completed&#x60; - Completed * &#x60;cancelled&#x60; - Cancelled * &#x60;disputed&#x60; - Disputed
     * @type {'assigned' | 'bidding' | 'cancelled' | 'completed' | 'disputed' | 'draft' | 'in_progress' | 'published'}
     * @memberof V1ApiV1OrdersList
     */
    readonly status?: 'assigned' | 'bidding' | 'cancelled' | 'completed' | 'disputed' | 'draft' | 'in_progress' | 'published'

    /**
     * * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
     * @type {'high' | 'low' | 'medium' | 'urgent'}
     * @memberof V1ApiV1OrdersList
     */
    readonly urgency?: 'high' | 'low' | 'medium' | 'urgent'
}

/**
 * Request parameters for v1OrdersMyAssignmentsList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersMyAssignmentsListRequest
 */
export interface V1ApiV1OrdersMyAssignmentsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersMyAssignmentsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersMyAssignmentsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersMyAssignmentsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1OrdersMyBidsList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersMyBidsListRequest
 */
export interface V1ApiV1OrdersMyBidsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersMyBidsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersMyBidsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersMyBidsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1OrdersMyList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersMyListRequest
 */
export interface V1ApiV1OrdersMyListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersMyList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersMyList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersMyList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1OrdersMyList
     */
    readonly search?: string
}

/**
 * Request parameters for v1OrdersMyOrdersAssignmentsList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersMyOrdersAssignmentsListRequest
 */
export interface V1ApiV1OrdersMyOrdersAssignmentsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersMyOrdersAssignmentsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersMyOrdersAssignmentsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersMyOrdersAssignmentsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1OrdersMyOrdersBidsList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersMyOrdersBidsListRequest
 */
export interface V1ApiV1OrdersMyOrdersBidsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersMyOrdersBidsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersMyOrdersBidsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersMyOrdersBidsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1OrdersPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersPartialUpdateRequest
 */
export interface V1ApiV1OrdersPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedOrderUpdate}
     * @memberof V1ApiV1OrdersPartialUpdate
     */
    readonly patchedOrderUpdate?: PatchedOrderUpdate
}

/**
 * Request parameters for v1OrdersRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersRetrieveRequest
 */
export interface V1ApiV1OrdersRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1OrdersUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersUpdateRequest
 */
export interface V1ApiV1OrdersUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {OrderUpdate}
     * @memberof V1ApiV1OrdersUpdate
     */
    readonly orderUpdate: OrderUpdate
}

/**
 * Request parameters for v1PaymentsCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsCreateCreateRequest
 */
export interface V1ApiV1PaymentsCreateCreateRequest {
    /**
     * 
     * @type {PaymentCreate}
     * @memberof V1ApiV1PaymentsCreateCreate
     */
    readonly paymentCreate: PaymentCreate
}

/**
 * Request parameters for v1PaymentsInvoicesCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsInvoicesCreateCreateRequest
 */
export interface V1ApiV1PaymentsInvoicesCreateCreateRequest {
    /**
     * 
     * @type {InvoiceCreate}
     * @memberof V1ApiV1PaymentsInvoicesCreateCreate
     */
    readonly invoiceCreate: InvoiceCreate
}

/**
 * Request parameters for v1PaymentsInvoicesList operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsInvoicesListRequest
 */
export interface V1ApiV1PaymentsInvoicesListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1PaymentsInvoicesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1PaymentsInvoicesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1PaymentsInvoicesList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1PaymentsInvoicesRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsInvoicesRetrieveRequest
 */
export interface V1ApiV1PaymentsInvoicesRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsInvoicesRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1PaymentsList operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsListRequest
 */
export interface V1ApiV1PaymentsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1PaymentsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1PaymentsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1PaymentsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1PaymentsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1PaymentsMethodsCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsCreateCreateRequest
 */
export interface V1ApiV1PaymentsMethodsCreateCreateRequest {
    /**
     * 
     * @type {PaymentMethodCreate}
     * @memberof V1ApiV1PaymentsMethodsCreateCreate
     */
    readonly paymentMethodCreate: PaymentMethodCreate
}

/**
 * Request parameters for v1PaymentsMethodsDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsDestroyRequest
 */
export interface V1ApiV1PaymentsMethodsDestroyRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1PaymentsMethodsList operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsListRequest
 */
export interface V1ApiV1PaymentsMethodsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1PaymentsMethodsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1PaymentsMethodsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsPartialUpdateRequest
 */
export interface V1ApiV1PaymentsMethodsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedPaymentMethodUpdate}
     * @memberof V1ApiV1PaymentsMethodsPartialUpdate
     */
    readonly patchedPaymentMethodUpdate?: PatchedPaymentMethodUpdate
}

/**
 * Request parameters for v1PaymentsMethodsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsRetrieveRequest
 */
export interface V1ApiV1PaymentsMethodsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1PaymentsMethodsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsUpdateRequest
 */
export interface V1ApiV1PaymentsMethodsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PaymentMethodUpdate}
     * @memberof V1ApiV1PaymentsMethodsUpdate
     */
    readonly paymentMethodUpdate?: PaymentMethodUpdate
}

/**
 * Request parameters for v1PaymentsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsPartialUpdateRequest
 */
export interface V1ApiV1PaymentsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedPaymentCreate}
     * @memberof V1ApiV1PaymentsPartialUpdate
     */
    readonly patchedPaymentCreate?: PatchedPaymentCreate
}

/**
 * Request parameters for v1PaymentsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsRetrieveRequest
 */
export interface V1ApiV1PaymentsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1PaymentsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsUpdateRequest
 */
export interface V1ApiV1PaymentsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PaymentCreate}
     * @memberof V1ApiV1PaymentsUpdate
     */
    readonly paymentCreate: PaymentCreate
}

/**
 * Request parameters for v1PaymentsWebhooksEventsRetryCreate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsWebhooksEventsRetryCreateRequest
 */
export interface V1ApiV1PaymentsWebhooksEventsRetryCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsWebhooksEventsRetryCreate
     */
    readonly eventId: number

    /**
     * 
     * @type {WebhookRetryResponse}
     * @memberof V1ApiV1PaymentsWebhooksEventsRetryCreate
     */
    readonly webhookRetryResponse: WebhookRetryResponse
}

/**
 * Request parameters for v1PaymentsWebhooksStripeDrfCreate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsWebhooksStripeDrfCreateRequest
 */
export interface V1ApiV1PaymentsWebhooksStripeDrfCreateRequest {
    /**
     * 
     * @type {WebhookResponse}
     * @memberof V1ApiV1PaymentsWebhooksStripeDrfCreate
     */
    readonly webhookResponse: WebhookResponse
}

/**
 * Request parameters for v1ProfileCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ProfileCreateRequest
 */
export interface V1ApiV1ProfileCreateRequest {
    /**
     * 
     * @type {UserUpdate}
     * @memberof V1ApiV1ProfileCreate
     */
    readonly userUpdate?: UserUpdate
}

/**
 * Request parameters for v1ProfilePartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ProfilePartialUpdateRequest
 */
export interface V1ApiV1ProfilePartialUpdateRequest {
    /**
     * 
     * @type {PatchedUserUpdate}
     * @memberof V1ApiV1ProfilePartialUpdate
     */
    readonly patchedUserUpdate?: PatchedUserUpdate
}

/**
 * Request parameters for v1ProfileUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ProfileUpdateRequest
 */
export interface V1ApiV1ProfileUpdateRequest {
    /**
     * 
     * @type {UserUpdate}
     * @memberof V1ApiV1ProfileUpdate
     */
    readonly userUpdate?: UserUpdate
}

/**
 * Request parameters for v1ReviewsCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsCreateRequest
 */
export interface V1ApiV1ReviewsCreateRequest {
    /**
     * 
     * @type {ReviewCreate}
     * @memberof V1ApiV1ReviewsCreate
     */
    readonly reviewCreate: ReviewCreate
}

/**
 * Request parameters for v1ReviewsDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsDestroyRequest
 */
export interface V1ApiV1ReviewsDestroyRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1ReviewsList operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsListRequest
 */
export interface V1ApiV1ReviewsListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1ReviewsList
     */
    readonly isVerified?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ReviewsList
     */
    readonly ordering?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsList
     */
    readonly overallRating?: number

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ReviewsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ReviewsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1ReviewsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1ReviewsOrderList operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsOrderListRequest
 */
export interface V1ApiV1ReviewsOrderListRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsOrderList
     */
    readonly orderId: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ReviewsOrderList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ReviewsOrderList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ReviewsOrderList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1ReviewsOrderList
     */
    readonly search?: string
}

/**
 * Request parameters for v1ReviewsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsPartialUpdateRequest
 */
export interface V1ApiV1ReviewsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedReviewUpdate}
     * @memberof V1ApiV1ReviewsPartialUpdate
     */
    readonly patchedReviewUpdate?: PatchedReviewUpdate
}

/**
 * Request parameters for v1ReviewsProviderList operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsProviderListRequest
 */
export interface V1ApiV1ReviewsProviderListRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly providerId: number

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly isVerified?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly ordering?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly overallRating?: number

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1ReviewsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsRetrieveRequest
 */
export interface V1ApiV1ReviewsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1ReviewsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsUpdateRequest
 */
export interface V1ApiV1ReviewsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ReviewUpdate}
     * @memberof V1ApiV1ReviewsUpdate
     */
    readonly reviewUpdate: ReviewUpdate
}

/**
 * Request parameters for v1SearchOrdersList operation in V1Api.
 * @export
 * @interface V1ApiV1SearchOrdersListRequest
 */
export interface V1ApiV1SearchOrdersListRequest {
    /**
     * Filter by city
     * @type {string}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly city?: string

    /**
     * Maximum budget
     * @type {number}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly maxBudget?: number

    /**
     * Minimum budget
     * @type {number}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly minBudget?: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly pageSize?: number

    /**
     * Search query
     * @type {string}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly q?: string

    /**
     * Filter by service category ID
     * @type {number}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly serviceCategory?: number

    /**
     * Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
     * @type {'high' | 'low' | 'medium' | 'urgent'}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly urgency?: 'high' | 'low' | 'medium' | 'urgent'
}

/**
 * Request parameters for v1SearchProvidersList operation in V1Api.
 * @export
 * @interface V1ApiV1SearchProvidersListRequest
 */
export interface V1ApiV1SearchProvidersListRequest {
    /**
     * Filter by city
     * @type {string}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly city?: string

    /**
     * Minimum rating
     * @type {number}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly minRating?: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly pageSize?: number

    /**
     * Search query
     * @type {string}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly q?: string
}

/**
 * Request parameters for v1UsersList operation in V1Api.
 * @export
 * @interface V1ApiV1UsersListRequest
 */
export interface V1ApiV1UsersListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1UsersList
     */
    readonly blocked?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1UsersList
     */
    readonly isActive?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1UsersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1UsersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1UsersList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1UsersList
     */
    readonly search?: string

    /**
     * * &#x60;free&#x60; - Бесплатный * &#x60;paid&#x60; - Оплаченный * &#x60;premium_paid&#x60; - Премиум оплаченный
     * @type {'free' | 'paid' | 'premium_paid'}
     * @memberof V1ApiV1UsersList
     */
    readonly userType?: 'free' | 'paid' | 'premium_paid'
}

/**
 * Request parameters for v1UsersMyCertificatesCreate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyCertificatesCreateRequest
 */
export interface V1ApiV1UsersMyCertificatesCreateRequest {
    /**
     * 
     * @type {Certificate}
     * @memberof V1ApiV1UsersMyCertificatesCreate
     */
    readonly certificate: Certificate
}

/**
 * Request parameters for v1UsersMyCertificatesList operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyCertificatesListRequest
 */
export interface V1ApiV1UsersMyCertificatesListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1UsersMyCertificatesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1UsersMyCertificatesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1UsersMyCertificatesList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1UsersMyClientCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyClientCreateCreateRequest
 */
export interface V1ApiV1UsersMyClientCreateCreateRequest {
    /**
     * 
     * @type {ClientUpdate}
     * @memberof V1ApiV1UsersMyClientCreateCreate
     */
    readonly clientUpdate?: ClientUpdate
}

/**
 * Request parameters for v1UsersMyClientUpdatePartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyClientUpdatePartialUpdateRequest
 */
export interface V1ApiV1UsersMyClientUpdatePartialUpdateRequest {
    /**
     * 
     * @type {PatchedClientUpdate}
     * @memberof V1ApiV1UsersMyClientUpdatePartialUpdate
     */
    readonly patchedClientUpdate?: PatchedClientUpdate
}

/**
 * Request parameters for v1UsersMyClientUpdateUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyClientUpdateUpdateRequest
 */
export interface V1ApiV1UsersMyClientUpdateUpdateRequest {
    /**
     * 
     * @type {ClientUpdate}
     * @memberof V1ApiV1UsersMyClientUpdateUpdate
     */
    readonly clientUpdate?: ClientUpdate
}

/**
 * Request parameters for v1UsersMyPortfolioCreate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyPortfolioCreateRequest
 */
export interface V1ApiV1UsersMyPortfolioCreateRequest {
    /**
     * 
     * @type {PortfolioItem}
     * @memberof V1ApiV1UsersMyPortfolioCreate
     */
    readonly portfolioItem: PortfolioItem
}

/**
 * Request parameters for v1UsersMyPortfolioList operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyPortfolioListRequest
 */
export interface V1ApiV1UsersMyPortfolioListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1UsersMyPortfolioList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1UsersMyPortfolioList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1UsersMyPortfolioList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1UsersMyProfileAdvancedPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyProfileAdvancedPartialUpdateRequest
 */
export interface V1ApiV1UsersMyProfileAdvancedPartialUpdateRequest {
    /**
     * 
     * @type {PatchedAdvancedProfileUpdate}
     * @memberof V1ApiV1UsersMyProfileAdvancedPartialUpdate
     */
    readonly patchedAdvancedProfileUpdate?: PatchedAdvancedProfileUpdate
}

/**
 * Request parameters for v1UsersMyProfileAdvancedUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyProfileAdvancedUpdateRequest
 */
export interface V1ApiV1UsersMyProfileAdvancedUpdateRequest {
    /**
     * 
     * @type {AdvancedProfileUpdate}
     * @memberof V1ApiV1UsersMyProfileAdvancedUpdate
     */
    readonly advancedProfileUpdate?: AdvancedProfileUpdate
}

/**
 * Request parameters for v1UsersMyProfilePartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyProfilePartialUpdateRequest
 */
export interface V1ApiV1UsersMyProfilePartialUpdateRequest {
    /**
     * 
     * @type {PatchedUserProfileUpdate}
     * @memberof V1ApiV1UsersMyProfilePartialUpdate
     */
    readonly patchedUserProfileUpdate?: PatchedUserProfileUpdate
}

/**
 * Request parameters for v1UsersMyProfileUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyProfileUpdateRequest
 */
export interface V1ApiV1UsersMyProfileUpdateRequest {
    /**
     * 
     * @type {UserProfileUpdate}
     * @memberof V1ApiV1UsersMyProfileUpdate
     */
    readonly userProfileUpdate?: UserProfileUpdate
}

/**
 * Request parameters for v1UsersMyProviderCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyProviderCreateCreateRequest
 */
export interface V1ApiV1UsersMyProviderCreateCreateRequest {
    /**
     * 
     * @type {ServiceProviderUpdate}
     * @memberof V1ApiV1UsersMyProviderCreateCreate
     */
    readonly serviceProviderUpdate?: ServiceProviderUpdate
}

/**
 * Request parameters for v1UsersMyProviderUpdatePartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyProviderUpdatePartialUpdateRequest
 */
export interface V1ApiV1UsersMyProviderUpdatePartialUpdateRequest {
    /**
     * 
     * @type {PatchedServiceProviderUpdate}
     * @memberof V1ApiV1UsersMyProviderUpdatePartialUpdate
     */
    readonly patchedServiceProviderUpdate?: PatchedServiceProviderUpdate
}

/**
 * Request parameters for v1UsersMyProviderUpdateUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyProviderUpdateUpdateRequest
 */
export interface V1ApiV1UsersMyProviderUpdateUpdateRequest {
    /**
     * 
     * @type {ServiceProviderUpdate}
     * @memberof V1ApiV1UsersMyProviderUpdateUpdate
     */
    readonly serviceProviderUpdate?: ServiceProviderUpdate
}

/**
 * Request parameters for v1UsersMySkillsCreate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMySkillsCreateRequest
 */
export interface V1ApiV1UsersMySkillsCreateRequest {
    /**
     * 
     * @type {ServiceProviderSkill}
     * @memberof V1ApiV1UsersMySkillsCreate
     */
    readonly serviceProviderSkill: ServiceProviderSkill
}

/**
 * Request parameters for v1UsersMySkillsList operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMySkillsListRequest
 */
export interface V1ApiV1UsersMySkillsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1UsersMySkillsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1UsersMySkillsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1UsersMySkillsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1UsersMyStatisticsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyStatisticsPartialUpdateRequest
 */
export interface V1ApiV1UsersMyStatisticsPartialUpdateRequest {
    /**
     * 
     * @type {PatchedProviderStatistics}
     * @memberof V1ApiV1UsersMyStatisticsPartialUpdate
     */
    readonly patchedProviderStatistics?: PatchedProviderStatistics
}

/**
 * Request parameters for v1UsersMyStatisticsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersMyStatisticsUpdateRequest
 */
export interface V1ApiV1UsersMyStatisticsUpdateRequest {
    /**
     * 
     * @type {ProviderStatistics}
     * @memberof V1ApiV1UsersMyStatisticsUpdate
     */
    readonly providerStatistics?: ProviderStatistics
}

/**
 * Request parameters for v1UsersProfessionsList operation in V1Api.
 * @export
 * @interface V1ApiV1UsersProfessionsListRequest
 */
export interface V1ApiV1UsersProfessionsListRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1UsersProfessionsList
     */
    readonly category?: number

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1UsersProfessionsList
     */
    readonly isActive?: boolean

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1UsersProfessionsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1UsersProfessionsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1UsersProfessionsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1UsersProvidersDetailsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersProvidersDetailsPartialUpdateRequest
 */
export interface V1ApiV1UsersProvidersDetailsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1UsersProvidersDetailsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedServiceProviderUpdate}
     * @memberof V1ApiV1UsersProvidersDetailsPartialUpdate
     */
    readonly patchedServiceProviderUpdate?: PatchedServiceProviderUpdate
}

/**
 * Request parameters for v1UsersProvidersDetailsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1UsersProvidersDetailsRetrieveRequest
 */
export interface V1ApiV1UsersProvidersDetailsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1UsersProvidersDetailsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1UsersProvidersDetailsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersProvidersDetailsUpdateRequest
 */
export interface V1ApiV1UsersProvidersDetailsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1UsersProvidersDetailsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ServiceProviderUpdate}
     * @memberof V1ApiV1UsersProvidersDetailsUpdate
     */
    readonly serviceProviderUpdate?: ServiceProviderUpdate
}

/**
 * Request parameters for v1UsersSkillsList operation in V1Api.
 * @export
 * @interface V1ApiV1UsersSkillsListRequest
 */
export interface V1ApiV1UsersSkillsListRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1UsersSkillsList
     */
    readonly category?: number

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1UsersSkillsList
     */
    readonly isActive?: boolean

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1UsersSkillsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1UsersSkillsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1UsersSkillsList
     */
    readonly search?: string
}

/**
 * V1Api - object-oriented interface
 * @export
 * @class V1Api
 * @extends {BaseAPI}
 */
export class V1Api extends BaseAPI implements V1ApiInterface {
    /**
     * Authenticate user with Firebase ID token or register new user if verified.
     * @param {V1ApiV1AuthFirebaseCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AuthFirebaseCreate(requestParameters: V1ApiV1AuthFirebaseCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AuthFirebaseCreate(requestParameters.fireBaseAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User logout view - enhanced version of api_users LogOutView
     * @param {V1ApiV1AuthLogoutCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AuthLogoutCreate(requestParameters: V1ApiV1AuthLogoutCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AuthLogoutCreate(requestParameters.logoutResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mobile-optimized view for chat conversation list.
     * @param {V1ApiV1ChatConversationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatConversationsList(requestParameters: V1ApiV1ChatConversationsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatConversationsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mobile-optimized view for chat conversation details with messages.
     * @param {V1ApiV1ChatConversationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatConversationsRetrieve(requestParameters: V1ApiV1ChatConversationsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatConversationsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a message to a chat room.
     * @param {V1ApiV1ChatConversationsSendCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatConversationsSendCreate(requestParameters: V1ApiV1ChatConversationsSendCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatConversationsSendCreate(requestParameters.id, requestParameters.chatSendMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get WebSocket connection info for the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatWebsocketInfoRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatWebsocketInfoRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Languages - Read-only (managed via admin/fixtures).
     * @param {V1ApiV1CoreLanguagesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreLanguagesList(requestParameters: V1ApiV1CoreLanguagesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreLanguagesList(requestParameters.isActive, requestParameters.isDefault, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Languages - Read-only (managed via admin/fixtures).
     * @param {V1ApiV1CoreLanguagesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreLanguagesRetrieve(requestParameters: V1ApiV1CoreLanguagesRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreLanguagesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceAreasCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceAreasCreate(requestParameters: V1ApiV1CoreServiceAreasCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceAreasCreate(requestParameters.serviceAreaCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceAreasDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceAreasDestroy(requestParameters: V1ApiV1CoreServiceAreasDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceAreasDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceAreasListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceAreasList(requestParameters: V1ApiV1CoreServiceAreasListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceAreasList(requestParameters.isActive, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceAreasPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceAreasPartialUpdate(requestParameters: V1ApiV1CoreServiceAreasPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceAreasPartialUpdate(requestParameters.id, requestParameters.patchedServiceAreaCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceAreasRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceAreasRetrieve(requestParameters: V1ApiV1CoreServiceAreasRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceAreasRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Areas - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceAreasUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceAreasUpdate(requestParameters: V1ApiV1CoreServiceAreasUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceAreasUpdate(requestParameters.id, requestParameters.serviceAreaCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceCategoriesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceCategoriesCreate(requestParameters: V1ApiV1CoreServiceCategoriesCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceCategoriesCreate(requestParameters.serviceCategoryCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceCategoriesDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceCategoriesDestroy(requestParameters: V1ApiV1CoreServiceCategoriesDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceCategoriesDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceCategoriesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceCategoriesList(requestParameters: V1ApiV1CoreServiceCategoriesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceCategoriesList(requestParameters.featured, requestParameters.isActive, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceCategoriesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceCategoriesPartialUpdate(requestParameters: V1ApiV1CoreServiceCategoriesPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceCategoriesPartialUpdate(requestParameters.id, requestParameters.patchedServiceCategoryCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceCategoriesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceCategoriesRetrieve(requestParameters: V1ApiV1CoreServiceCategoriesRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceCategoriesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Categories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceCategoriesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceCategoriesUpdate(requestParameters: V1ApiV1CoreServiceCategoriesUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceCategoriesUpdate(requestParameters.id, requestParameters.serviceCategoryCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceSubcategoriesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceSubcategoriesCreate(requestParameters: V1ApiV1CoreServiceSubcategoriesCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceSubcategoriesCreate(requestParameters.serviceSubcategoryCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceSubcategoriesDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceSubcategoriesDestroy(requestParameters: V1ApiV1CoreServiceSubcategoriesDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceSubcategoriesDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceSubcategoriesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceSubcategoriesList(requestParameters: V1ApiV1CoreServiceSubcategoriesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceSubcategoriesList(requestParameters.category, requestParameters.featured, requestParameters.isActive, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceSubcategoriesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceSubcategoriesPartialUpdate(requestParameters: V1ApiV1CoreServiceSubcategoriesPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceSubcategoriesPartialUpdate(requestParameters.id, requestParameters.patchedServiceSubcategoryCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceSubcategoriesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceSubcategoriesRetrieve(requestParameters: V1ApiV1CoreServiceSubcategoriesRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceSubcategoriesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Service Subcategories - Full CRUD with authenticated access.
     * @param {V1ApiV1CoreServiceSubcategoriesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceSubcategoriesUpdate(requestParameters: V1ApiV1CoreServiceSubcategoriesUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceSubcategoriesUpdate(requestParameters.id, requestParameters.serviceSubcategoryCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {V1ApiV1CoreSupportFaqCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSupportFaqCreate(requestParameters: V1ApiV1CoreSupportFaqCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSupportFaqCreate(requestParameters.supportFAQCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {V1ApiV1CoreSupportFaqDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSupportFaqDestroy(requestParameters: V1ApiV1CoreSupportFaqDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSupportFaqDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {V1ApiV1CoreSupportFaqListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSupportFaqList(requestParameters: V1ApiV1CoreSupportFaqListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSupportFaqList(requestParameters.category, requestParameters.isActive, requestParameters.language, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {V1ApiV1CoreSupportFaqPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSupportFaqPartialUpdate(requestParameters: V1ApiV1CoreSupportFaqPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSupportFaqPartialUpdate(requestParameters.id, requestParameters.patchedSupportFAQCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {V1ApiV1CoreSupportFaqRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSupportFaqRetrieve(requestParameters: V1ApiV1CoreSupportFaqRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSupportFaqRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Support FAQ - Full CRUD with admin access.
     * @param {V1ApiV1CoreSupportFaqUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSupportFaqUpdate(requestParameters: V1ApiV1CoreSupportFaqUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSupportFaqUpdate(requestParameters.id, requestParameters.supportFAQCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * System Settings - Full CRUD with admin access.
     * @param {V1ApiV1CoreSystemSettingsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSystemSettingsCreate(requestParameters: V1ApiV1CoreSystemSettingsCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSystemSettingsCreate(requestParameters.systemSettingsCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * System Settings - Full CRUD with admin access.
     * @param {V1ApiV1CoreSystemSettingsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSystemSettingsDestroy(requestParameters: V1ApiV1CoreSystemSettingsDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSystemSettingsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * System Settings - Full CRUD with admin access.
     * @param {V1ApiV1CoreSystemSettingsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSystemSettingsList(requestParameters: V1ApiV1CoreSystemSettingsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSystemSettingsList(requestParameters.category, requestParameters.isActive, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * System Settings - Full CRUD with admin access.
     * @param {V1ApiV1CoreSystemSettingsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSystemSettingsPartialUpdate(requestParameters: V1ApiV1CoreSystemSettingsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSystemSettingsPartialUpdate(requestParameters.id, requestParameters.patchedSystemSettingsCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * System Settings - Full CRUD with admin access.
     * @param {V1ApiV1CoreSystemSettingsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSystemSettingsRetrieve(requestParameters: V1ApiV1CoreSystemSettingsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSystemSettingsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * System Settings - Full CRUD with admin access.
     * @param {V1ApiV1CoreSystemSettingsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSystemSettingsUpdate(requestParameters: V1ApiV1CoreSystemSettingsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSystemSettingsUpdate(requestParameters.id, requestParameters.systemSettingsCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get notification counts for current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsCountRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsCountRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new notifications (admin only).
     * @param {V1ApiV1NotificationsCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsCreateCreate(requestParameters: V1ApiV1NotificationsCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsCreateCreate(requestParameters.notificationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List notifications for the current user.
     * @param {V1ApiV1NotificationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsList(requestParameters: V1ApiV1NotificationsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark all notifications as read for current user.
     * @param {V1ApiV1NotificationsMarkAllReadCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsMarkAllReadCreate(requestParameters: V1ApiV1NotificationsMarkAllReadCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsMarkAllReadCreate(requestParameters.notification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve and update individual notifications.
     * @param {V1ApiV1NotificationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsPartialUpdate(requestParameters: V1ApiV1NotificationsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsPartialUpdate(requestParameters.id, requestParameters.patchedNotificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent notifications (last 7 days).
     * @param {V1ApiV1NotificationsRecentListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsRecentList(requestParameters: V1ApiV1NotificationsRecentListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsRecentList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve and update individual notifications.
     * @param {V1ApiV1NotificationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsRetrieve(requestParameters: V1ApiV1NotificationsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get unread notifications for current user.
     * @param {V1ApiV1NotificationsUnreadListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsUnreadList(requestParameters: V1ApiV1NotificationsUnreadListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsUnreadList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve and update individual notifications.
     * @param {V1ApiV1NotificationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsUpdate(requestParameters: V1ApiV1NotificationsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsUpdate(requestParameters.id, requestParameters.notificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all order assignments (admin view).
     * @param {V1ApiV1OrdersAssignmentsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersAssignmentsList(requestParameters: V1ApiV1OrdersAssignmentsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersAssignmentsList(requestParameters.order, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View and update order assignment details.
     * @param {V1ApiV1OrdersAssignmentsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersAssignmentsPartialUpdate(requestParameters: V1ApiV1OrdersAssignmentsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersAssignmentsPartialUpdate(requestParameters.id, requestParameters.patchedOrderAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View and update order assignment details.
     * @param {V1ApiV1OrdersAssignmentsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersAssignmentsRetrieve(requestParameters: V1ApiV1OrdersAssignmentsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersAssignmentsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View and update order assignment details.
     * @param {V1ApiV1OrdersAssignmentsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersAssignmentsUpdate(requestParameters: V1ApiV1OrdersAssignmentsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersAssignmentsUpdate(requestParameters.id, requestParameters.orderAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accept a bid and create order assignment.
     * @param {V1ApiV1OrdersBidsAcceptCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsAcceptCreate(requestParameters: V1ApiV1OrdersBidsAcceptCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsAcceptCreate(requestParameters.bidId, requestParameters.bidAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersBidsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsCreate(requestParameters: V1ApiV1OrdersBidsCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsCreate(requestParameters.orderId, requestParameters.bidCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersBidsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsDestroy(requestParameters: V1ApiV1OrdersBidsDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all bids (admin view).
     * @param {V1ApiV1OrdersBidsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsList(requestParameters: V1ApiV1OrdersBidsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsList(requestParameters.isNegotiable, requestParameters.order, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersBidsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsPartialUpdate(requestParameters: V1ApiV1OrdersBidsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsPartialUpdate(requestParameters.id, requestParameters.patchedBidCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reject a bid.
     * @param {V1ApiV1OrdersBidsRejectCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsRejectCreate(requestParameters: V1ApiV1OrdersBidsRejectCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsRejectCreate(requestParameters.bidId, requestParameters.bidAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersBidsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsRetrieve(requestParameters: V1ApiV1OrdersBidsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersBidsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsUpdate(requestParameters: V1ApiV1OrdersBidsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsUpdate(requestParameters.id, requestParameters.bidCreateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Withdraw a bid (by provider).
     * @param {V1ApiV1OrdersBidsWithdrawCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsWithdrawCreate(requestParameters: V1ApiV1OrdersBidsWithdrawCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsWithdrawCreate(requestParameters.bidId, requestParameters.bidAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersCreateCreate(requestParameters: V1ApiV1OrdersCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersCreateCreate(requestParameters.orderCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all orders (admin view).
     * @param {V1ApiV1OrdersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersList(requestParameters: V1ApiV1OrdersListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.serviceSubcategory, requestParameters.status, requestParameters.urgency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user\'s assignments (as service provider).
     * @param {V1ApiV1OrdersMyAssignmentsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersMyAssignmentsList(requestParameters: V1ApiV1OrdersMyAssignmentsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersMyAssignmentsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user\'s bids (as service provider).
     * @param {V1ApiV1OrdersMyBidsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersMyBidsList(requestParameters: V1ApiV1OrdersMyBidsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersMyBidsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user\'s orders (as client).
     * @param {V1ApiV1OrdersMyListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersMyList(requestParameters: V1ApiV1OrdersMyListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersMyList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get assignments for current user\'s orders (as client).
     * @param {V1ApiV1OrdersMyOrdersAssignmentsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersMyOrdersAssignmentsList(requestParameters: V1ApiV1OrdersMyOrdersAssignmentsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersMyOrdersAssignmentsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get bids for current user\'s orders (as client).
     * @param {V1ApiV1OrdersMyOrdersBidsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersMyOrdersBidsList(requestParameters: V1ApiV1OrdersMyOrdersBidsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersMyOrdersBidsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersPartialUpdate(requestParameters: V1ApiV1OrdersPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersPartialUpdate(requestParameters.id, requestParameters.patchedOrderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersRetrieve(requestParameters: V1ApiV1OrdersRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersUpdate(requestParameters: V1ApiV1OrdersUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersUpdate(requestParameters.id, requestParameters.orderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsCreateCreate(requestParameters: V1ApiV1PaymentsCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsCreateCreate(requestParameters.paymentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsInvoicesCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsInvoicesCreateCreate(requestParameters: V1ApiV1PaymentsInvoicesCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsInvoicesCreateCreate(requestParameters.invoiceCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsInvoicesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsInvoicesList(requestParameters: V1ApiV1PaymentsInvoicesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsInvoicesList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsInvoicesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsInvoicesRetrieve(requestParameters: V1ApiV1PaymentsInvoicesRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsInvoicesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsList(requestParameters: V1ApiV1PaymentsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsMethodsCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsCreateCreate(requestParameters: V1ApiV1PaymentsMethodsCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsCreateCreate(requestParameters.paymentMethodCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsMethodsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsDestroy(requestParameters: V1ApiV1PaymentsMethodsDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsMethodsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsList(requestParameters: V1ApiV1PaymentsMethodsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsMethodsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsPartialUpdate(requestParameters: V1ApiV1PaymentsMethodsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsPartialUpdate(requestParameters.id, requestParameters.patchedPaymentMethodUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsMethodsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsRetrieve(requestParameters: V1ApiV1PaymentsMethodsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsMethodsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsUpdate(requestParameters: V1ApiV1PaymentsMethodsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsUpdate(requestParameters.id, requestParameters.paymentMethodUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsPartialUpdate(requestParameters: V1ApiV1PaymentsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsPartialUpdate(requestParameters.id, requestParameters.patchedPaymentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsRetrieve(requestParameters: V1ApiV1PaymentsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1PaymentsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsUpdate(requestParameters: V1ApiV1PaymentsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsUpdate(requestParameters.id, requestParameters.paymentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List webhook events.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsWebhooksEventsRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsWebhooksEventsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retry processing a webhook event.
     * @param {V1ApiV1PaymentsWebhooksEventsRetryCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsWebhooksEventsRetryCreate(requestParameters: V1ApiV1PaymentsWebhooksEventsRetryCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsWebhooksEventsRetryCreate(requestParameters.eventId, requestParameters.webhookRetryResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API view for Stripe webhook handling.
     * @param {V1ApiV1PaymentsWebhooksStripeDrfCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsWebhooksStripeDrfCreate(requestParameters: V1ApiV1PaymentsWebhooksStripeDrfCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsWebhooksStripeDrfCreate(requestParameters.webhookResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload profile image
     * @param {V1ApiV1ProfileCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ProfileCreate(requestParameters: V1ApiV1ProfileCreateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ProfileCreate(requestParameters.userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User profile view with image upload
     * @param {V1ApiV1ProfilePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ProfilePartialUpdate(requestParameters: V1ApiV1ProfilePartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ProfilePartialUpdate(requestParameters.patchedUserUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User profile view with image upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ProfileRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ProfileRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User profile view with image upload
     * @param {V1ApiV1ProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ProfileUpdate(requestParameters: V1ApiV1ProfileUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ProfileUpdate(requestParameters.userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get review analytics.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsAnalyticsRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsAnalyticsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List and create reviews.
     * @param {V1ApiV1ReviewsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsCreate(requestParameters: V1ApiV1ReviewsCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsCreate(requestParameters.reviewCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete specific review.
     * @param {V1ApiV1ReviewsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsDestroy(requestParameters: V1ApiV1ReviewsDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List and create reviews.
     * @param {V1ApiV1ReviewsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsList(requestParameters: V1ApiV1ReviewsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsList(requestParameters.isVerified, requestParameters.ordering, requestParameters.overallRating, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get reviews for a specific order.
     * @param {V1ApiV1ReviewsOrderListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsOrderList(requestParameters: V1ApiV1ReviewsOrderListRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsOrderList(requestParameters.orderId, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete specific review.
     * @param {V1ApiV1ReviewsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsPartialUpdate(requestParameters: V1ApiV1ReviewsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsPartialUpdate(requestParameters.id, requestParameters.patchedReviewUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get reviews for a specific service provider.
     * @param {V1ApiV1ReviewsProviderListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsProviderList(requestParameters: V1ApiV1ReviewsProviderListRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsProviderList(requestParameters.providerId, requestParameters.isVerified, requestParameters.ordering, requestParameters.overallRating, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete specific review.
     * @param {V1ApiV1ReviewsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsRetrieve(requestParameters: V1ApiV1ReviewsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete specific review.
     * @param {V1ApiV1ReviewsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsUpdate(requestParameters: V1ApiV1ReviewsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsUpdate(requestParameters.id, requestParameters.reviewUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple global search across all content types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1SearchGlobalRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1SearchGlobalRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search specifically for orders (job vacancies).
     * @param {V1ApiV1SearchOrdersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1SearchOrdersList(requestParameters: V1ApiV1SearchOrdersListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1SearchOrdersList(requestParameters.city, requestParameters.maxBudget, requestParameters.minBudget, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.q, requestParameters.serviceCategory, requestParameters.urgency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search specifically for service providers.
     * @param {V1ApiV1SearchProvidersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1SearchProvidersList(requestParameters: V1ApiV1SearchProvidersListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1SearchProvidersList(requestParameters.city, requestParameters.minRating, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all users - not in api_users, useful for admin
     * @param {V1ApiV1UsersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersList(requestParameters: V1ApiV1UsersListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersList(requestParameters.blocked, requestParameters.isActive, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.userType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage my service provider certificates.
     * @param {V1ApiV1UsersMyCertificatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyCertificatesCreate(requestParameters: V1ApiV1UsersMyCertificatesCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyCertificatesCreate(requestParameters.certificate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage my service provider certificates.
     * @param {V1ApiV1UsersMyCertificatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyCertificatesList(requestParameters: V1ApiV1UsersMyCertificatesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyCertificatesList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersMyClientCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyClientCreateCreate(requestParameters: V1ApiV1UsersMyClientCreateCreateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyClientCreateCreate(requestParameters.clientUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersMyClientUpdatePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyClientUpdatePartialUpdate(requestParameters: V1ApiV1UsersMyClientUpdatePartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyClientUpdatePartialUpdate(requestParameters.patchedClientUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersMyClientUpdateUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyClientUpdateUpdate(requestParameters: V1ApiV1UsersMyClientUpdateUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyClientUpdateUpdate(requestParameters.clientUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage my service provider portfolio items.
     * @param {V1ApiV1UsersMyPortfolioCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyPortfolioCreate(requestParameters: V1ApiV1UsersMyPortfolioCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyPortfolioCreate(requestParameters.portfolioItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage my service provider portfolio items.
     * @param {V1ApiV1UsersMyPortfolioListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyPortfolioList(requestParameters: V1ApiV1UsersMyPortfolioListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyPortfolioList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersMyProfileAdvancedPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyProfileAdvancedPartialUpdate(requestParameters: V1ApiV1UsersMyProfileAdvancedPartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyProfileAdvancedPartialUpdate(requestParameters.patchedAdvancedProfileUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyProfileAdvancedRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyProfileAdvancedRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersMyProfileAdvancedUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyProfileAdvancedUpdate(requestParameters: V1ApiV1UsersMyProfileAdvancedUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyProfileAdvancedUpdate(requestParameters.advancedProfileUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersMyProfilePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyProfilePartialUpdate(requestParameters: V1ApiV1UsersMyProfilePartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyProfilePartialUpdate(requestParameters.patchedUserProfileUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyProfileRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyProfileRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersMyProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyProfileUpdate(requestParameters: V1ApiV1UsersMyProfileUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyProfileUpdate(requestParameters.userProfileUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersMyProviderCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyProviderCreateCreate(requestParameters: V1ApiV1UsersMyProviderCreateCreateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyProviderCreateCreate(requestParameters.serviceProviderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersMyProviderUpdatePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyProviderUpdatePartialUpdate(requestParameters: V1ApiV1UsersMyProviderUpdatePartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyProviderUpdatePartialUpdate(requestParameters.patchedServiceProviderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersMyProviderUpdateUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyProviderUpdateUpdate(requestParameters: V1ApiV1UsersMyProviderUpdateUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyProviderUpdateUpdate(requestParameters.serviceProviderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage my service provider skills.
     * @param {V1ApiV1UsersMySkillsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMySkillsCreate(requestParameters: V1ApiV1UsersMySkillsCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMySkillsCreate(requestParameters.serviceProviderSkill, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage my service provider skills.
     * @param {V1ApiV1UsersMySkillsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMySkillsList(requestParameters: V1ApiV1UsersMySkillsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMySkillsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage my provider statistics.
     * @param {V1ApiV1UsersMyStatisticsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyStatisticsPartialUpdate(requestParameters: V1ApiV1UsersMyStatisticsPartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyStatisticsPartialUpdate(requestParameters.patchedProviderStatistics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage my provider statistics.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyStatisticsRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyStatisticsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manage my provider statistics.
     * @param {V1ApiV1UsersMyStatisticsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersMyStatisticsUpdate(requestParameters: V1ApiV1UsersMyStatisticsUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersMyStatisticsUpdate(requestParameters.providerStatistics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available professions.
     * @param {V1ApiV1UsersProfessionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProfessionsList(requestParameters: V1ApiV1UsersProfessionsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProfessionsList(requestParameters.category, requestParameters.isActive, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersProvidersDetailsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProvidersDetailsPartialUpdate(requestParameters: V1ApiV1UsersProvidersDetailsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProvidersDetailsPartialUpdate(requestParameters.id, requestParameters.patchedServiceProviderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersProvidersDetailsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProvidersDetailsRetrieve(requestParameters: V1ApiV1UsersProvidersDetailsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProvidersDetailsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1UsersProvidersDetailsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProvidersDetailsUpdate(requestParameters: V1ApiV1UsersProvidersDetailsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProvidersDetailsUpdate(requestParameters.id, requestParameters.serviceProviderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available skills for service providers.
     * @param {V1ApiV1UsersSkillsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersSkillsList(requestParameters: V1ApiV1UsersSkillsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersSkillsList(requestParameters.category, requestParameters.isActive, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }
}


