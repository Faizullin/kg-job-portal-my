/* tslint:disable */
/* eslint-disable */
/**
 * Master KG Job Portal API
 * Master KG Job Portal API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { type AxiosPromise, type AxiosInstance, type AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS,  type RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * * `login` - Login * `logout` - Logout * `order_created` - Order Created * `order_viewed` - Order Viewed * `bid_submitted` - Bid Submitted * `chat_message` - Chat Message * `payment_made` - Payment Made * `profile_updated` - Profile Updated * `search_performed` - Search Performed * `service_viewed` - Service Viewed
 * @export
 * @enum {string}
 */

export const ActivityTypeEnum = {
    Login: 'login',
    Logout: 'logout',
    OrderCreated: 'order_created',
    OrderViewed: 'order_viewed',
    BidSubmitted: 'bid_submitted',
    ChatMessage: 'chat_message',
    PaymentMade: 'payment_made',
    ProfileUpdated: 'profile_updated',
    SearchPerformed: 'search_performed',
    ServiceViewed: 'service_viewed'
} as const;

export type ActivityTypeEnum = typeof ActivityTypeEnum[keyof typeof ActivityTypeEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface AppVersion
 */
export interface AppVersion {
    /**
     * 
     * @type {number}
     * @memberof AppVersion
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AppVersion
     */
    'version': string;
    /**
     * 
     * @type {number}
     * @memberof AppVersion
     */
    'build_number': number;
    /**
     * 
     * @type {PlatformEnum}
     * @memberof AppVersion
     */
    'platform'?: PlatformEnum;
    /**
     * 
     * @type {boolean}
     * @memberof AppVersion
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppVersion
     */
    'is_forced_update'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AppVersion
     */
    'release_date': string;
    /**
     * 
     * @type {string}
     * @memberof AppVersion
     */
    'download_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppVersion
     */
    'platform_display': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Bid
 */
export interface Bid {
    /**
     * 
     * @type {number}
     * @memberof Bid
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Bid
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof Bid
     */
    'provider': number;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'provider_name': string;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof Bid
     */
    'estimated_duration'?: number | null;
    /**
     * 
     * @type {BidStatusEnum}
     * @memberof Bid
     */
    'status'?: BidStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Bid
     */
    'is_negotiable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'terms_conditions'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bid
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface BidCreate
 */
export interface BidCreate {
    /**
     * 
     * @type {string}
     * @memberof BidCreate
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof BidCreate
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof BidCreate
     */
    'estimated_duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BidCreate
     */
    'terms_conditions'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BidCreate
     */
    'is_negotiable'?: boolean;
}
/**
 * * `pending` - Pending * `accepted` - Accepted * `rejected` - Rejected * `withdrawn` - Withdrawn
 * @export
 * @enum {string}
 */

export const BidStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Rejected: 'rejected',
    Withdrawn: 'withdrawn'
} as const;

export type BidStatusEnum = typeof BidStatusEnum[keyof typeof BidStatusEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const BlankEnum = {
    Empty: ''
} as const;

export type BlankEnum = typeof BlankEnum[keyof typeof BlankEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface BusinessMetrics
 */
export interface BusinessMetrics {
    /**
     * 
     * @type {number}
     * @memberof BusinessMetrics
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetrics
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetrics
     */
    'gross_merchandise_volume'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetrics
     */
    'net_revenue'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetrics
     */
    'profit_margin'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetrics
     */
    'order_fulfillment_rate'?: string;
    /**
     * 
     * @type {number}
     * @memberof BusinessMetrics
     */
    'average_order_processing_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetrics
     */
    'customer_satisfaction_score'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetrics
     */
    'month_over_month_growth'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetrics
     */
    'year_over_year_growth'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetrics
     */
    'market_share'?: string;
    /**
     * 
     * @type {BusinessMetricsCompetitivePosition}
     * @memberof BusinessMetrics
     */
    'competitive_position'?: BusinessMetricsCompetitivePosition;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetrics
     */
    'created_at': string;
}
/**
 * @type BusinessMetricsCompetitivePosition
 * @export
 */
export type BusinessMetricsCompetitivePosition = BlankEnum | CompetitivePositionEnum;

/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface BusinessMetricsCreate
 */
export interface BusinessMetricsCreate {
    /**
     * 
     * @type {string}
     * @memberof BusinessMetricsCreate
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetricsCreate
     */
    'gross_merchandise_volume'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetricsCreate
     */
    'net_revenue'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetricsCreate
     */
    'profit_margin'?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetricsCreate
     */
    'order_fulfillment_rate'?: string;
    /**
     * 
     * @type {number}
     * @memberof BusinessMetricsCreate
     */
    'average_order_processing_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof BusinessMetricsCreate
     */
    'customer_satisfaction_score'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ChatAttachment
 */
export interface ChatAttachment {
    /**
     * 
     * @type {number}
     * @memberof ChatAttachment
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ChatAttachment
     */
    'message': number;
    /**
     * 
     * @type {string}
     * @memberof ChatAttachment
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof ChatAttachment
     */
    'file_type': string;
    /**
     * 
     * @type {number}
     * @memberof ChatAttachment
     */
    'file_size': number;
    /**
     * 
     * @type {string}
     * @memberof ChatAttachment
     */
    'file_size_display': string;
    /**
     * 
     * @type {string}
     * @memberof ChatAttachment
     */
    'file_url': string;
    /**
     * 
     * @type {string}
     * @memberof ChatAttachment
     */
    'thumbnail_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatAttachment
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ChatAttachmentCreate
 */
export interface ChatAttachmentCreate {
    /**
     * 
     * @type {number}
     * @memberof ChatAttachmentCreate
     */
    'message': number;
    /**
     * 
     * @type {string}
     * @memberof ChatAttachmentCreate
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof ChatAttachmentCreate
     */
    'file_type': string;
    /**
     * 
     * @type {number}
     * @memberof ChatAttachmentCreate
     */
    'file_size': number;
    /**
     * 
     * @type {string}
     * @memberof ChatAttachmentCreate
     */
    'file_url': string;
    /**
     * 
     * @type {string}
     * @memberof ChatAttachmentCreate
     */
    'thumbnail_url'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ChatParticipant
 */
export interface ChatParticipant {
    /**
     * 
     * @type {number}
     * @memberof ChatParticipant
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ChatParticipant
     */
    'chat_room': number;
    /**
     * 
     * @type {string}
     * @memberof ChatParticipant
     */
    'chat_room_title': string;
    /**
     * 
     * @type {number}
     * @memberof ChatParticipant
     */
    'user': number;
    /**
     * 
     * @type {string}
     * @memberof ChatParticipant
     */
    'user_name': string;
    /**
     * 
     * @type {RoleEnum}
     * @memberof ChatParticipant
     */
    'role'?: RoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ChatParticipant
     */
    'is_online'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChatParticipant
     */
    'last_seen'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatParticipant
     */
    'unread_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ChatParticipant
     */
    'notifications_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChatParticipant
     */
    'mute_until'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatParticipant
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChatParticipant
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ChatParticipantCreate
 */
export interface ChatParticipantCreate {
    /**
     * 
     * @type {number}
     * @memberof ChatParticipantCreate
     */
    'chat_room': number;
    /**
     * 
     * @type {number}
     * @memberof ChatParticipantCreate
     */
    'user': number;
    /**
     * 
     * @type {RoleEnum}
     * @memberof ChatParticipantCreate
     */
    'role'?: RoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ChatParticipantCreate
     */
    'is_online'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChatParticipantCreate
     */
    'notifications_enabled'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ChatRoom
 */
export interface ChatRoom {
    /**
     * 
     * @type {number}
     * @memberof ChatRoom
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'title'?: string;
    /**
     * 
     * @type {ChatTypeEnum}
     * @memberof ChatRoom
     */
    'chat_type'?: ChatTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'chat_type_display': string;
    /**
     * 
     * @type {number}
     * @memberof ChatRoom
     */
    'order'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'order_title': string;
    /**
     * 
     * @type {Array<ChatParticipant>}
     * @memberof ChatRoom
     */
    'participants': Array<ChatParticipant>;
    /**
     * 
     * @type {boolean}
     * @memberof ChatRoom
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'last_message_at'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ChatRoom
     */
    'last_message': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof ChatRoom
     */
    'unread_count': number;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ChatRoomCreate
 */
export interface ChatRoomCreate {
    /**
     * 
     * @type {string}
     * @memberof ChatRoomCreate
     */
    'title'?: string;
    /**
     * 
     * @type {ChatTypeEnum}
     * @memberof ChatRoomCreate
     */
    'chat_type'?: ChatTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ChatRoomCreate
     */
    'order'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatRoomCreate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChatRoomCreate
     */
    'participants'?: Array<number>;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ChatRoomUpdate
 */
export interface ChatRoomUpdate {
    /**
     * 
     * @type {string}
     * @memberof ChatRoomUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {ChatTypeEnum}
     * @memberof ChatRoomUpdate
     */
    'chat_type'?: ChatTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ChatRoomUpdate
     */
    'is_active'?: boolean;
}
/**
 * * `order_chat` - Order Chat * `support_chat` - Support Chat * `general_chat` - General Chat
 * @export
 * @enum {string}
 */

export const ChatTypeEnum = {
    OrderChat: 'order_chat',
    SupportChat: 'support_chat',
    GeneralChat: 'general_chat'
} as const;

export type ChatTypeEnum = typeof ChatTypeEnum[keyof typeof ChatTypeEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    'user_profile': number;
    /**
     * 
     * @type {any}
     * @memberof Client
     */
    'preferred_service_areas'?: any;
    /**
     * 
     * @type {any}
     * @memberof Client
     */
    'budget_preferences'?: any;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    'total_orders': number;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    'completed_orders': number;
    /**
     * 
     * @type {number}
     * @memberof Client
     */
    'cancelled_orders': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Client
     */
    'favorite_providers'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ClientUpdate
 */
export interface ClientUpdate {
    /**
     * 
     * @type {any}
     * @memberof ClientUpdate
     */
    'preferred_service_areas'?: any;
    /**
     * 
     * @type {any}
     * @memberof ClientUpdate
     */
    'budget_preferences'?: any;
}
/**
 * * `leader` - Market Leader * `challenger` - Market Challenger * `follower` - Market Follower * `niche` - Niche Player
 * @export
 * @enum {string}
 */

export const CompetitivePositionEnum = {
    Leader: 'leader',
    Challenger: 'challenger',
    Follower: 'follower',
    Niche: 'niche'
} as const;

export type CompetitivePositionEnum = typeof CompetitivePositionEnum[keyof typeof CompetitivePositionEnum];


/**
 * * `beginner` - Beginner * `intermediate` - Intermediate * `advanced` - Advanced * `expert` - Expert
 * @export
 * @enum {string}
 */

export const ComplexityLevelEnum = {
    Beginner: 'beginner',
    Intermediate: 'intermediate',
    Advanced: 'advanced',
    Expert: 'expert'
} as const;

export type ComplexityLevelEnum = typeof ComplexityLevelEnum[keyof typeof ComplexityLevelEnum];


/**
 * Serializer for dashboard API response.
 * @export
 * @interface DashboardResponse
 */
export interface DashboardResponse {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DashboardResponse
     */
    'current_month': { [key: string]: any; };
}
/**
 * * `immediate` - Immediate * `hourly` - Hourly * `daily` - Daily * `weekly` - Weekly
 * @export
 * @enum {string}
 */

export const DigestFrequencyEnum = {
    Immediate: 'immediate',
    Hourly: 'hourly',
    Daily: 'daily',
    Weekly: 'weekly'
} as const;

export type DigestFrequencyEnum = typeof DigestFrequencyEnum[keyof typeof DigestFrequencyEnum];


/**
 * * `quality_issue` - Quality Issue * `payment_dispute` - Payment Dispute * `schedule_conflict` - Schedule Conflict * `communication_issue` - Communication Issue * `other` - Other
 * @export
 * @enum {string}
 */

export const DisputeTypeEnum = {
    QualityIssue: 'quality_issue',
    PaymentDispute: 'payment_dispute',
    ScheduleConflict: 'schedule_conflict',
    CommunicationIssue: 'communication_issue',
    Other: 'other'
} as const;

export type DisputeTypeEnum = typeof DisputeTypeEnum[keyof typeof DisputeTypeEnum];


/**
 * Serializer for Firebase authentication request
 * @export
 * @interface FireBaseAuth
 */
export interface FireBaseAuth {
    /**
     * Firebase ID token
     * @type {string}
     * @memberof FireBaseAuth
     */
    'id_token': string;
}
/**
 * * `male` - Male * `female` - Female * `other` - Other * `prefer_not_to_say` - Prefer not to say
 * @export
 * @enum {string}
 */

export const GenderEnum = {
    Male: 'male',
    Female: 'female',
    Other: 'other',
    PreferNotToSay: 'prefer_not_to_say'
} as const;

export type GenderEnum = typeof GenderEnum[keyof typeof GenderEnum];


/**
 * Serializer for global search response.
 * @export
 * @interface GlobalSearchResponse
 */
export interface GlobalSearchResponse {
    /**
     * Search query
     * @type {string}
     * @memberof GlobalSearchResponse
     */
    'query': string;
    /**
     * Type of search performed
     * @type {string}
     * @memberof GlobalSearchResponse
     */
    'search_type': string;
    /**
     * Search results by category
     * @type {{ [key: string]: any; }}
     * @memberof GlobalSearchResponse
     */
    'results': { [key: string]: any; };
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'invoice_number': string;
    /**
     * 
     * @type {InvoiceStatusEnum}
     * @memberof Invoice
     */
    'status'?: InvoiceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'subtotal': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'platform_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'total_amount': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'due_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'paid_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface InvoiceCreate
 */
export interface InvoiceCreate {
    /**
     * 
     * @type {number}
     * @memberof InvoiceCreate
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCreate
     */
    'subtotal': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCreate
     */
    'platform_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceCreate
     */
    'due_date'?: string | null;
}
/**
 * * `draft` - Draft * `sent` - Sent * `paid` - Paid * `overdue` - Overdue * `cancelled` - Cancelled
 * @export
 * @enum {string}
 */

export const InvoiceStatusEnum = {
    Draft: 'draft',
    Sent: 'sent',
    Paid: 'paid',
    Overdue: 'overdue',
    Cancelled: 'cancelled'
} as const;

export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {number}
     * @memberof Language
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'native_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'flag_icon'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    'rtl_support'?: boolean;
}
/**
 * Serializer for logout response
 * @export
 * @interface LogoutResponse
 */
export interface LogoutResponse {
    /**
     * Logout confirmation message
     * @type {string}
     * @memberof LogoutResponse
     */
    'message': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'chat_room': number;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'sender': number;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'sender_name': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'content': string;
    /**
     * 
     * @type {MessageTypeEnum}
     * @memberof Message
     */
    'message_type'?: MessageTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'message_type_display': string;
    /**
     * 
     * @type {Array<ChatAttachment>}
     * @memberof Message
     */
    'attachments': Array<ChatAttachment>;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'is_read'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'read_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface MessageCreate
 */
export interface MessageCreate {
    /**
     * 
     * @type {number}
     * @memberof MessageCreate
     */
    'chat_room': number;
    /**
     * 
     * @type {string}
     * @memberof MessageCreate
     */
    'content': string;
    /**
     * 
     * @type {MessageTypeEnum}
     * @memberof MessageCreate
     */
    'message_type'?: MessageTypeEnum;
}
/**
 * * `text` - Текст * `image` - Изображение * `file` - Файл * `system` - System Message * `order_update` - Order Update
 * @export
 * @enum {string}
 */

export const MessageTypeEnum = {
    Text: 'text',
    Image: 'image',
    File: 'file',
    System: 'system',
    OrderUpdate: 'order_update'
} as const;

export type MessageTypeEnum = typeof MessageTypeEnum[keyof typeof MessageTypeEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface MessageUpdate
 */
export interface MessageUpdate {
    /**
     * 
     * @type {string}
     * @memberof MessageUpdate
     */
    'content': string;
    /**
     * 
     * @type {MessageTypeEnum}
     * @memberof MessageUpdate
     */
    'message_type'?: MessageTypeEnum;
}
/**
 * * `credit_card` - Credit Card * `debit_card` - Debit Card * `bank_transfer` - Bank Transfer * `digital_wallet` - Digital Wallet
 * @export
 * @enum {string}
 */

export const MethodTypeEnum = {
    CreditCard: 'credit_card',
    DebitCard: 'debit_card',
    BankTransfer: 'bank_transfer',
    DigitalWallet: 'digital_wallet'
} as const;

export type MethodTypeEnum = typeof MethodTypeEnum[keyof typeof MethodTypeEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'template': number;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'short_message'?: string;
    /**
     * 
     * @type {any}
     * @memberof Notification
     */
    'context_data'?: any;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'related_object_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'related_object_id'?: number | null;
    /**
     * 
     * @type {NotificationStatusEnum}
     * @memberof Notification
     */
    'status'?: NotificationStatusEnum;
    /**
     * 
     * @type {PriorityEnum}
     * @memberof Notification
     */
    'priority'?: PriorityEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'is_read'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'read_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'sent_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'delivered_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface NotificationCreate
 */
export interface NotificationCreate {
    /**
     * 
     * @type {number}
     * @memberof NotificationCreate
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationCreate
     */
    'template': number;
    /**
     * 
     * @type {string}
     * @memberof NotificationCreate
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCreate
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCreate
     */
    'short_message'?: string;
    /**
     * 
     * @type {any}
     * @memberof NotificationCreate
     */
    'context_data'?: any;
    /**
     * 
     * @type {string}
     * @memberof NotificationCreate
     */
    'related_object_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof NotificationCreate
     */
    'related_object_id'?: number | null;
    /**
     * 
     * @type {PriorityEnum}
     * @memberof NotificationCreate
     */
    'priority'?: PriorityEnum;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface NotificationSetting
 */
export interface NotificationSetting {
    /**
     * 
     * @type {number}
     * @memberof NotificationSetting
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationSetting
     */
    'user': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'email_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'push_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'sms_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'in_app_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'order_updates'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'bid_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'payment_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'chat_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'promotional_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSetting
     */
    'system_notifications'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationSetting
     */
    'quiet_hours_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationSetting
     */
    'quiet_hours_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationSetting
     */
    'timezone'?: string;
    /**
     * 
     * @type {DigestFrequencyEnum}
     * @memberof NotificationSetting
     */
    'digest_frequency'?: DigestFrequencyEnum;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface NotificationSettingUpdate
 */
export interface NotificationSettingUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingUpdate
     */
    'email_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingUpdate
     */
    'push_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingUpdate
     */
    'sms_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingUpdate
     */
    'in_app_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingUpdate
     */
    'order_updates'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingUpdate
     */
    'bid_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingUpdate
     */
    'payment_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingUpdate
     */
    'chat_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingUpdate
     */
    'promotional_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSettingUpdate
     */
    'system_notifications'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationSettingUpdate
     */
    'quiet_hours_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationSettingUpdate
     */
    'quiet_hours_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationSettingUpdate
     */
    'timezone'?: string;
    /**
     * 
     * @type {DigestFrequencyEnum}
     * @memberof NotificationSettingUpdate
     */
    'digest_frequency'?: DigestFrequencyEnum;
}
/**
 * * `pending` - Pending * `sent` - Sent * `delivered` - Delivered * `failed` - Failed * `cancelled` - Cancelled
 * @export
 * @enum {string}
 */

export const NotificationStatusEnum = {
    Pending: 'pending',
    Sent: 'sent',
    Delivered: 'delivered',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;

export type NotificationStatusEnum = typeof NotificationStatusEnum[keyof typeof NotificationStatusEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface NotificationTemplate
 */
export interface NotificationTemplate {
    /**
     * 
     * @type {number}
     * @memberof NotificationTemplate
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplate
     */
    'name': string;
    /**
     * 
     * @type {NotificationTypeEnum}
     * @memberof NotificationTemplate
     */
    'notification_type': NotificationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplate
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplate
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplate
     */
    'short_message'?: string;
    /**
     * 
     * @type {any}
     * @memberof NotificationTemplate
     */
    'variables'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationTemplate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplate
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface NotificationTemplateCreate
 */
export interface NotificationTemplateCreate {
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplateCreate
     */
    'name': string;
    /**
     * 
     * @type {NotificationTypeEnum}
     * @memberof NotificationTemplateCreate
     */
    'notification_type': NotificationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplateCreate
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplateCreate
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplateCreate
     */
    'short_message'?: string;
    /**
     * 
     * @type {any}
     * @memberof NotificationTemplateCreate
     */
    'variables'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationTemplateCreate
     */
    'is_active'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface NotificationTemplateUpdate
 */
export interface NotificationTemplateUpdate {
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplateUpdate
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplateUpdate
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplateUpdate
     */
    'short_message'?: string;
    /**
     * 
     * @type {any}
     * @memberof NotificationTemplateUpdate
     */
    'variables'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationTemplateUpdate
     */
    'is_active'?: boolean;
}
/**
 * * `order_update` - Order Update * `bid_received` - Bid Received * `payment_success` - Payment Success * `payment_failed` - Payment Failed * `chat_message` - Chat Message * `system_alert` - System Alert * `promotional` - Promotional
 * @export
 * @enum {string}
 */

export const NotificationTypeEnum = {
    OrderUpdate: 'order_update',
    BidReceived: 'bid_received',
    PaymentSuccess: 'payment_success',
    PaymentFailed: 'payment_failed',
    ChatMessage: 'chat_message',
    SystemAlert: 'system_alert',
    Promotional: 'promotional'
} as const;

export type NotificationTypeEnum = typeof NotificationTypeEnum[keyof typeof NotificationTypeEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface NotificationUpdate
 */
export interface NotificationUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof NotificationUpdate
     */
    'is_read'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationUpdate
     */
    'read_at'?: string | null;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'client': number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'client_name': string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'service_subcategory': number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'description': string;
    /**
     * 
     * @type {OrderStatusEnum}
     * @memberof Order
     */
    'status'?: OrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'postal_code': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'service_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'service_time'?: string | null;
    /**
     * 
     * @type {UrgencyEnum}
     * @memberof Order
     */
    'urgency'?: UrgencyEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'budget_min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'budget_max'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'final_price'?: string | null;
    /**
     * 
     * @type {Array<OrderAddon>}
     * @memberof Order
     */
    'addons': Array<OrderAddon>;
    /**
     * 
     * @type {Array<OrderPhoto>}
     * @memberof Order
     */
    'photos': Array<OrderPhoto>;
    /**
     * 
     * @type {Array<Bid>}
     * @memberof Order
     */
    'bids': Array<Bid>;
    /**
     * 
     * @type {any}
     * @memberof Order
     */
    'attachments'?: any;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'special_requirements'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'is_featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderAddon
 */
export interface OrderAddon {
    /**
     * 
     * @type {number}
     * @memberof OrderAddon
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof OrderAddon
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof OrderAddon
     */
    'addon': number;
    /**
     * 
     * @type {string}
     * @memberof OrderAddon
     */
    'addon_name': string;
    /**
     * 
     * @type {number}
     * @memberof OrderAddon
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderAddon
     */
    'price': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderAnalytics
 */
export interface OrderAnalytics {
    /**
     * 
     * @type {number}
     * @memberof OrderAnalytics
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderAnalytics
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalytics
     */
    'total_orders'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalytics
     */
    'new_orders'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalytics
     */
    'completed_orders'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalytics
     */
    'cancelled_orders'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderAnalytics
     */
    'average_order_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAnalytics
     */
    'revenue_per_order': string;
    /**
     * 
     * @type {string}
     * @memberof OrderAnalytics
     */
    'total_revenue'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalytics
     */
    'total_bids'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderAnalytics
     */
    'average_bids_per_order'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalytics
     */
    'active_clients'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalytics
     */
    'active_providers'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalytics
     */
    'new_users'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderAnalytics
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderAnalyticsCreate
 */
export interface OrderAnalyticsCreate {
    /**
     * 
     * @type {string}
     * @memberof OrderAnalyticsCreate
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalyticsCreate
     */
    'total_orders'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalyticsCreate
     */
    'new_orders'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalyticsCreate
     */
    'completed_orders'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalyticsCreate
     */
    'cancelled_orders'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderAnalyticsCreate
     */
    'average_order_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAnalyticsCreate
     */
    'total_revenue'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalyticsCreate
     */
    'total_bids'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderAnalyticsCreate
     */
    'average_bids_per_order'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalyticsCreate
     */
    'active_clients'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalyticsCreate
     */
    'active_providers'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderAnalyticsCreate
     */
    'new_users'?: number;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderCreate
 */
export interface OrderCreate {
    /**
     * 
     * @type {number}
     * @memberof OrderCreate
     */
    'service_subcategory': number;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'postal_code': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'service_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'service_time'?: string | null;
    /**
     * 
     * @type {UrgencyEnum}
     * @memberof OrderCreate
     */
    'urgency'?: UrgencyEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'budget_min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'budget_max'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderCreate
     */
    'special_requirements'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderDispute
 */
export interface OrderDispute {
    /**
     * 
     * @type {number}
     * @memberof OrderDispute
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof OrderDispute
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof OrderDispute
     */
    'raised_by': number;
    /**
     * 
     * @type {DisputeTypeEnum}
     * @memberof OrderDispute
     */
    'dispute_type': DisputeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderDispute
     */
    'dispute_type_display': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDispute
     */
    'description': string;
    /**
     * 
     * @type {any}
     * @memberof OrderDispute
     */
    'evidence'?: any;
    /**
     * 
     * @type {Status61fEnum}
     * @memberof OrderDispute
     */
    'status'?: Status61fEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderDispute
     */
    'admin_notes'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDispute
     */
    'resolved_by'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OrderDispute
     */
    'resolved_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderDispute
     */
    'resolution'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDispute
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderDisputeCreate
 */
export interface OrderDisputeCreate {
    /**
     * 
     * @type {DisputeTypeEnum}
     * @memberof OrderDisputeCreate
     */
    'dispute_type': DisputeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderDisputeCreate
     */
    'description': string;
    /**
     * 
     * @type {any}
     * @memberof OrderDisputeCreate
     */
    'evidence'?: any;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderDisputeUpdate
 */
export interface OrderDisputeUpdate {
    /**
     * 
     * @type {Status61fEnum}
     * @memberof OrderDisputeUpdate
     */
    'status'?: Status61fEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderDisputeUpdate
     */
    'admin_notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDisputeUpdate
     */
    'resolution'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderPhoto
 */
export interface OrderPhoto {
    /**
     * 
     * @type {number}
     * @memberof OrderPhoto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof OrderPhoto
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof OrderPhoto
     */
    'photo_url': string;
    /**
     * 
     * @type {string}
     * @memberof OrderPhoto
     */
    'caption'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderPhoto
     */
    'is_primary'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderPhoto
     */
    'created_at': string;
}
/**
 * Serializer for order search response.
 * @export
 * @interface OrderSearchResponse
 */
export interface OrderSearchResponse {
    /**
     * Search query
     * @type {string}
     * @memberof OrderSearchResponse
     */
    'query': string;
    /**
     * Number of results found
     * @type {number}
     * @memberof OrderSearchResponse
     */
    'count': number;
    /**
     * List of order results
     * @type {Array<Order>}
     * @memberof OrderSearchResponse
     */
    'results': Array<Order>;
}
/**
 * * `draft` - Draft * `published` - Published * `bidding` - Bidding * `assigned` - Assigned * `in_progress` - In Progress * `completed` - Completed * `cancelled` - Cancelled * `disputed` - Disputed
 * @export
 * @enum {string}
 */

export const OrderStatusEnum = {
    Draft: 'draft',
    Published: 'published',
    Bidding: 'bidding',
    Assigned: 'assigned',
    InProgress: 'in_progress',
    Completed: 'completed',
    Cancelled: 'cancelled',
    Disputed: 'disputed'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface OrderUpdate
 */
export interface OrderUpdate {
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'location': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'postal_code': string;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'service_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'service_time'?: string | null;
    /**
     * 
     * @type {UrgencyEnum}
     * @memberof OrderUpdate
     */
    'urgency'?: UrgencyEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'budget_min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'budget_max'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderUpdate
     */
    'special_requirements'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedAppVersionList
 */
export interface PaginatedAppVersionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAppVersionList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAppVersionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAppVersionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<AppVersion>}
     * @memberof PaginatedAppVersionList
     */
    'results'?: Array<AppVersion>;
}
/**
 * 
 * @export
 * @interface PaginatedBidList
 */
export interface PaginatedBidList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBidList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBidList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBidList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Bid>}
     * @memberof PaginatedBidList
     */
    'results'?: Array<Bid>;
}
/**
 * 
 * @export
 * @interface PaginatedBusinessMetricsList
 */
export interface PaginatedBusinessMetricsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBusinessMetricsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBusinessMetricsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBusinessMetricsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<BusinessMetrics>}
     * @memberof PaginatedBusinessMetricsList
     */
    'results'?: Array<BusinessMetrics>;
}
/**
 * 
 * @export
 * @interface PaginatedChatAttachmentList
 */
export interface PaginatedChatAttachmentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedChatAttachmentList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedChatAttachmentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedChatAttachmentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ChatAttachment>}
     * @memberof PaginatedChatAttachmentList
     */
    'results'?: Array<ChatAttachment>;
}
/**
 * 
 * @export
 * @interface PaginatedChatParticipantList
 */
export interface PaginatedChatParticipantList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedChatParticipantList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedChatParticipantList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedChatParticipantList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ChatParticipant>}
     * @memberof PaginatedChatParticipantList
     */
    'results'?: Array<ChatParticipant>;
}
/**
 * 
 * @export
 * @interface PaginatedChatRoomList
 */
export interface PaginatedChatRoomList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedChatRoomList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedChatRoomList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedChatRoomList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ChatRoom>}
     * @memberof PaginatedChatRoomList
     */
    'results'?: Array<ChatRoom>;
}
/**
 * 
 * @export
 * @interface PaginatedClientList
 */
export interface PaginatedClientList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedClientList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedClientList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedClientList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Client>}
     * @memberof PaginatedClientList
     */
    'results'?: Array<Client>;
}
/**
 * 
 * @export
 * @interface PaginatedGlobalSearchResponseList
 */
export interface PaginatedGlobalSearchResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGlobalSearchResponseList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGlobalSearchResponseList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGlobalSearchResponseList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<GlobalSearchResponse>}
     * @memberof PaginatedGlobalSearchResponseList
     */
    'results'?: Array<GlobalSearchResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedInvoiceList
 */
export interface PaginatedInvoiceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedInvoiceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInvoiceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInvoiceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof PaginatedInvoiceList
     */
    'results'?: Array<Invoice>;
}
/**
 * 
 * @export
 * @interface PaginatedLanguageList
 */
export interface PaginatedLanguageList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLanguageList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLanguageList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLanguageList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Language>}
     * @memberof PaginatedLanguageList
     */
    'results'?: Array<Language>;
}
/**
 * 
 * @export
 * @interface PaginatedMessageList
 */
export interface PaginatedMessageList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMessageList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMessageList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMessageList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Message>}
     * @memberof PaginatedMessageList
     */
    'results'?: Array<Message>;
}
/**
 * 
 * @export
 * @interface PaginatedNotificationList
 */
export interface PaginatedNotificationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedNotificationList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotificationList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotificationList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof PaginatedNotificationList
     */
    'results'?: Array<Notification>;
}
/**
 * 
 * @export
 * @interface PaginatedNotificationTemplateList
 */
export interface PaginatedNotificationTemplateList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedNotificationTemplateList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotificationTemplateList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNotificationTemplateList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<NotificationTemplate>}
     * @memberof PaginatedNotificationTemplateList
     */
    'results'?: Array<NotificationTemplate>;
}
/**
 * 
 * @export
 * @interface PaginatedOrderAddonList
 */
export interface PaginatedOrderAddonList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOrderAddonList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderAddonList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderAddonList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OrderAddon>}
     * @memberof PaginatedOrderAddonList
     */
    'results'?: Array<OrderAddon>;
}
/**
 * 
 * @export
 * @interface PaginatedOrderAnalyticsList
 */
export interface PaginatedOrderAnalyticsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOrderAnalyticsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderAnalyticsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderAnalyticsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OrderAnalytics>}
     * @memberof PaginatedOrderAnalyticsList
     */
    'results'?: Array<OrderAnalytics>;
}
/**
 * 
 * @export
 * @interface PaginatedOrderDisputeList
 */
export interface PaginatedOrderDisputeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOrderDisputeList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderDisputeList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderDisputeList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OrderDispute>}
     * @memberof PaginatedOrderDisputeList
     */
    'results'?: Array<OrderDispute>;
}
/**
 * 
 * @export
 * @interface PaginatedOrderList
 */
export interface PaginatedOrderList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOrderList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Order>}
     * @memberof PaginatedOrderList
     */
    'results'?: Array<Order>;
}
/**
 * 
 * @export
 * @interface PaginatedOrderPhotoList
 */
export interface PaginatedOrderPhotoList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOrderPhotoList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderPhotoList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderPhotoList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OrderPhoto>}
     * @memberof PaginatedOrderPhotoList
     */
    'results'?: Array<OrderPhoto>;
}
/**
 * 
 * @export
 * @interface PaginatedOrderSearchResponseList
 */
export interface PaginatedOrderSearchResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOrderSearchResponseList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderSearchResponseList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOrderSearchResponseList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OrderSearchResponse>}
     * @memberof PaginatedOrderSearchResponseList
     */
    'results'?: Array<OrderSearchResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedPaymentList
 */
export interface PaginatedPaymentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPaymentList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPaymentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPaymentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof PaginatedPaymentList
     */
    'results'?: Array<Payment>;
}
/**
 * 
 * @export
 * @interface PaginatedPaymentMethodList
 */
export interface PaginatedPaymentMethodList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPaymentMethodList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPaymentMethodList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPaymentMethodList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PaymentMethod>}
     * @memberof PaginatedPaymentMethodList
     */
    'results'?: Array<PaymentMethod>;
}
/**
 * 
 * @export
 * @interface PaginatedPerformanceMetricsList
 */
export interface PaginatedPerformanceMetricsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPerformanceMetricsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPerformanceMetricsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPerformanceMetricsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PerformanceMetrics>}
     * @memberof PaginatedPerformanceMetricsList
     */
    'results'?: Array<PerformanceMetrics>;
}
/**
 * 
 * @export
 * @interface PaginatedProviderSearchResponseList
 */
export interface PaginatedProviderSearchResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedProviderSearchResponseList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProviderSearchResponseList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProviderSearchResponseList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ProviderSearchResponse>}
     * @memberof PaginatedProviderSearchResponseList
     */
    'results'?: Array<ProviderSearchResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedReviewList
 */
export interface PaginatedReviewList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedReviewList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedReviewList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedReviewList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Review>}
     * @memberof PaginatedReviewList
     */
    'results'?: Array<Review>;
}
/**
 * 
 * @export
 * @interface PaginatedServiceAreaList
 */
export interface PaginatedServiceAreaList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedServiceAreaList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceAreaList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceAreaList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ServiceArea>}
     * @memberof PaginatedServiceAreaList
     */
    'results'?: Array<ServiceArea>;
}
/**
 * 
 * @export
 * @interface PaginatedServiceCategoryAnalyticsList
 */
export interface PaginatedServiceCategoryAnalyticsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedServiceCategoryAnalyticsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceCategoryAnalyticsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceCategoryAnalyticsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ServiceCategoryAnalytics>}
     * @memberof PaginatedServiceCategoryAnalyticsList
     */
    'results'?: Array<ServiceCategoryAnalytics>;
}
/**
 * 
 * @export
 * @interface PaginatedServiceCategoryList
 */
export interface PaginatedServiceCategoryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedServiceCategoryList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceCategoryList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceCategoryList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ServiceCategory>}
     * @memberof PaginatedServiceCategoryList
     */
    'results'?: Array<ServiceCategory>;
}
/**
 * 
 * @export
 * @interface PaginatedServiceProviderList
 */
export interface PaginatedServiceProviderList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedServiceProviderList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceProviderList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceProviderList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ServiceProvider>}
     * @memberof PaginatedServiceProviderList
     */
    'results'?: Array<ServiceProvider>;
}
/**
 * 
 * @export
 * @interface PaginatedServiceSubcategoryList
 */
export interface PaginatedServiceSubcategoryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedServiceSubcategoryList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceSubcategoryList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedServiceSubcategoryList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ServiceSubcategory>}
     * @memberof PaginatedServiceSubcategoryList
     */
    'results'?: Array<ServiceSubcategory>;
}
/**
 * 
 * @export
 * @interface PaginatedSystemSettingsList
 */
export interface PaginatedSystemSettingsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSystemSettingsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSystemSettingsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSystemSettingsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SystemSettings>}
     * @memberof PaginatedSystemSettingsList
     */
    'results'?: Array<SystemSettings>;
}
/**
 * 
 * @export
 * @interface PaginatedUserActivityList
 */
export interface PaginatedUserActivityList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserActivityList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserActivityList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserActivityList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<UserActivity>}
     * @memberof PaginatedUserActivityList
     */
    'results'?: Array<UserActivity>;
}
/**
 * 
 * @export
 * @interface PaginatedUserListList
 */
export interface PaginatedUserListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserListList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserListList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserListList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<UserList>}
     * @memberof PaginatedUserListList
     */
    'results'?: Array<UserList>;
}
/**
 * 
 * @export
 * @interface PaginatedUserProfileDetailList
 */
export interface PaginatedUserProfileDetailList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserProfileDetailList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserProfileDetailList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserProfileDetailList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<UserProfileDetail>}
     * @memberof PaginatedUserProfileDetailList
     */
    'results'?: Array<UserProfileDetail>;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedChatRoomUpdate
 */
export interface PatchedChatRoomUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedChatRoomUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {ChatTypeEnum}
     * @memberof PatchedChatRoomUpdate
     */
    'chat_type'?: ChatTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedChatRoomUpdate
     */
    'is_active'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedClientUpdate
 */
export interface PatchedClientUpdate {
    /**
     * 
     * @type {any}
     * @memberof PatchedClientUpdate
     */
    'preferred_service_areas'?: any;
    /**
     * 
     * @type {any}
     * @memberof PatchedClientUpdate
     */
    'budget_preferences'?: any;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedMessageUpdate
 */
export interface PatchedMessageUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedMessageUpdate
     */
    'content'?: string;
    /**
     * 
     * @type {MessageTypeEnum}
     * @memberof PatchedMessageUpdate
     */
    'message_type'?: MessageTypeEnum;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedNotificationSettingUpdate
 */
export interface PatchedNotificationSettingUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationSettingUpdate
     */
    'email_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationSettingUpdate
     */
    'push_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationSettingUpdate
     */
    'sms_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationSettingUpdate
     */
    'in_app_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationSettingUpdate
     */
    'order_updates'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationSettingUpdate
     */
    'bid_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationSettingUpdate
     */
    'payment_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationSettingUpdate
     */
    'chat_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationSettingUpdate
     */
    'promotional_notifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationSettingUpdate
     */
    'system_notifications'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedNotificationSettingUpdate
     */
    'quiet_hours_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedNotificationSettingUpdate
     */
    'quiet_hours_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedNotificationSettingUpdate
     */
    'timezone'?: string;
    /**
     * 
     * @type {DigestFrequencyEnum}
     * @memberof PatchedNotificationSettingUpdate
     */
    'digest_frequency'?: DigestFrequencyEnum;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedNotificationTemplateUpdate
 */
export interface PatchedNotificationTemplateUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedNotificationTemplateUpdate
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedNotificationTemplateUpdate
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedNotificationTemplateUpdate
     */
    'short_message'?: string;
    /**
     * 
     * @type {any}
     * @memberof PatchedNotificationTemplateUpdate
     */
    'variables'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationTemplateUpdate
     */
    'is_active'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedNotificationUpdate
 */
export interface PatchedNotificationUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedNotificationUpdate
     */
    'is_read'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedNotificationUpdate
     */
    'read_at'?: string | null;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedOrderDisputeUpdate
 */
export interface PatchedOrderDisputeUpdate {
    /**
     * 
     * @type {Status61fEnum}
     * @memberof PatchedOrderDisputeUpdate
     */
    'status'?: Status61fEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderDisputeUpdate
     */
    'admin_notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderDisputeUpdate
     */
    'resolution'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedOrderUpdate
 */
export interface PatchedOrderUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'service_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'service_time'?: string | null;
    /**
     * 
     * @type {UrgencyEnum}
     * @memberof PatchedOrderUpdate
     */
    'urgency'?: UrgencyEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'budget_min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'budget_max'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOrderUpdate
     */
    'special_requirements'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedPaymentCreate
 */
export interface PatchedPaymentCreate {
    /**
     * 
     * @type {number}
     * @memberof PatchedPaymentCreate
     */
    'invoice'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPaymentCreate
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPaymentCreate
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPaymentCreate
     */
    'payment_method'?: number;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedPaymentMethodUpdate
 */
export interface PatchedPaymentMethodUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPaymentMethodUpdate
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPaymentMethodUpdate
     */
    'is_active'?: boolean;
}
/**
 * Serializer for updating existing reviews.
 * @export
 * @interface PatchedReviewUpdate
 */
export interface PatchedReviewUpdate {
    /**
     * Overall rating from 1 to 5 stars
     * @type {number}
     * @memberof PatchedReviewUpdate
     */
    'overall_rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedReviewUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedReviewUpdate
     */
    'comment'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedServiceProviderUpdate
 */
export interface PatchedServiceProviderUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceProviderUpdate
     */
    'business_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceProviderUpdate
     */
    'business_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceProviderUpdate
     */
    'business_license'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceProviderUpdate
     */
    'years_of_experience'?: number;
    /**
     * 
     * @type {any}
     * @memberof PatchedServiceProviderUpdate
     */
    'service_areas'?: any;
    /**
     * 
     * @type {number}
     * @memberof PatchedServiceProviderUpdate
     */
    'travel_radius'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedServiceProviderUpdate
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof PatchedServiceProviderUpdate
     */
    'availability_schedule'?: any;
    /**
     * 
     * @type {any}
     * @memberof PatchedServiceProviderUpdate
     */
    'verification_documents'?: any;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PatchedUserProfileUpdate
 */
export interface PatchedUserProfileUpdate {
    /**
     * 
     * @type {UserTypeD25Enum}
     * @memberof PatchedUserProfileUpdate
     */
    'user_type'?: UserTypeD25Enum;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'date_of_birth'?: string | null;
    /**
     * 
     * @type {PatchedUserProfileUpdateGender}
     * @memberof PatchedUserProfileUpdate
     */
    'gender'?: PatchedUserProfileUpdateGender;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserProfileUpdate
     */
    'postal_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserProfileUpdate
     */
    'preferred_language'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof PatchedUserProfileUpdate
     */
    'notification_preferences'?: any;
}
/**
 * @type PatchedUserProfileUpdateGender
 * @export
 */
export type PatchedUserProfileUpdateGender = BlankEnum | GenderEnum;

/**
 * Serializer for updating user profile - enhanced version of api_users EditUserSettingsView
 * @export
 * @interface PatchedUserUpdate
 */
export interface PatchedUserUpdate {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'photo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserUpdate
     */
    'last_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserUpdate
     */
    'timezone_difference'?: number;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'invoice': number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'currency'?: string;
    /**
     * 
     * @type {PaymentStatusEnum}
     * @memberof Payment
     */
    'status'?: PaymentStatusEnum;
    /**
     * 
     * @type {PaymentPaymentMethod}
     * @memberof Payment
     */
    'payment_method': PaymentPaymentMethod;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'stripe_payment_intent_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'stripe_charge_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'processed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PaymentCreate
 */
export interface PaymentCreate {
    /**
     * 
     * @type {number}
     * @memberof PaymentCreate
     */
    'invoice': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentCreate
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCreate
     */
    'currency'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentCreate
     */
    'payment_method': number;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    'user': number;
    /**
     * 
     * @type {MethodTypeEnum}
     * @memberof PaymentMethod
     */
    'method_type': MethodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'method_type_display': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'card_last4'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'card_brand'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    'card_exp_month'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    'card_exp_year'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    'is_active'?: boolean;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PaymentMethodCreate
 */
export interface PaymentMethodCreate {
    /**
     * 
     * @type {MethodTypeEnum}
     * @memberof PaymentMethodCreate
     */
    'method_type': MethodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCreate
     */
    'card_last4'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCreate
     */
    'card_brand'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodCreate
     */
    'card_exp_month'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodCreate
     */
    'card_exp_year'?: number | null;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PaymentMethodUpdate
 */
export interface PaymentMethodUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodUpdate
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodUpdate
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentPaymentMethod
 */
export interface PaymentPaymentMethod {
    /**
     * 
     * @type {number}
     * @memberof PaymentPaymentMethod
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PaymentPaymentMethod
     */
    'user': number;
    /**
     * 
     * @type {MethodTypeEnum}
     * @memberof PaymentPaymentMethod
     */
    'method_type': MethodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentPaymentMethod
     */
    'method_type_display': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentPaymentMethod
     */
    'card_last4'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentPaymentMethod
     */
    'card_brand'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentPaymentMethod
     */
    'card_exp_month'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PaymentPaymentMethod
     */
    'card_exp_year'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentPaymentMethod
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentPaymentMethod
     */
    'is_active'?: boolean;
}
/**
 * * `pending` - Pending * `processing` - Processing * `completed` - Completed * `failed` - Failed * `cancelled` - Cancelled * `refunded` - Refunded
 * @export
 * @enum {string}
 */

export const PaymentStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed',
    Cancelled: 'cancelled',
    Refunded: 'refunded'
} as const;

export type PaymentStatusEnum = typeof PaymentStatusEnum[keyof typeof PaymentStatusEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface PerformanceMetrics
 */
export interface PerformanceMetrics {
    /**
     * 
     * @type {number}
     * @memberof PerformanceMetrics
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PerformanceMetrics
     */
    'date': string;
    /**
     * 
     * @type {TimePeriodEnum}
     * @memberof PerformanceMetrics
     */
    'time_period'?: TimePeriodEnum;
    /**
     * 
     * @type {number}
     * @memberof PerformanceMetrics
     */
    'average_response_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PerformanceMetrics
     */
    'max_response_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PerformanceMetrics
     */
    'min_response_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PerformanceMetrics
     */
    'total_errors'?: number;
    /**
     * 
     * @type {string}
     * @memberof PerformanceMetrics
     */
    'error_rate'?: string;
    /**
     * 
     * @type {number}
     * @memberof PerformanceMetrics
     */
    'active_users'?: number;
    /**
     * 
     * @type {number}
     * @memberof PerformanceMetrics
     */
    'concurrent_users'?: number;
    /**
     * 
     * @type {number}
     * @memberof PerformanceMetrics
     */
    'database_queries'?: number;
    /**
     * 
     * @type {string}
     * @memberof PerformanceMetrics
     */
    'cpu_usage'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerformanceMetrics
     */
    'memory_usage'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerformanceMetrics
     */
    'disk_usage'?: string;
    /**
     * 
     * @type {string}
     * @memberof PerformanceMetrics
     */
    'created_at': string;
}
/**
 * * `android` - Android * `ios` - iOS * `web` - Web * `all` - All Platforms
 * @export
 * @enum {string}
 */

export const PlatformEnum = {
    Android: 'android',
    Ios: 'ios',
    Web: 'web',
    All: 'all'
} as const;

export type PlatformEnum = typeof PlatformEnum[keyof typeof PlatformEnum];


/**
 * * `low` - Low * `normal` - Normal * `high` - High * `urgent` - Urgent
 * @export
 * @enum {string}
 */

export const PriorityEnum = {
    Low: 'low',
    Normal: 'normal',
    High: 'high',
    Urgent: 'urgent'
} as const;

export type PriorityEnum = typeof PriorityEnum[keyof typeof PriorityEnum];


/**
 * Serializer for provider search response.
 * @export
 * @interface ProviderSearchResponse
 */
export interface ProviderSearchResponse {
    /**
     * Search query
     * @type {string}
     * @memberof ProviderSearchResponse
     */
    'query': string;
    /**
     * Number of results found
     * @type {number}
     * @memberof ProviderSearchResponse
     */
    'count': number;
    /**
     * List of provider results
     * @type {Array<ServiceProvider>}
     * @memberof ProviderSearchResponse
     */
    'results': Array<ServiceProvider>;
}
/**
 * Serializer for reading review data.
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'order_id': number;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'order_title': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'reviewer_name': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'reviewer_email': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'provider_name': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'provider_email': string;
    /**
     * Overall rating from 1 to 5 stars
     * @type {number}
     * @memberof Review
     */
    'overall_rating': number;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Review
     */
    'is_verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'updated_at': string;
}
/**
 * Serializer for review analytics data.
 * @export
 * @interface ReviewAnalytics
 */
export interface ReviewAnalytics {
    /**
     * 
     * @type {number}
     * @memberof ReviewAnalytics
     */
    'total_reviews': number;
    /**
     * 
     * @type {string}
     * @memberof ReviewAnalytics
     */
    'average_rating': string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ReviewAnalytics
     */
    'rating_distribution': Array<{ [key: string]: any; }>;
}
/**
 * Serializer for creating new reviews.
 * @export
 * @interface ReviewCreate
 */
export interface ReviewCreate {
    /**
     * 
     * @type {number}
     * @memberof ReviewCreate
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof ReviewCreate
     */
    'provider': number;
    /**
     * Overall rating from 1 to 5 stars
     * @type {number}
     * @memberof ReviewCreate
     */
    'overall_rating': number;
    /**
     * 
     * @type {string}
     * @memberof ReviewCreate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewCreate
     */
    'comment'?: string;
}
/**
 * Serializer for updating existing reviews.
 * @export
 * @interface ReviewUpdate
 */
export interface ReviewUpdate {
    /**
     * Overall rating from 1 to 5 stars
     * @type {number}
     * @memberof ReviewUpdate
     */
    'overall_rating': number;
    /**
     * 
     * @type {string}
     * @memberof ReviewUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewUpdate
     */
    'comment'?: string;
}
/**
 * * `member` - Member * `admin` - Admin * `moderator` - Moderator
 * @export
 * @enum {string}
 */

export const RoleEnum = {
    Member: 'member',
    Admin: 'admin',
    Moderator: 'moderator'
} as const;

export type RoleEnum = typeof RoleEnum[keyof typeof RoleEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceArea
 */
export interface ServiceArea {
    /**
     * 
     * @type {number}
     * @memberof ServiceArea
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'latitude'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'longitude'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceArea
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'base_price_multiplier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'travel_fee'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceArea
     */
    'coordinates': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceCategory
 */
export interface ServiceCategory {
    /**
     * 
     * @type {number}
     * @memberof ServiceCategory
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'icon'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'color'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCategory
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategory
     */
    'sort_order'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'banner_image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceCategory
     */
    'featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'commission_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategory
     */
    'slug'?: string;
    /**
     * 
     * @type {Array<ServiceSubcategory>}
     * @memberof ServiceCategory
     */
    'subcategories': Array<ServiceSubcategory>;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceCategoryAnalytics
 */
export interface ServiceCategoryAnalytics {
    /**
     * 
     * @type {number}
     * @memberof ServiceCategoryAnalytics
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryAnalytics
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategoryAnalytics
     */
    'category': number;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategoryAnalytics
     */
    'order_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryAnalytics
     */
    'total_revenue'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryAnalytics
     */
    'average_order_value'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategoryAnalytics
     */
    'bid_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryAnalytics
     */
    'completion_rate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryAnalytics
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceCategoryAnalyticsCreate
 */
export interface ServiceCategoryAnalyticsCreate {
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryAnalyticsCreate
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategoryAnalyticsCreate
     */
    'category': number;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategoryAnalyticsCreate
     */
    'order_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryAnalyticsCreate
     */
    'total_revenue'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryAnalyticsCreate
     */
    'average_order_value'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceCategoryAnalyticsCreate
     */
    'bid_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceCategoryAnalyticsCreate
     */
    'completion_rate'?: string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceProvider
 */
export interface ServiceProvider {
    /**
     * 
     * @type {number}
     * @memberof ServiceProvider
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ServiceProvider
     */
    'user_profile': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'business_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'business_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'business_license'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceProvider
     */
    'years_of_experience'?: number;
    /**
     * 
     * @type {any}
     * @memberof ServiceProvider
     */
    'service_areas'?: any;
    /**
     * 
     * @type {number}
     * @memberof ServiceProvider
     */
    'travel_radius'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProvider
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ServiceProvider
     */
    'availability_schedule'?: any;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'average_rating': string;
    /**
     * 
     * @type {number}
     * @memberof ServiceProvider
     */
    'total_reviews': number;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProvider
     */
    'is_verified_provider': boolean;
    /**
     * 
     * @type {any}
     * @memberof ServiceProvider
     */
    'verification_documents'?: any;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProvider
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceProviderUpdate
 */
export interface ServiceProviderUpdate {
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderUpdate
     */
    'business_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderUpdate
     */
    'business_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceProviderUpdate
     */
    'business_license'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderUpdate
     */
    'years_of_experience'?: number;
    /**
     * 
     * @type {any}
     * @memberof ServiceProviderUpdate
     */
    'service_areas'?: any;
    /**
     * 
     * @type {number}
     * @memberof ServiceProviderUpdate
     */
    'travel_radius'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceProviderUpdate
     */
    'is_available'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ServiceProviderUpdate
     */
    'availability_schedule'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServiceProviderUpdate
     */
    'verification_documents'?: any;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface ServiceSubcategory
 */
export interface ServiceSubcategory {
    /**
     * 
     * @type {number}
     * @memberof ServiceSubcategory
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'icon'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceSubcategory
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServiceSubcategory
     */
    'sort_order'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceSubcategory
     */
    'featured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'base_price'?: string | null;
    /**
     * 
     * @type {ComplexityLevelEnum}
     * @memberof ServiceSubcategory
     */
    'complexity_level'?: ComplexityLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof ServiceSubcategory
     */
    'complexity_level_display': string;
}
/**
 * * `string` - String * `integer` - Целое * `boolean` - Boolean * `json` - JSON * `file` - Файл
 * @export
 * @enum {string}
 */

export const SettingTypeEnum = {
    String: 'string',
    Integer: 'integer',
    Boolean: 'boolean',
    Json: 'json',
    File: 'file'
} as const;

export type SettingTypeEnum = typeof SettingTypeEnum[keyof typeof SettingTypeEnum];


/**
 * * `open` - Open * `under_review` - Under Review * `resolved` - Resolved * `closed` - Closed
 * @export
 * @enum {string}
 */

export const Status61fEnum = {
    Open: 'open',
    UnderReview: 'under_review',
    Resolved: 'resolved',
    Closed: 'closed'
} as const;

export type Status61fEnum = typeof Status61fEnum[keyof typeof Status61fEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface SystemSettings
 */
export interface SystemSettings {
    /**
     * 
     * @type {number}
     * @memberof SystemSettings
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SystemSettings
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {SettingTypeEnum}
     * @memberof SystemSettings
     */
    'setting_type'?: SettingTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemSettings
     */
    'setting_type_display': string;
}
/**
 * * `hourly` - Hourly * `daily` - Daily * `weekly` - Weekly * `monthly` - Monthly
 * @export
 * @enum {string}
 */

export const TimePeriodEnum = {
    Hourly: 'hourly',
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type TimePeriodEnum = typeof TimePeriodEnum[keyof typeof TimePeriodEnum];


/**
 * * `low` - Low * `medium` - Medium * `high` - High * `urgent` - Urgent
 * @export
 * @enum {string}
 */

export const UrgencyEnum = {
    Low: 'low',
    Medium: 'medium',
    High: 'high',
    Urgent: 'urgent'
} as const;

export type UrgencyEnum = typeof UrgencyEnum[keyof typeof UrgencyEnum];


/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface UserActivity
 */
export interface UserActivity {
    /**
     * 
     * @type {number}
     * @memberof UserActivity
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof UserActivity
     */
    'user': number;
    /**
     * 
     * @type {ActivityTypeEnum}
     * @memberof UserActivity
     */
    'activity_type': ActivityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    'activity_type_display': string;
    /**
     * 
     * @type {any}
     * @memberof UserActivity
     */
    'context_data'?: any;
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    'ip_address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    'user_agent'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    'session_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    'related_object_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserActivity
     */
    'related_object_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserActivity
     */
    'response_time'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserActivity
     */
    'created_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface UserActivityCreate
 */
export interface UserActivityCreate {
    /**
     * 
     * @type {ActivityTypeEnum}
     * @memberof UserActivityCreate
     */
    'activity_type': ActivityTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof UserActivityCreate
     */
    'context_data'?: any;
    /**
     * 
     * @type {string}
     * @memberof UserActivityCreate
     */
    'related_object_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserActivityCreate
     */
    'related_object_id'?: number | null;
}
/**
 * Serializer for listing users - not in api_users, useful for admin
 * @export
 * @interface UserList
 */
export interface UserList {
    /**
     * 
     * @type {number}
     * @memberof UserList
     */
    'id': number;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof UserList
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'email': string;
    /**
     * Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи.
     * @type {boolean}
     * @memberof UserList
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'date_joined'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'groups': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserList
     */
    'photo_url'?: string | null;
    /**
     * 
     * @type {UserListUserTypeEnum}
     * @memberof UserList
     */
    'user_type'?: UserListUserTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserList
     */
    'blocked'?: boolean;
}
/**
 * * `free` - Бесплатный * `paid` - Оплаченный * `premium_paid` - Премиум оплаченный
 * @export
 * @enum {string}
 */

export const UserListUserTypeEnum = {
    Free: 'free',
    Paid: 'paid',
    PremiumPaid: 'premium_paid'
} as const;

export type UserListUserTypeEnum = typeof UserListUserTypeEnum[keyof typeof UserListUserTypeEnum];


/**
 * Serializer for user profile information - enhanced version of api_users
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    'id': number;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof UserProfile
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'date_joined': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'last_login': string | null;
    /**
     * Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи.
     * @type {boolean}
     * @memberof UserProfile
     */
    'is_active'?: boolean;
    /**
     * Отметьте, если пользователь может входить в административную часть сайта.
     * @type {boolean}
     * @memberof UserProfile
     */
    'is_staff': boolean;
    /**
     * Указывает, что пользователь имеет все права без явного их назначения.
     * @type {boolean}
     * @memberof UserProfile
     */
    'is_superuser': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'groups': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'permissions': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'photo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'photo_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    'timezone_difference'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    'points'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    'day_streak'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    'max_day_streak'?: number;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface UserProfileDetail
 */
export interface UserProfileDetail {
    /**
     * 
     * @type {number}
     * @memberof UserProfileDetail
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof UserProfileDetail
     */
    'user': number;
    /**
     * 
     * @type {UserTypeD25Enum}
     * @memberof UserProfileDetail
     */
    'user_type'?: UserTypeD25Enum;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'date_of_birth'?: string | null;
    /**
     * 
     * @type {PatchedUserProfileUpdateGender}
     * @memberof UserProfileDetail
     */
    'gender'?: PatchedUserProfileUpdateGender;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'postal_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserProfileDetail
     */
    'preferred_language'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof UserProfileDetail
     */
    'notification_preferences'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileDetail
     */
    'is_verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'verification_date': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDetail
     */
    'updated_at': string;
}
/**
 * Serializer for models with timestamp fields.
 * @export
 * @interface UserProfileUpdate
 */
export interface UserProfileUpdate {
    /**
     * 
     * @type {UserTypeD25Enum}
     * @memberof UserProfileUpdate
     */
    'user_type'?: UserTypeD25Enum;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'date_of_birth'?: string | null;
    /**
     * 
     * @type {PatchedUserProfileUpdateGender}
     * @memberof UserProfileUpdate
     */
    'gender'?: PatchedUserProfileUpdateGender;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'phone_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdate
     */
    'postal_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserProfileUpdate
     */
    'preferred_language'?: number | null;
    /**
     * 
     * @type {any}
     * @memberof UserProfileUpdate
     */
    'notification_preferences'?: any;
}
/**
 * * `client` - Client * `service_provider` - Service Provider * `both` - Both
 * @export
 * @enum {string}
 */

export const UserTypeD25Enum = {
    Client: 'client',
    ServiceProvider: 'service_provider',
    Both: 'both'
} as const;

export type UserTypeD25Enum = typeof UserTypeD25Enum[keyof typeof UserTypeD25Enum];


/**
 * Serializer for updating user profile - enhanced version of api_users EditUserSettingsView
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'photo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'last_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserUpdate
     */
    'timezone_difference'?: number;
}
/**
 * Serializer for WebSocket connection information.
 * @export
 * @interface WebSocketInfo
 */
export interface WebSocketInfo {
    /**
     * Base WebSocket URL
     * @type {string}
     * @memberof WebSocketInfo
     */
    'websocket_url': string;
    /**
     * Whether authentication is required
     * @type {boolean}
     * @memberof WebSocketInfo
     */
    'auth_required': boolean;
    /**
     * Token parameter name
     * @type {string}
     * @memberof WebSocketInfo
     */
    'token_param': string;
    /**
     * Connection URL format with placeholders
     * @type {string}
     * @memberof WebSocketInfo
     */
    'connection_format': string;
    /**
     * Available message types
     * @type {Array<string>}
     * @memberof WebSocketInfo
     */
    'message_types': Array<string>;
}

/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(format, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.schemaRetrieve(format, lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for schemaRetrieve operation in SchemaApi.
 * @export
 * @interface SchemaApiSchemaRetrieveRequest
 */
export interface SchemaApiSchemaRetrieveRequest {
    /**
     * 
     * @type {'json' | 'yaml'}
     * @memberof SchemaApiSchemaRetrieve
     */
    readonly format?: 'json' | 'yaml'

    /**
     * 
     * @type {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'}
     * @memberof SchemaApiSchemaRetrieve
     */
    readonly lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'ckb' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'ug' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'
}

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {SchemaApiSchemaRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(requestParameters: SchemaApiSchemaRetrieveRequest = {}, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaRetrieve(requestParameters.format, requestParameters.lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1Api - axios parameter creator
 * @export
 */
export const V1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserActivityCreate} userActivityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsActivitiesCreateCreate: async (userActivityCreate: UserActivityCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userActivityCreate' is not null or undefined
            assertParamExists('v1AnalyticsActivitiesCreateCreate', 'userActivityCreate', userActivityCreate)
            const localVarPath = `/api/v1/analytics/activities/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userActivityCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'bid_submitted' | 'chat_message' | 'login' | 'logout' | 'order_created' | 'order_viewed' | 'payment_made' | 'profile_updated' | 'search_performed' | 'service_viewed'} [activityType] * &#x60;login&#x60; - Login * &#x60;logout&#x60; - Logout * &#x60;order_created&#x60; - Order Created * &#x60;order_viewed&#x60; - Order Viewed * &#x60;bid_submitted&#x60; - Bid Submitted * &#x60;chat_message&#x60; - Chat Message * &#x60;payment_made&#x60; - Payment Made * &#x60;profile_updated&#x60; - Profile Updated * &#x60;search_performed&#x60; - Search Performed * &#x60;service_viewed&#x60; - Service Viewed
         * @param {string} [ipAddress] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsActivitiesList: async (activityType?: 'bid_submitted' | 'chat_message' | 'login' | 'logout' | 'order_created' | 'order_viewed' | 'payment_made' | 'profile_updated' | 'search_performed' | 'service_viewed', ipAddress?: string, ordering?: string, page?: number, pageSize?: number, search?: string, user?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/activities/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (activityType !== undefined) {
                localVarQueryParameter['activity_type'] = activityType;
            }

            if (ipAddress !== undefined) {
                localVarQueryParameter['ip_address'] = ipAddress;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BusinessMetricsCreate} businessMetricsCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsBusinessCreateCreate: async (businessMetricsCreate: BusinessMetricsCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessMetricsCreate' is not null or undefined
            assertParamExists('v1AnalyticsBusinessCreateCreate', 'businessMetricsCreate', businessMetricsCreate)
            const localVarPath = `/api/v1/analytics/business/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessMetricsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsBusinessList: async (date?: string, ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/business/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServiceCategoryAnalyticsCreate} serviceCategoryAnalyticsCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsCategoriesCreateCreate: async (serviceCategoryAnalyticsCreate: ServiceCategoryAnalyticsCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceCategoryAnalyticsCreate' is not null or undefined
            assertParamExists('v1AnalyticsCategoriesCreateCreate', 'serviceCategoryAnalyticsCreate', serviceCategoryAnalyticsCreate)
            const localVarPath = `/api/v1/analytics/categories/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceCategoryAnalyticsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [category] 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsCategoriesList: async (category?: number, date?: string, ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dashboard overview data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsDashboardRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/dashboard/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrderAnalyticsCreate} orderAnalyticsCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsOrdersCreateCreate: async (orderAnalyticsCreate: OrderAnalyticsCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderAnalyticsCreate' is not null or undefined
            assertParamExists('v1AnalyticsOrdersCreateCreate', 'orderAnalyticsCreate', orderAnalyticsCreate)
            const localVarPath = `/api/v1/analytics/orders/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderAnalyticsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsOrdersList: async (date?: string, ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'daily' | 'hourly' | 'monthly' | 'weekly'} [timePeriod] * &#x60;hourly&#x60; - Hourly * &#x60;daily&#x60; - Daily * &#x60;weekly&#x60; - Weekly * &#x60;monthly&#x60; - Monthly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsPerformanceList: async (date?: string, ordering?: string, page?: number, pageSize?: number, timePeriod?: 'daily' | 'hourly' | 'monthly' | 'weekly', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/performance/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (timePeriod !== undefined) {
                localVarQueryParameter['time_period'] = timePeriod;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate user with Firebase ID token or register new user if verified.
         * @param {FireBaseAuth} fireBaseAuth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthFirebaseCreate: async (fireBaseAuth: FireBaseAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fireBaseAuth' is not null or undefined
            assertParamExists('v1AuthFirebaseCreate', 'fireBaseAuth', fireBaseAuth)
            const localVarPath = `/api/v1/auth/firebase/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fireBaseAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User logout view - enhanced version of api_users LogOutView
         * @param {LogoutResponse} logoutResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLogoutCreate: async (logoutResponse: LogoutResponse, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logoutResponse' is not null or undefined
            assertParamExists('v1AuthLogoutCreate', 'logoutResponse', logoutResponse)
            const localVarPath = `/api/v1/auth/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logoutResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ChatAttachmentCreate} chatAttachmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatAttachmentsCreateCreate: async (chatAttachmentCreate: ChatAttachmentCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatAttachmentCreate' is not null or undefined
            assertParamExists('v1ChatAttachmentsCreateCreate', 'chatAttachmentCreate', chatAttachmentCreate)
            const localVarPath = `/api/v1/chat/attachments/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatAttachmentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatAttachmentsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatAttachmentsDestroy', 'id', id)
            const localVarPath = `/api/v1/chat/attachments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatAttachmentsList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/attachments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatAttachmentsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatAttachmentsRetrieve', 'id', id)
            const localVarPath = `/api/v1/chat/attachments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {MessageCreate} messageCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesCreateCreate: async (messageCreate: MessageCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageCreate' is not null or undefined
            assertParamExists('v1ChatMessagesCreateCreate', 'messageCreate', messageCreate)
            const localVarPath = `/api/v1/chat/messages/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatMessagesDestroy', 'id', id)
            const localVarPath = `/api/v1/chat/messages/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/messages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedMessageUpdate} [patchedMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesPartialUpdate: async (id: number, patchedMessageUpdate?: PatchedMessageUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatMessagesPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/chat/messages/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMessageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatMessagesRetrieve', 'id', id)
            const localVarPath = `/api/v1/chat/messages/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {MessageUpdate} messageUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesUpdate: async (id: number, messageUpdate: MessageUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatMessagesUpdate', 'id', id)
            // verify required parameter 'messageUpdate' is not null or undefined
            assertParamExists('v1ChatMessagesUpdate', 'messageUpdate', messageUpdate)
            const localVarPath = `/api/v1/chat/messages/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ChatParticipantCreate} chatParticipantCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatParticipantsCreateCreate: async (chatParticipantCreate: ChatParticipantCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatParticipantCreate' is not null or undefined
            assertParamExists('v1ChatParticipantsCreateCreate', 'chatParticipantCreate', chatParticipantCreate)
            const localVarPath = `/api/v1/chat/participants/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatParticipantCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatParticipantsList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/participants/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ChatRoomCreate} [chatRoomCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatRoomsCreateCreate: async (chatRoomCreate?: ChatRoomCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/rooms/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatRoomCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatRoomsList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/rooms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedChatRoomUpdate} [patchedChatRoomUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatRoomsPartialUpdate: async (id: number, patchedChatRoomUpdate?: PatchedChatRoomUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatRoomsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/chat/rooms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedChatRoomUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatRoomsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatRoomsRetrieve', 'id', id)
            const localVarPath = `/api/v1/chat/rooms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {ChatRoomUpdate} [chatRoomUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatRoomsUpdate: async (id: number, chatRoomUpdate?: ChatRoomUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChatRoomsUpdate', 'id', id)
            const localVarPath = `/api/v1/chat/rooms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatRoomUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get WebSocket connection information for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatWebsocketInfoRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/websocket-info/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'all' | 'android' | 'ios' | 'web'} [platform] * &#x60;android&#x60; - Android * &#x60;ios&#x60; - iOS * &#x60;web&#x60; - Web * &#x60;all&#x60; - All Platforms
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreAppVersionsList: async (isActive?: boolean, ordering?: string, page?: number, pageSize?: number, platform?: 'all' | 'android' | 'ios' | 'web', search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/app-versions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isActive] 
         * @param {boolean} [isDefault] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreLanguagesList: async (isActive?: boolean, isDefault?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/languages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['is_default'] = isDefault;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [country] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasList: async (country?: string, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, state?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/service-areas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesList: async (featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/service-categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [category] 
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesList: async (category?: number, featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/service-subcategories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (featured !== undefined) {
                localVarQueryParameter['featured'] = featured;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [category] 
         * @param {boolean} [isPublic] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsList: async (category?: string, isPublic?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/core/system-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (isPublic !== undefined) {
                localVarQueryParameter['is_public'] = isPublic;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NotificationCreate} notificationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsCreateCreate: async (notificationCreate: NotificationCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationCreate' is not null or undefined
            assertParamExists('v1NotificationsCreateCreate', 'notificationCreate', notificationCreate)
            const localVarPath = `/api/v1/notifications/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedNotificationUpdate} [patchedNotificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsPartialUpdate: async (id: number, patchedNotificationUpdate?: PatchedNotificationUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotificationsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/notifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedNotificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotificationsRetrieve', 'id', id)
            const localVarPath = `/api/v1/notifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedNotificationSettingUpdate} [patchedNotificationSettingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsSettingsPartialUpdate: async (patchedNotificationSettingUpdate?: PatchedNotificationSettingUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedNotificationSettingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsSettingsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NotificationSettingUpdate} [notificationSettingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsSettingsUpdate: async (notificationSettingUpdate?: NotificationSettingUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationSettingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NotificationTemplateCreate} notificationTemplateCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsTemplatesCreateCreate: async (notificationTemplateCreate: NotificationTemplateCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationTemplateCreate' is not null or undefined
            assertParamExists('v1NotificationsTemplatesCreateCreate', 'notificationTemplateCreate', notificationTemplateCreate)
            const localVarPath = `/api/v1/notifications/templates/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationTemplateCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isActive] 
         * @param {'bid_received' | 'chat_message' | 'order_update' | 'payment_failed' | 'payment_success' | 'promotional' | 'system_alert'} [notificationType] * &#x60;order_update&#x60; - Order Update * &#x60;bid_received&#x60; - Bid Received * &#x60;payment_success&#x60; - Payment Success * &#x60;payment_failed&#x60; - Payment Failed * &#x60;chat_message&#x60; - Chat Message * &#x60;system_alert&#x60; - System Alert * &#x60;promotional&#x60; - Promotional
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsTemplatesList: async (isActive?: boolean, notificationType?: 'bid_received' | 'chat_message' | 'order_update' | 'payment_failed' | 'payment_success' | 'promotional' | 'system_alert', ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (notificationType !== undefined) {
                localVarQueryParameter['notification_type'] = notificationType;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedNotificationTemplateUpdate} [patchedNotificationTemplateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsTemplatesPartialUpdate: async (id: number, patchedNotificationTemplateUpdate?: PatchedNotificationTemplateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotificationsTemplatesPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/notifications/templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedNotificationTemplateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsTemplatesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotificationsTemplatesRetrieve', 'id', id)
            const localVarPath = `/api/v1/notifications/templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {NotificationTemplateUpdate} notificationTemplateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsTemplatesUpdate: async (id: number, notificationTemplateUpdate: NotificationTemplateUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotificationsTemplatesUpdate', 'id', id)
            // verify required parameter 'notificationTemplateUpdate' is not null or undefined
            assertParamExists('v1NotificationsTemplatesUpdate', 'notificationTemplateUpdate', notificationTemplateUpdate)
            const localVarPath = `/api/v1/notifications/templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationTemplateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {NotificationUpdate} [notificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsUpdate: async (id: number, notificationUpdate?: NotificationUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1NotificationsUpdate', 'id', id)
            const localVarPath = `/api/v1/notifications/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersAddonsList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/addons/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} orderId 
         * @param {BidCreate} bidCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsCreate: async (orderId: number, bidCreate: BidCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1OrdersBidsCreate', 'orderId', orderId)
            // verify required parameter 'bidCreate' is not null or undefined
            assertParamExists('v1OrdersBidsCreate', 'bidCreate', bidCreate)
            const localVarPath = `/api/v1/orders/{order_id}/bids/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bidCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/bids/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersCreateCreate: async (orderCreate: OrderCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderCreate' is not null or undefined
            assertParamExists('v1OrdersCreateCreate', 'orderCreate', orderCreate)
            const localVarPath = `/api/v1/orders/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} orderId 
         * @param {OrderDisputeCreate} orderDisputeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersDisputesCreate: async (orderId: number, orderDisputeCreate: OrderDisputeCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1OrdersDisputesCreate', 'orderId', orderId)
            // verify required parameter 'orderDisputeCreate' is not null or undefined
            assertParamExists('v1OrdersDisputesCreate', 'orderDisputeCreate', orderDisputeCreate)
            const localVarPath = `/api/v1/orders/{order_id}/disputes/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderDisputeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersDisputesList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/disputes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedOrderDisputeUpdate} [patchedOrderDisputeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersDisputesPartialUpdate: async (id: number, patchedOrderDisputeUpdate?: PatchedOrderDisputeUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersDisputesPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/orders/disputes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOrderDisputeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersDisputesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersDisputesRetrieve', 'id', id)
            const localVarPath = `/api/v1/orders/disputes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {OrderDisputeUpdate} [orderDisputeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersDisputesUpdate: async (id: number, orderDisputeUpdate?: OrderDisputeUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersDisputesUpdate', 'id', id)
            const localVarPath = `/api/v1/orders/disputes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderDisputeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedOrderUpdate} [patchedOrderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersPartialUpdate: async (id: number, patchedOrderUpdate?: PatchedOrderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/orders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOrderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersPhotosList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/photos/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersRetrieve', 'id', id)
            const localVarPath = `/api/v1/orders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {OrderUpdate} orderUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersUpdate: async (id: number, orderUpdate: OrderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1OrdersUpdate', 'id', id)
            // verify required parameter 'orderUpdate' is not null or undefined
            assertParamExists('v1OrdersUpdate', 'orderUpdate', orderUpdate)
            const localVarPath = `/api/v1/orders/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsCreateCreate: async (paymentCreate: PaymentCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentCreate' is not null or undefined
            assertParamExists('v1PaymentsCreateCreate', 'paymentCreate', paymentCreate)
            const localVarPath = `/api/v1/payments/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InvoiceCreate} invoiceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesCreateCreate: async (invoiceCreate: InvoiceCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceCreate' is not null or undefined
            assertParamExists('v1PaymentsInvoicesCreateCreate', 'invoiceCreate', invoiceCreate)
            const localVarPath = `/api/v1/payments/invoices/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/invoices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsInvoicesRetrieve', 'id', id)
            const localVarPath = `/api/v1/payments/invoices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsList: async (ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PaymentMethodCreate} paymentMethodCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsCreateCreate: async (paymentMethodCreate: PaymentMethodCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodCreate' is not null or undefined
            assertParamExists('v1PaymentsMethodsCreateCreate', 'paymentMethodCreate', paymentMethodCreate)
            const localVarPath = `/api/v1/payments/methods/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentMethodCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsMethodsDestroy', 'id', id)
            const localVarPath = `/api/v1/payments/methods/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsList: async (ordering?: string, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/methods/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedPaymentMethodUpdate} [patchedPaymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsPartialUpdate: async (id: number, patchedPaymentMethodUpdate?: PatchedPaymentMethodUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsMethodsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/payments/methods/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPaymentMethodUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsMethodsRetrieve', 'id', id)
            const localVarPath = `/api/v1/payments/methods/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PaymentMethodUpdate} [paymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsUpdate: async (id: number, paymentMethodUpdate?: PaymentMethodUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsMethodsUpdate', 'id', id)
            const localVarPath = `/api/v1/payments/methods/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentMethodUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {number} id 
         * @param {PatchedPaymentCreate} [patchedPaymentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsPartialUpdate: async (id: number, patchedPaymentCreate?: PatchedPaymentCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/payments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPaymentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsRetrieve', 'id', id)
            const localVarPath = `/api/v1/payments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {number} id 
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsUpdate: async (id: number, paymentCreate: PaymentCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentsUpdate', 'id', id)
            // verify required parameter 'paymentCreate' is not null or undefined
            assertParamExists('v1PaymentsUpdate', 'paymentCreate', paymentCreate)
            const localVarPath = `/api/v1/payments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List webhook events - function-based version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksEventsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/webhooks/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retry processing a webhook event - function-based version.
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksEventsRetryCreate: async (eventId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('v1PaymentsWebhooksEventsRetryCreate', 'eventId', eventId)
            const localVarPath = `/api/v1/payments/webhooks/events/{event_id}/retry/`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple Stripe webhook handler - function-based version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksStripeDrfCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/webhooks/stripe/drf/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload profile image
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileCreate: async (userUpdate: UserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('v1ProfileCreate', 'userUpdate', userUpdate)
            const localVarPath = `/api/v1/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset profile image to default by removing uploaded photo.  This clears the stored ImageField `photo`. The `photo_url` (e.g., Firebase avatar) remains unchanged. Frontend should use `photo_url` as fallback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileDestroy: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User profile view with image upload
         * @param {PatchedUserUpdate} [patchedUserUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfilePartialUpdate: async (patchedUserUpdate?: PatchedUserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User profile view with image upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User profile view with image upload
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileUpdate: async (userUpdate: UserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('v1ProfileUpdate', 'userUpdate', userUpdate)
            const localVarPath = `/api/v1/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get review analytics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsAnalyticsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/reviews/analytics/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List and create reviews.
         * @param {ReviewCreate} reviewCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsCreate: async (reviewCreate: ReviewCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewCreate' is not null or undefined
            assertParamExists('v1ReviewsCreate', 'reviewCreate', reviewCreate)
            const localVarPath = `/api/v1/reviews/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ReviewsDestroy', 'id', id)
            const localVarPath = `/api/v1/reviews/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List and create reviews.
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsList: async (isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/reviews/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isVerified !== undefined) {
                localVarQueryParameter['is_verified'] = isVerified;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (overallRating !== undefined) {
                localVarQueryParameter['overall_rating'] = overallRating;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get reviews for a specific order.
         * @param {number} orderId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsOrderList: async (orderId: number, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('v1ReviewsOrderList', 'orderId', orderId)
            const localVarPath = `/api/v1/reviews/order/{order_id}/`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {PatchedReviewUpdate} [patchedReviewUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsPartialUpdate: async (id: number, patchedReviewUpdate?: PatchedReviewUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ReviewsPartialUpdate', 'id', id)
            const localVarPath = `/api/v1/reviews/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedReviewUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get reviews for a specific service provider.
         * @param {number} providerId 
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsProviderList: async (providerId: number, isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('v1ReviewsProviderList', 'providerId', providerId)
            const localVarPath = `/api/v1/reviews/provider/{provider_id}/`
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isVerified !== undefined) {
                localVarQueryParameter['is_verified'] = isVerified;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (overallRating !== undefined) {
                localVarQueryParameter['overall_rating'] = overallRating;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ReviewsRetrieve', 'id', id)
            const localVarPath = `/api/v1/reviews/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {ReviewUpdate} reviewUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsUpdate: async (id: number, reviewUpdate: ReviewUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ReviewsUpdate', 'id', id)
            // verify required parameter 'reviewUpdate' is not null or undefined
            assertParamExists('v1ReviewsUpdate', 'reviewUpdate', reviewUpdate)
            const localVarPath = `/api/v1/reviews/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple global search across all content types.
         * @param {string} [city] Filter by city
         * @param {number} [maxBudget] Maximum budget
         * @param {number} [minBudget] Minimum budget
         * @param {number} [minRating] Minimum rating for providers
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {number} [serviceCategory] Filter by service category ID
         * @param {'all' | 'orders' | 'providers' | 'services'} [type] Type of search to perform  * &#x60;all&#x60; - All * &#x60;orders&#x60; - Orders * &#x60;providers&#x60; - Providers * &#x60;services&#x60; - Services
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchGlobalList: async (city?: string, maxBudget?: number, minBudget?: number, minRating?: number, ordering?: string, page?: number, pageSize?: number, q?: string, serviceCategory?: number, type?: 'all' | 'orders' | 'providers' | 'services', urgency?: 'high' | 'low' | 'medium' | 'urgent', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/global/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (maxBudget !== undefined) {
                localVarQueryParameter['max_budget'] = maxBudget;
            }

            if (minBudget !== undefined) {
                localVarQueryParameter['min_budget'] = minBudget;
            }

            if (minRating !== undefined) {
                localVarQueryParameter['min_rating'] = minRating;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (serviceCategory !== undefined) {
                localVarQueryParameter['service_category'] = serviceCategory;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (urgency !== undefined) {
                localVarQueryParameter['urgency'] = urgency;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search specifically for orders (job vacancies).
         * @param {string} [city] Filter by city
         * @param {number} [maxBudget] Maximum budget
         * @param {number} [minBudget] Minimum budget
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {number} [serviceCategory] Filter by service category ID
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchOrdersList: async (city?: string, maxBudget?: number, minBudget?: number, ordering?: string, page?: number, pageSize?: number, q?: string, serviceCategory?: number, urgency?: 'high' | 'low' | 'medium' | 'urgent', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/orders/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (maxBudget !== undefined) {
                localVarQueryParameter['max_budget'] = maxBudget;
            }

            if (minBudget !== undefined) {
                localVarQueryParameter['min_budget'] = minBudget;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (serviceCategory !== undefined) {
                localVarQueryParameter['service_category'] = serviceCategory;
            }

            if (urgency !== undefined) {
                localVarQueryParameter['urgency'] = urgency;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search specifically for service providers.
         * @param {string} [city] Filter by city
         * @param {number} [minRating] Minimum rating
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchProvidersList: async (city?: string, minRating?: number, ordering?: string, page?: number, pageSize?: number, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/search/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (minRating !== undefined) {
                localVarQueryParameter['min_rating'] = minRating;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedClientUpdate} [patchedClientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersClientPartialUpdate: async (patchedClientUpdate?: PatchedClientUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedClientUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersClientRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClientUpdate} [clientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersClientUpdate: async (clientUpdate?: ClientUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/client/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update client profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersClientUpdateCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/client/update/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersClientsList: async (createdAt?: string, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/clients/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = (createdAt as any instanceof Date) ?
                    (createdAt as any).toISOString() :
                    createdAt;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all users - not in api_users, useful for admin
         * @param {boolean} [blocked] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {'free' | 'paid' | 'premium_paid'} [userType] * &#x60;free&#x60; - Бесплатный * &#x60;paid&#x60; - Оплаченный * &#x60;premium_paid&#x60; - Премиум оплаченный
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersList: async (blocked?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, userType?: 'free' | 'paid' | 'premium_paid', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (blocked !== undefined) {
                localVarQueryParameter['blocked'] = blocked;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (userType !== undefined) {
                localVarQueryParameter['user_type'] = userType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedUserProfileUpdate} [patchedUserProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfilePartialUpdate: async (patchedUserProfileUpdate?: PatchedUserProfileUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserProfileUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfileRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserProfileUpdate} [userProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfileUpdate: async (userProfileUpdate?: UserProfileUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfileUpdateCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/profile/update/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'female' | 'male' | 'other' | 'prefer_not_to_say'} [gender] * &#x60;male&#x60; - Male * &#x60;female&#x60; - Female * &#x60;other&#x60; - Other * &#x60;prefer_not_to_say&#x60; - Prefer not to say
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {'both' | 'client' | 'service_provider'} [userType] * &#x60;client&#x60; - Client * &#x60;service_provider&#x60; - Service Provider * &#x60;both&#x60; - Both
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfilesList: async (gender?: 'female' | 'male' | 'other' | 'prefer_not_to_say', isVerified?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, userType?: 'both' | 'client' | 'service_provider', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }

            if (isVerified !== undefined) {
                localVarQueryParameter['is_verified'] = isVerified;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (userType !== undefined) {
                localVarQueryParameter['user_type'] = userType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProviderPartialUpdate: async (patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/provider/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedServiceProviderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProviderRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/provider/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProviderUpdate: async (serviceProviderUpdate?: ServiceProviderUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/provider/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceProviderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update service provider profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProviderUpdateCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/provider/update/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isAvailable] 
         * @param {boolean} [isVerifiedProvider] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProvidersList: async (isAvailable?: boolean, isVerifiedProvider?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isAvailable !== undefined) {
                localVarQueryParameter['is_available'] = isAvailable;
            }

            if (isVerifiedProvider !== undefined) {
                localVarQueryParameter['is_verified_provider'] = isVerifiedProvider;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1Api - functional programming interface
 * @export
 */
export const V1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserActivityCreate} userActivityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyticsActivitiesCreateCreate(userActivityCreate: UserActivityCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserActivityCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyticsActivitiesCreateCreate(userActivityCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'bid_submitted' | 'chat_message' | 'login' | 'logout' | 'order_created' | 'order_viewed' | 'payment_made' | 'profile_updated' | 'search_performed' | 'service_viewed'} [activityType] * &#x60;login&#x60; - Login * &#x60;logout&#x60; - Logout * &#x60;order_created&#x60; - Order Created * &#x60;order_viewed&#x60; - Order Viewed * &#x60;bid_submitted&#x60; - Bid Submitted * &#x60;chat_message&#x60; - Chat Message * &#x60;payment_made&#x60; - Payment Made * &#x60;profile_updated&#x60; - Profile Updated * &#x60;search_performed&#x60; - Search Performed * &#x60;service_viewed&#x60; - Service Viewed
         * @param {string} [ipAddress] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyticsActivitiesList(activityType?: 'bid_submitted' | 'chat_message' | 'login' | 'logout' | 'order_created' | 'order_viewed' | 'payment_made' | 'profile_updated' | 'search_performed' | 'service_viewed', ipAddress?: string, ordering?: string, page?: number, pageSize?: number, search?: string, user?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserActivityList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyticsActivitiesList(activityType, ipAddress, ordering, page, pageSize, search, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BusinessMetricsCreate} businessMetricsCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyticsBusinessCreateCreate(businessMetricsCreate: BusinessMetricsCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessMetricsCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyticsBusinessCreateCreate(businessMetricsCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyticsBusinessList(date?: string, ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBusinessMetricsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyticsBusinessList(date, ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ServiceCategoryAnalyticsCreate} serviceCategoryAnalyticsCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyticsCategoriesCreateCreate(serviceCategoryAnalyticsCreate: ServiceCategoryAnalyticsCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceCategoryAnalyticsCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyticsCategoriesCreateCreate(serviceCategoryAnalyticsCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [category] 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyticsCategoriesList(category?: number, date?: string, ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedServiceCategoryAnalyticsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyticsCategoriesList(category, date, ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get dashboard overview data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyticsDashboardRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyticsDashboardRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrderAnalyticsCreate} orderAnalyticsCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyticsOrdersCreateCreate(orderAnalyticsCreate: OrderAnalyticsCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderAnalyticsCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyticsOrdersCreateCreate(orderAnalyticsCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyticsOrdersList(date?: string, ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderAnalyticsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyticsOrdersList(date, ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'daily' | 'hourly' | 'monthly' | 'weekly'} [timePeriod] * &#x60;hourly&#x60; - Hourly * &#x60;daily&#x60; - Daily * &#x60;weekly&#x60; - Weekly * &#x60;monthly&#x60; - Monthly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AnalyticsPerformanceList(date?: string, ordering?: string, page?: number, pageSize?: number, timePeriod?: 'daily' | 'hourly' | 'monthly' | 'weekly', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPerformanceMetricsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AnalyticsPerformanceList(date, ordering, page, pageSize, timePeriod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate user with Firebase ID token or register new user if verified.
         * @param {FireBaseAuth} fireBaseAuth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthFirebaseCreate(fireBaseAuth: FireBaseAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireBaseAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthFirebaseCreate(fireBaseAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User logout view - enhanced version of api_users LogOutView
         * @param {LogoutResponse} logoutResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1AuthLogoutCreate(logoutResponse: LogoutResponse, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthLogoutCreate(logoutResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ChatAttachmentCreate} chatAttachmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatAttachmentsCreateCreate(chatAttachmentCreate: ChatAttachmentCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatAttachmentCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatAttachmentsCreateCreate(chatAttachmentCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatAttachmentsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatAttachmentsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatAttachmentsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChatAttachmentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatAttachmentsList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatAttachmentsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatAttachmentsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {MessageCreate} messageCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatMessagesCreateCreate(messageCreate: MessageCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatMessagesCreateCreate(messageCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatMessagesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatMessagesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatMessagesList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMessageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatMessagesList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedMessageUpdate} [patchedMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatMessagesPartialUpdate(id: number, patchedMessageUpdate?: PatchedMessageUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatMessagesPartialUpdate(id, patchedMessageUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatMessagesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatMessagesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {MessageUpdate} messageUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatMessagesUpdate(id: number, messageUpdate: MessageUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatMessagesUpdate(id, messageUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ChatParticipantCreate} chatParticipantCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatParticipantsCreateCreate(chatParticipantCreate: ChatParticipantCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatParticipantCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatParticipantsCreateCreate(chatParticipantCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatParticipantsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChatParticipantList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatParticipantsList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ChatRoomCreate} [chatRoomCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatRoomsCreateCreate(chatRoomCreate?: ChatRoomCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoomCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatRoomsCreateCreate(chatRoomCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatRoomsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedChatRoomList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatRoomsList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedChatRoomUpdate} [patchedChatRoomUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatRoomsPartialUpdate(id: number, patchedChatRoomUpdate?: PatchedChatRoomUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoomUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatRoomsPartialUpdate(id, patchedChatRoomUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatRoomsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatRoomsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {ChatRoomUpdate} [chatRoomUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatRoomsUpdate(id: number, chatRoomUpdate?: ChatRoomUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoomUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatRoomsUpdate(id, chatRoomUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get WebSocket connection information for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChatWebsocketInfoRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebSocketInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChatWebsocketInfoRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'all' | 'android' | 'ios' | 'web'} [platform] * &#x60;android&#x60; - Android * &#x60;ios&#x60; - iOS * &#x60;web&#x60; - Web * &#x60;all&#x60; - All Platforms
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreAppVersionsList(isActive?: boolean, ordering?: string, page?: number, pageSize?: number, platform?: 'all' | 'android' | 'ios' | 'web', search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAppVersionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreAppVersionsList(isActive, ordering, page, pageSize, platform, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [isActive] 
         * @param {boolean} [isDefault] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreLanguagesList(isActive?: boolean, isDefault?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLanguageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreLanguagesList(isActive, isDefault, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [country] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceAreasList(country?: string, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, state?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedServiceAreaList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceAreasList(country, isActive, ordering, page, pageSize, search, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceCategoriesList(featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedServiceCategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceCategoriesList(featured, isActive, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [category] 
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreServiceSubcategoriesList(category?: number, featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedServiceSubcategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreServiceSubcategoriesList(category, featured, isActive, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [category] 
         * @param {boolean} [isPublic] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CoreSystemSettingsList(category?: string, isPublic?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSystemSettingsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CoreSystemSettingsList(category, isPublic, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {NotificationCreate} notificationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsCreateCreate(notificationCreate: NotificationCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsCreateCreate(notificationCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNotificationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedNotificationUpdate} [patchedNotificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsPartialUpdate(id: number, patchedNotificationUpdate?: PatchedNotificationUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsPartialUpdate(id, patchedNotificationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PatchedNotificationSettingUpdate} [patchedNotificationSettingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsSettingsPartialUpdate(patchedNotificationSettingUpdate?: PatchedNotificationSettingUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSettingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsSettingsPartialUpdate(patchedNotificationSettingUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsSettingsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsSettingsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {NotificationSettingUpdate} [notificationSettingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsSettingsUpdate(notificationSettingUpdate?: NotificationSettingUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSettingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsSettingsUpdate(notificationSettingUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {NotificationTemplateCreate} notificationTemplateCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsTemplatesCreateCreate(notificationTemplateCreate: NotificationTemplateCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationTemplateCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsTemplatesCreateCreate(notificationTemplateCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [isActive] 
         * @param {'bid_received' | 'chat_message' | 'order_update' | 'payment_failed' | 'payment_success' | 'promotional' | 'system_alert'} [notificationType] * &#x60;order_update&#x60; - Order Update * &#x60;bid_received&#x60; - Bid Received * &#x60;payment_success&#x60; - Payment Success * &#x60;payment_failed&#x60; - Payment Failed * &#x60;chat_message&#x60; - Chat Message * &#x60;system_alert&#x60; - System Alert * &#x60;promotional&#x60; - Promotional
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsTemplatesList(isActive?: boolean, notificationType?: 'bid_received' | 'chat_message' | 'order_update' | 'payment_failed' | 'payment_success' | 'promotional' | 'system_alert', ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNotificationTemplateList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsTemplatesList(isActive, notificationType, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedNotificationTemplateUpdate} [patchedNotificationTemplateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsTemplatesPartialUpdate(id: number, patchedNotificationTemplateUpdate?: PatchedNotificationTemplateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationTemplateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsTemplatesPartialUpdate(id, patchedNotificationTemplateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsTemplatesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsTemplatesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {NotificationTemplateUpdate} notificationTemplateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsTemplatesUpdate(id: number, notificationTemplateUpdate: NotificationTemplateUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationTemplateUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsTemplatesUpdate(id, notificationTemplateUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {NotificationUpdate} [notificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1NotificationsUpdate(id: number, notificationUpdate?: NotificationUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1NotificationsUpdate(id, notificationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersAddonsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderAddonList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersAddonsList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} orderId 
         * @param {BidCreate} bidCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsCreate(orderId: number, bidCreate: BidCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsCreate(orderId, bidCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersBidsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBidList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersBidsList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersCreateCreate(orderCreate: OrderCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersCreateCreate(orderCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} orderId 
         * @param {OrderDisputeCreate} orderDisputeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersDisputesCreate(orderId: number, orderDisputeCreate: OrderDisputeCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDisputeCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersDisputesCreate(orderId, orderDisputeCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersDisputesList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderDisputeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersDisputesList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedOrderDisputeUpdate} [patchedOrderDisputeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersDisputesPartialUpdate(id: number, patchedOrderDisputeUpdate?: PatchedOrderDisputeUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDisputeUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersDisputesPartialUpdate(id, patchedOrderDisputeUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersDisputesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDispute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersDisputesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {OrderDisputeUpdate} [orderDisputeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersDisputesUpdate(id: number, orderDisputeUpdate?: OrderDisputeUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDisputeUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersDisputesUpdate(id, orderDisputeUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedOrderUpdate} [patchedOrderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersPartialUpdate(id: number, patchedOrderUpdate?: PatchedOrderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersPartialUpdate(id, patchedOrderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersPhotosList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderPhotoList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersPhotosList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {OrderUpdate} orderUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrdersUpdate(id: number, orderUpdate: OrderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrdersUpdate(id, orderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsCreateCreate(paymentCreate: PaymentCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsCreateCreate(paymentCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {InvoiceCreate} invoiceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsInvoicesCreateCreate(invoiceCreate: InvoiceCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsInvoicesCreateCreate(invoiceCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsInvoicesList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInvoiceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsInvoicesList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsInvoicesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsInvoicesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPaymentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsList(ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PaymentMethodCreate} paymentMethodCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsCreateCreate(paymentMethodCreate: PaymentMethodCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsCreateCreate(paymentMethodCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsList(ordering?: string, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPaymentMethodList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsList(ordering, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedPaymentMethodUpdate} [patchedPaymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsPartialUpdate(id: number, patchedPaymentMethodUpdate?: PatchedPaymentMethodUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsPartialUpdate(id, patchedPaymentMethodUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {PaymentMethodUpdate} [paymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsMethodsUpdate(id: number, paymentMethodUpdate?: PaymentMethodUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsMethodsUpdate(id, paymentMethodUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {number} id 
         * @param {PatchedPaymentCreate} [patchedPaymentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsPartialUpdate(id: number, patchedPaymentCreate?: PatchedPaymentCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsPartialUpdate(id, patchedPaymentCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {number} id 
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsUpdate(id: number, paymentCreate: PaymentCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsUpdate(id, paymentCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List webhook events - function-based version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsWebhooksEventsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsWebhooksEventsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retry processing a webhook event - function-based version.
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsWebhooksEventsRetryCreate(eventId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsWebhooksEventsRetryCreate(eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Simple Stripe webhook handler - function-based version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentsWebhooksStripeDrfCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentsWebhooksStripeDrfCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload profile image
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileCreate(userUpdate: UserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileCreate(userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset profile image to default by removing uploaded photo.  This clears the stored ImageField `photo`. The `photo_url` (e.g., Firebase avatar) remains unchanged. Frontend should use `photo_url` as fallback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileDestroy(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileDestroy(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User profile view with image upload
         * @param {PatchedUserUpdate} [patchedUserUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfilePartialUpdate(patchedUserUpdate?: PatchedUserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfilePartialUpdate(patchedUserUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User profile view with image upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User profile view with image upload
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProfileUpdate(userUpdate: UserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProfileUpdate(userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get review analytics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsAnalyticsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewAnalytics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsAnalyticsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List and create reviews.
         * @param {ReviewCreate} reviewCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsCreate(reviewCreate: ReviewCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsCreate(reviewCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List and create reviews.
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsList(isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReviewList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsList(isVerified, ordering, overallRating, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get reviews for a specific order.
         * @param {number} orderId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsOrderList(orderId: number, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReviewList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsOrderList(orderId, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {PatchedReviewUpdate} [patchedReviewUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsPartialUpdate(id: number, patchedReviewUpdate?: PatchedReviewUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsPartialUpdate(id, patchedReviewUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get reviews for a specific service provider.
         * @param {number} providerId 
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsProviderList(providerId: number, isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedReviewList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsProviderList(providerId, isVerified, ordering, overallRating, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Review>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {ReviewUpdate} reviewUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ReviewsUpdate(id: number, reviewUpdate: ReviewUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ReviewsUpdate(id, reviewUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Simple global search across all content types.
         * @param {string} [city] Filter by city
         * @param {number} [maxBudget] Maximum budget
         * @param {number} [minBudget] Minimum budget
         * @param {number} [minRating] Minimum rating for providers
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {number} [serviceCategory] Filter by service category ID
         * @param {'all' | 'orders' | 'providers' | 'services'} [type] Type of search to perform  * &#x60;all&#x60; - All * &#x60;orders&#x60; - Orders * &#x60;providers&#x60; - Providers * &#x60;services&#x60; - Services
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SearchGlobalList(city?: string, maxBudget?: number, minBudget?: number, minRating?: number, ordering?: string, page?: number, pageSize?: number, q?: string, serviceCategory?: number, type?: 'all' | 'orders' | 'providers' | 'services', urgency?: 'high' | 'low' | 'medium' | 'urgent', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGlobalSearchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SearchGlobalList(city, maxBudget, minBudget, minRating, ordering, page, pageSize, q, serviceCategory, type, urgency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search specifically for orders (job vacancies).
         * @param {string} [city] Filter by city
         * @param {number} [maxBudget] Maximum budget
         * @param {number} [minBudget] Minimum budget
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {number} [serviceCategory] Filter by service category ID
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SearchOrdersList(city?: string, maxBudget?: number, minBudget?: number, ordering?: string, page?: number, pageSize?: number, q?: string, serviceCategory?: number, urgency?: 'high' | 'low' | 'medium' | 'urgent', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOrderSearchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SearchOrdersList(city, maxBudget, minBudget, ordering, page, pageSize, q, serviceCategory, urgency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search specifically for service providers.
         * @param {string} [city] Filter by city
         * @param {number} [minRating] Minimum rating
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SearchProvidersList(city?: string, minRating?: number, ordering?: string, page?: number, pageSize?: number, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProviderSearchResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SearchProvidersList(city, minRating, ordering, page, pageSize, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PatchedClientUpdate} [patchedClientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersClientPartialUpdate(patchedClientUpdate?: PatchedClientUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersClientPartialUpdate(patchedClientUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersClientRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersClientRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClientUpdate} [clientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersClientUpdate(clientUpdate?: ClientUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersClientUpdate(clientUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update client profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersClientUpdateCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersClientUpdateCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersClientsList(createdAt?: string, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedClientList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersClientsList(createdAt, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all users - not in api_users, useful for admin
         * @param {boolean} [blocked] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {'free' | 'paid' | 'premium_paid'} [userType] * &#x60;free&#x60; - Бесплатный * &#x60;paid&#x60; - Оплаченный * &#x60;premium_paid&#x60; - Премиум оплаченный
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersList(blocked?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, userType?: 'free' | 'paid' | 'premium_paid', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersList(blocked, isActive, ordering, page, pageSize, search, userType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PatchedUserProfileUpdate} [patchedUserProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProfilePartialUpdate(patchedUserProfileUpdate?: PatchedUserProfileUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProfilePartialUpdate(patchedUserProfileUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProfileRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProfileRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserProfileUpdate} [userProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProfileUpdate(userProfileUpdate?: UserProfileUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProfileUpdate(userProfileUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProfileUpdateCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProfileUpdateCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'female' | 'male' | 'other' | 'prefer_not_to_say'} [gender] * &#x60;male&#x60; - Male * &#x60;female&#x60; - Female * &#x60;other&#x60; - Other * &#x60;prefer_not_to_say&#x60; - Prefer not to say
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {'both' | 'client' | 'service_provider'} [userType] * &#x60;client&#x60; - Client * &#x60;service_provider&#x60; - Service Provider * &#x60;both&#x60; - Both
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProfilesList(gender?: 'female' | 'male' | 'other' | 'prefer_not_to_say', isVerified?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, userType?: 'both' | 'client' | 'service_provider', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserProfileDetailList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProfilesList(gender, isVerified, ordering, page, pageSize, search, userType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProviderPartialUpdate(patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProviderPartialUpdate(patchedServiceProviderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProviderRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProviderRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProviderUpdate(serviceProviderUpdate?: ServiceProviderUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProviderUpdate(serviceProviderUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create or update service provider profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProviderUpdateCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProviderUpdateCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [isAvailable] 
         * @param {boolean} [isVerifiedProvider] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsersProvidersList(isAvailable?: boolean, isVerifiedProvider?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedServiceProviderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersProvidersList(isAvailable, isVerifiedProvider, ordering, page, pageSize, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1Api - factory interface
 * @export
 */
export const V1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1ApiFp(configuration)
    return {
        /**
         * 
         * @param {UserActivityCreate} userActivityCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsActivitiesCreateCreate(userActivityCreate: UserActivityCreate, options?: any): AxiosPromise<UserActivityCreate> {
            return localVarFp.v1AnalyticsActivitiesCreateCreate(userActivityCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'bid_submitted' | 'chat_message' | 'login' | 'logout' | 'order_created' | 'order_viewed' | 'payment_made' | 'profile_updated' | 'search_performed' | 'service_viewed'} [activityType] * &#x60;login&#x60; - Login * &#x60;logout&#x60; - Logout * &#x60;order_created&#x60; - Order Created * &#x60;order_viewed&#x60; - Order Viewed * &#x60;bid_submitted&#x60; - Bid Submitted * &#x60;chat_message&#x60; - Chat Message * &#x60;payment_made&#x60; - Payment Made * &#x60;profile_updated&#x60; - Profile Updated * &#x60;search_performed&#x60; - Search Performed * &#x60;service_viewed&#x60; - Service Viewed
         * @param {string} [ipAddress] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsActivitiesList(activityType?: 'bid_submitted' | 'chat_message' | 'login' | 'logout' | 'order_created' | 'order_viewed' | 'payment_made' | 'profile_updated' | 'search_performed' | 'service_viewed', ipAddress?: string, ordering?: string, page?: number, pageSize?: number, search?: string, user?: number, options?: any): AxiosPromise<PaginatedUserActivityList> {
            return localVarFp.v1AnalyticsActivitiesList(activityType, ipAddress, ordering, page, pageSize, search, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BusinessMetricsCreate} businessMetricsCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsBusinessCreateCreate(businessMetricsCreate: BusinessMetricsCreate, options?: any): AxiosPromise<BusinessMetricsCreate> {
            return localVarFp.v1AnalyticsBusinessCreateCreate(businessMetricsCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsBusinessList(date?: string, ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedBusinessMetricsList> {
            return localVarFp.v1AnalyticsBusinessList(date, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServiceCategoryAnalyticsCreate} serviceCategoryAnalyticsCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsCategoriesCreateCreate(serviceCategoryAnalyticsCreate: ServiceCategoryAnalyticsCreate, options?: any): AxiosPromise<ServiceCategoryAnalyticsCreate> {
            return localVarFp.v1AnalyticsCategoriesCreateCreate(serviceCategoryAnalyticsCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [category] 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsCategoriesList(category?: number, date?: string, ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedServiceCategoryAnalyticsList> {
            return localVarFp.v1AnalyticsCategoriesList(category, date, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dashboard overview data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsDashboardRetrieve(options?: any): AxiosPromise<DashboardResponse> {
            return localVarFp.v1AnalyticsDashboardRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrderAnalyticsCreate} orderAnalyticsCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsOrdersCreateCreate(orderAnalyticsCreate: OrderAnalyticsCreate, options?: any): AxiosPromise<OrderAnalyticsCreate> {
            return localVarFp.v1AnalyticsOrdersCreateCreate(orderAnalyticsCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsOrdersList(date?: string, ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedOrderAnalyticsList> {
            return localVarFp.v1AnalyticsOrdersList(date, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [date] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'daily' | 'hourly' | 'monthly' | 'weekly'} [timePeriod] * &#x60;hourly&#x60; - Hourly * &#x60;daily&#x60; - Daily * &#x60;weekly&#x60; - Weekly * &#x60;monthly&#x60; - Monthly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AnalyticsPerformanceList(date?: string, ordering?: string, page?: number, pageSize?: number, timePeriod?: 'daily' | 'hourly' | 'monthly' | 'weekly', options?: any): AxiosPromise<PaginatedPerformanceMetricsList> {
            return localVarFp.v1AnalyticsPerformanceList(date, ordering, page, pageSize, timePeriod, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate user with Firebase ID token or register new user if verified.
         * @param {FireBaseAuth} fireBaseAuth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthFirebaseCreate(fireBaseAuth: FireBaseAuth, options?: any): AxiosPromise<FireBaseAuth> {
            return localVarFp.v1AuthFirebaseCreate(fireBaseAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * User logout view - enhanced version of api_users LogOutView
         * @param {LogoutResponse} logoutResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthLogoutCreate(logoutResponse: LogoutResponse, options?: any): AxiosPromise<LogoutResponse> {
            return localVarFp.v1AuthLogoutCreate(logoutResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ChatAttachmentCreate} chatAttachmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatAttachmentsCreateCreate(chatAttachmentCreate: ChatAttachmentCreate, options?: any): AxiosPromise<ChatAttachmentCreate> {
            return localVarFp.v1ChatAttachmentsCreateCreate(chatAttachmentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatAttachmentsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1ChatAttachmentsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatAttachmentsList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedChatAttachmentList> {
            return localVarFp.v1ChatAttachmentsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatAttachmentsRetrieve(id: number, options?: any): AxiosPromise<ChatAttachment> {
            return localVarFp.v1ChatAttachmentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {MessageCreate} messageCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesCreateCreate(messageCreate: MessageCreate, options?: any): AxiosPromise<MessageCreate> {
            return localVarFp.v1ChatMessagesCreateCreate(messageCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1ChatMessagesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedMessageList> {
            return localVarFp.v1ChatMessagesList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedMessageUpdate} [patchedMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesPartialUpdate(id: number, patchedMessageUpdate?: PatchedMessageUpdate, options?: any): AxiosPromise<MessageUpdate> {
            return localVarFp.v1ChatMessagesPartialUpdate(id, patchedMessageUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesRetrieve(id: number, options?: any): AxiosPromise<Message> {
            return localVarFp.v1ChatMessagesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {MessageUpdate} messageUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatMessagesUpdate(id: number, messageUpdate: MessageUpdate, options?: any): AxiosPromise<MessageUpdate> {
            return localVarFp.v1ChatMessagesUpdate(id, messageUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ChatParticipantCreate} chatParticipantCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatParticipantsCreateCreate(chatParticipantCreate: ChatParticipantCreate, options?: any): AxiosPromise<ChatParticipantCreate> {
            return localVarFp.v1ChatParticipantsCreateCreate(chatParticipantCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatParticipantsList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedChatParticipantList> {
            return localVarFp.v1ChatParticipantsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {ChatRoomCreate} [chatRoomCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatRoomsCreateCreate(chatRoomCreate?: ChatRoomCreate, options?: any): AxiosPromise<ChatRoomCreate> {
            return localVarFp.v1ChatRoomsCreateCreate(chatRoomCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatRoomsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedChatRoomList> {
            return localVarFp.v1ChatRoomsList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedChatRoomUpdate} [patchedChatRoomUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatRoomsPartialUpdate(id: number, patchedChatRoomUpdate?: PatchedChatRoomUpdate, options?: any): AxiosPromise<ChatRoomUpdate> {
            return localVarFp.v1ChatRoomsPartialUpdate(id, patchedChatRoomUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatRoomsRetrieve(id: number, options?: any): AxiosPromise<ChatRoom> {
            return localVarFp.v1ChatRoomsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {ChatRoomUpdate} [chatRoomUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatRoomsUpdate(id: number, chatRoomUpdate?: ChatRoomUpdate, options?: any): AxiosPromise<ChatRoomUpdate> {
            return localVarFp.v1ChatRoomsUpdate(id, chatRoomUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get WebSocket connection information for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChatWebsocketInfoRetrieve(options?: any): AxiosPromise<WebSocketInfo> {
            return localVarFp.v1ChatWebsocketInfoRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'all' | 'android' | 'ios' | 'web'} [platform] * &#x60;android&#x60; - Android * &#x60;ios&#x60; - iOS * &#x60;web&#x60; - Web * &#x60;all&#x60; - All Platforms
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreAppVersionsList(isActive?: boolean, ordering?: string, page?: number, pageSize?: number, platform?: 'all' | 'android' | 'ios' | 'web', search?: string, options?: any): AxiosPromise<PaginatedAppVersionList> {
            return localVarFp.v1CoreAppVersionsList(isActive, ordering, page, pageSize, platform, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isActive] 
         * @param {boolean} [isDefault] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreLanguagesList(isActive?: boolean, isDefault?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedLanguageList> {
            return localVarFp.v1CoreLanguagesList(isActive, isDefault, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [country] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceAreasList(country?: string, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, state?: string, options?: any): AxiosPromise<PaginatedServiceAreaList> {
            return localVarFp.v1CoreServiceAreasList(country, isActive, ordering, page, pageSize, search, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceCategoriesList(featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedServiceCategoryList> {
            return localVarFp.v1CoreServiceCategoriesList(featured, isActive, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [category] 
         * @param {boolean} [featured] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreServiceSubcategoriesList(category?: number, featured?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedServiceSubcategoryList> {
            return localVarFp.v1CoreServiceSubcategoriesList(category, featured, isActive, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [category] 
         * @param {boolean} [isPublic] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CoreSystemSettingsList(category?: string, isPublic?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedSystemSettingsList> {
            return localVarFp.v1CoreSystemSettingsList(category, isPublic, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NotificationCreate} notificationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsCreateCreate(notificationCreate: NotificationCreate, options?: any): AxiosPromise<NotificationCreate> {
            return localVarFp.v1NotificationsCreateCreate(notificationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedNotificationList> {
            return localVarFp.v1NotificationsList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedNotificationUpdate} [patchedNotificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsPartialUpdate(id: number, patchedNotificationUpdate?: PatchedNotificationUpdate, options?: any): AxiosPromise<NotificationUpdate> {
            return localVarFp.v1NotificationsPartialUpdate(id, patchedNotificationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsRetrieve(id: number, options?: any): AxiosPromise<Notification> {
            return localVarFp.v1NotificationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatchedNotificationSettingUpdate} [patchedNotificationSettingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsSettingsPartialUpdate(patchedNotificationSettingUpdate?: PatchedNotificationSettingUpdate, options?: any): AxiosPromise<NotificationSettingUpdate> {
            return localVarFp.v1NotificationsSettingsPartialUpdate(patchedNotificationSettingUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsSettingsRetrieve(options?: any): AxiosPromise<NotificationSetting> {
            return localVarFp.v1NotificationsSettingsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NotificationSettingUpdate} [notificationSettingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsSettingsUpdate(notificationSettingUpdate?: NotificationSettingUpdate, options?: any): AxiosPromise<NotificationSettingUpdate> {
            return localVarFp.v1NotificationsSettingsUpdate(notificationSettingUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NotificationTemplateCreate} notificationTemplateCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsTemplatesCreateCreate(notificationTemplateCreate: NotificationTemplateCreate, options?: any): AxiosPromise<NotificationTemplateCreate> {
            return localVarFp.v1NotificationsTemplatesCreateCreate(notificationTemplateCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isActive] 
         * @param {'bid_received' | 'chat_message' | 'order_update' | 'payment_failed' | 'payment_success' | 'promotional' | 'system_alert'} [notificationType] * &#x60;order_update&#x60; - Order Update * &#x60;bid_received&#x60; - Bid Received * &#x60;payment_success&#x60; - Payment Success * &#x60;payment_failed&#x60; - Payment Failed * &#x60;chat_message&#x60; - Chat Message * &#x60;system_alert&#x60; - System Alert * &#x60;promotional&#x60; - Promotional
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsTemplatesList(isActive?: boolean, notificationType?: 'bid_received' | 'chat_message' | 'order_update' | 'payment_failed' | 'payment_success' | 'promotional' | 'system_alert', ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedNotificationTemplateList> {
            return localVarFp.v1NotificationsTemplatesList(isActive, notificationType, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedNotificationTemplateUpdate} [patchedNotificationTemplateUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsTemplatesPartialUpdate(id: number, patchedNotificationTemplateUpdate?: PatchedNotificationTemplateUpdate, options?: any): AxiosPromise<NotificationTemplateUpdate> {
            return localVarFp.v1NotificationsTemplatesPartialUpdate(id, patchedNotificationTemplateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsTemplatesRetrieve(id: number, options?: any): AxiosPromise<NotificationTemplate> {
            return localVarFp.v1NotificationsTemplatesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {NotificationTemplateUpdate} notificationTemplateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsTemplatesUpdate(id: number, notificationTemplateUpdate: NotificationTemplateUpdate, options?: any): AxiosPromise<NotificationTemplateUpdate> {
            return localVarFp.v1NotificationsTemplatesUpdate(id, notificationTemplateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {NotificationUpdate} [notificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1NotificationsUpdate(id: number, notificationUpdate?: NotificationUpdate, options?: any): AxiosPromise<NotificationUpdate> {
            return localVarFp.v1NotificationsUpdate(id, notificationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersAddonsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedOrderAddonList> {
            return localVarFp.v1OrdersAddonsList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} orderId 
         * @param {BidCreate} bidCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsCreate(orderId: number, bidCreate: BidCreate, options?: any): AxiosPromise<BidCreate> {
            return localVarFp.v1OrdersBidsCreate(orderId, bidCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersBidsList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedBidList> {
            return localVarFp.v1OrdersBidsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {OrderCreate} orderCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersCreateCreate(orderCreate: OrderCreate, options?: any): AxiosPromise<OrderCreate> {
            return localVarFp.v1OrdersCreateCreate(orderCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} orderId 
         * @param {OrderDisputeCreate} orderDisputeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersDisputesCreate(orderId: number, orderDisputeCreate: OrderDisputeCreate, options?: any): AxiosPromise<OrderDisputeCreate> {
            return localVarFp.v1OrdersDisputesCreate(orderId, orderDisputeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersDisputesList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedOrderDisputeList> {
            return localVarFp.v1OrdersDisputesList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedOrderDisputeUpdate} [patchedOrderDisputeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersDisputesPartialUpdate(id: number, patchedOrderDisputeUpdate?: PatchedOrderDisputeUpdate, options?: any): AxiosPromise<OrderDisputeUpdate> {
            return localVarFp.v1OrdersDisputesPartialUpdate(id, patchedOrderDisputeUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersDisputesRetrieve(id: number, options?: any): AxiosPromise<OrderDispute> {
            return localVarFp.v1OrdersDisputesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {OrderDisputeUpdate} [orderDisputeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersDisputesUpdate(id: number, orderDisputeUpdate?: OrderDisputeUpdate, options?: any): AxiosPromise<OrderDisputeUpdate> {
            return localVarFp.v1OrdersDisputesUpdate(id, orderDisputeUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedOrderList> {
            return localVarFp.v1OrdersList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {PatchedOrderUpdate} [patchedOrderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersPartialUpdate(id: number, patchedOrderUpdate?: PatchedOrderUpdate, options?: any): AxiosPromise<OrderUpdate> {
            return localVarFp.v1OrdersPartialUpdate(id, patchedOrderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersPhotosList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedOrderPhotoList> {
            return localVarFp.v1OrdersPhotosList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersRetrieve(id: number, options?: any): AxiosPromise<Order> {
            return localVarFp.v1OrdersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to provide standardized exception handling for DRF views.
         * @param {number} id 
         * @param {OrderUpdate} orderUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrdersUpdate(id: number, orderUpdate: OrderUpdate, options?: any): AxiosPromise<OrderUpdate> {
            return localVarFp.v1OrdersUpdate(id, orderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsCreateCreate(paymentCreate: PaymentCreate, options?: any): AxiosPromise<PaymentCreate> {
            return localVarFp.v1PaymentsCreateCreate(paymentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InvoiceCreate} invoiceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesCreateCreate(invoiceCreate: InvoiceCreate, options?: any): AxiosPromise<InvoiceCreate> {
            return localVarFp.v1PaymentsInvoicesCreateCreate(invoiceCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedInvoiceList> {
            return localVarFp.v1PaymentsInvoicesList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsInvoicesRetrieve(id: number, options?: any): AxiosPromise<Invoice> {
            return localVarFp.v1PaymentsInvoicesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsList(ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedPaymentList> {
            return localVarFp.v1PaymentsList(ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PaymentMethodCreate} paymentMethodCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsCreateCreate(paymentMethodCreate: PaymentMethodCreate, options?: any): AxiosPromise<PaymentMethodCreate> {
            return localVarFp.v1PaymentsMethodsCreateCreate(paymentMethodCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1PaymentsMethodsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsList(ordering?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPaymentMethodList> {
            return localVarFp.v1PaymentsMethodsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedPaymentMethodUpdate} [patchedPaymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsPartialUpdate(id: number, patchedPaymentMethodUpdate?: PatchedPaymentMethodUpdate, options?: any): AxiosPromise<PaymentMethodUpdate> {
            return localVarFp.v1PaymentsMethodsPartialUpdate(id, patchedPaymentMethodUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsRetrieve(id: number, options?: any): AxiosPromise<PaymentMethod> {
            return localVarFp.v1PaymentsMethodsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PaymentMethodUpdate} [paymentMethodUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsMethodsUpdate(id: number, paymentMethodUpdate?: PaymentMethodUpdate, options?: any): AxiosPromise<PaymentMethodUpdate> {
            return localVarFp.v1PaymentsMethodsUpdate(id, paymentMethodUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {number} id 
         * @param {PatchedPaymentCreate} [patchedPaymentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsPartialUpdate(id: number, patchedPaymentCreate?: PatchedPaymentCreate, options?: any): AxiosPromise<PaymentCreate> {
            return localVarFp.v1PaymentsPartialUpdate(id, patchedPaymentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsRetrieve(id: number, options?: any): AxiosPromise<Payment> {
            return localVarFp.v1PaymentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mixin to require specific group membership for class-based views.
         * @param {number} id 
         * @param {PaymentCreate} paymentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsUpdate(id: number, paymentCreate: PaymentCreate, options?: any): AxiosPromise<PaymentCreate> {
            return localVarFp.v1PaymentsUpdate(id, paymentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List webhook events - function-based version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksEventsRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.v1PaymentsWebhooksEventsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Retry processing a webhook event - function-based version.
         * @param {number} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksEventsRetryCreate(eventId: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1PaymentsWebhooksEventsRetryCreate(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple Stripe webhook handler - function-based version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentsWebhooksStripeDrfCreate(options?: any): AxiosPromise<void> {
            return localVarFp.v1PaymentsWebhooksStripeDrfCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Upload profile image
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileCreate(userUpdate: UserUpdate, options?: any): AxiosPromise<UserUpdate> {
            return localVarFp.v1ProfileCreate(userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset profile image to default by removing uploaded photo.  This clears the stored ImageField `photo`. The `photo_url` (e.g., Firebase avatar) remains unchanged. Frontend should use `photo_url` as fallback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileDestroy(options?: any): AxiosPromise<void> {
            return localVarFp.v1ProfileDestroy(options).then((request) => request(axios, basePath));
        },
        /**
         * User profile view with image upload
         * @param {PatchedUserUpdate} [patchedUserUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfilePartialUpdate(patchedUserUpdate?: PatchedUserUpdate, options?: any): AxiosPromise<UserUpdate> {
            return localVarFp.v1ProfilePartialUpdate(patchedUserUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * User profile view with image upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileRetrieve(options?: any): AxiosPromise<UserProfile> {
            return localVarFp.v1ProfileRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * User profile view with image upload
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProfileUpdate(userUpdate: UserUpdate, options?: any): AxiosPromise<UserUpdate> {
            return localVarFp.v1ProfileUpdate(userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get review analytics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsAnalyticsRetrieve(options?: any): AxiosPromise<ReviewAnalytics> {
            return localVarFp.v1ReviewsAnalyticsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * List and create reviews.
         * @param {ReviewCreate} reviewCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsCreate(reviewCreate: ReviewCreate, options?: any): AxiosPromise<ReviewCreate> {
            return localVarFp.v1ReviewsCreate(reviewCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.v1ReviewsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List and create reviews.
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsList(isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedReviewList> {
            return localVarFp.v1ReviewsList(isVerified, ordering, overallRating, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Get reviews for a specific order.
         * @param {number} orderId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsOrderList(orderId: number, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedReviewList> {
            return localVarFp.v1ReviewsOrderList(orderId, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {PatchedReviewUpdate} [patchedReviewUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsPartialUpdate(id: number, patchedReviewUpdate?: PatchedReviewUpdate, options?: any): AxiosPromise<ReviewUpdate> {
            return localVarFp.v1ReviewsPartialUpdate(id, patchedReviewUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get reviews for a specific service provider.
         * @param {number} providerId 
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [overallRating] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsProviderList(providerId: number, isVerified?: boolean, ordering?: string, overallRating?: number, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedReviewList> {
            return localVarFp.v1ReviewsProviderList(providerId, isVerified, ordering, overallRating, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsRetrieve(id: number, options?: any): AxiosPromise<Review> {
            return localVarFp.v1ReviewsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve, update, and delete specific review.
         * @param {number} id 
         * @param {ReviewUpdate} reviewUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ReviewsUpdate(id: number, reviewUpdate: ReviewUpdate, options?: any): AxiosPromise<ReviewUpdate> {
            return localVarFp.v1ReviewsUpdate(id, reviewUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Simple global search across all content types.
         * @param {string} [city] Filter by city
         * @param {number} [maxBudget] Maximum budget
         * @param {number} [minBudget] Minimum budget
         * @param {number} [minRating] Minimum rating for providers
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {number} [serviceCategory] Filter by service category ID
         * @param {'all' | 'orders' | 'providers' | 'services'} [type] Type of search to perform  * &#x60;all&#x60; - All * &#x60;orders&#x60; - Orders * &#x60;providers&#x60; - Providers * &#x60;services&#x60; - Services
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchGlobalList(city?: string, maxBudget?: number, minBudget?: number, minRating?: number, ordering?: string, page?: number, pageSize?: number, q?: string, serviceCategory?: number, type?: 'all' | 'orders' | 'providers' | 'services', urgency?: 'high' | 'low' | 'medium' | 'urgent', options?: any): AxiosPromise<PaginatedGlobalSearchResponseList> {
            return localVarFp.v1SearchGlobalList(city, maxBudget, minBudget, minRating, ordering, page, pageSize, q, serviceCategory, type, urgency, options).then((request) => request(axios, basePath));
        },
        /**
         * Search specifically for orders (job vacancies).
         * @param {string} [city] Filter by city
         * @param {number} [maxBudget] Maximum budget
         * @param {number} [minBudget] Minimum budget
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {number} [serviceCategory] Filter by service category ID
         * @param {'high' | 'low' | 'medium' | 'urgent'} [urgency] Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchOrdersList(city?: string, maxBudget?: number, minBudget?: number, ordering?: string, page?: number, pageSize?: number, q?: string, serviceCategory?: number, urgency?: 'high' | 'low' | 'medium' | 'urgent', options?: any): AxiosPromise<PaginatedOrderSearchResponseList> {
            return localVarFp.v1SearchOrdersList(city, maxBudget, minBudget, ordering, page, pageSize, q, serviceCategory, urgency, options).then((request) => request(axios, basePath));
        },
        /**
         * Search specifically for service providers.
         * @param {string} [city] Filter by city
         * @param {number} [minRating] Minimum rating
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [q] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SearchProvidersList(city?: string, minRating?: number, ordering?: string, page?: number, pageSize?: number, q?: string, options?: any): AxiosPromise<PaginatedProviderSearchResponseList> {
            return localVarFp.v1SearchProvidersList(city, minRating, ordering, page, pageSize, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatchedClientUpdate} [patchedClientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersClientPartialUpdate(patchedClientUpdate?: PatchedClientUpdate, options?: any): AxiosPromise<ClientUpdate> {
            return localVarFp.v1UsersClientPartialUpdate(patchedClientUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersClientRetrieve(options?: any): AxiosPromise<Client> {
            return localVarFp.v1UsersClientRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClientUpdate} [clientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersClientUpdate(clientUpdate?: ClientUpdate, options?: any): AxiosPromise<ClientUpdate> {
            return localVarFp.v1UsersClientUpdate(clientUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update client profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersClientUpdateCreate(options?: any): AxiosPromise<void> {
            return localVarFp.v1UsersClientUpdateCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [createdAt] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersClientsList(createdAt?: string, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedClientList> {
            return localVarFp.v1UsersClientsList(createdAt, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List all users - not in api_users, useful for admin
         * @param {boolean} [blocked] 
         * @param {boolean} [isActive] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {'free' | 'paid' | 'premium_paid'} [userType] * &#x60;free&#x60; - Бесплатный * &#x60;paid&#x60; - Оплаченный * &#x60;premium_paid&#x60; - Премиум оплаченный
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersList(blocked?: boolean, isActive?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, userType?: 'free' | 'paid' | 'premium_paid', options?: any): AxiosPromise<PaginatedUserListList> {
            return localVarFp.v1UsersList(blocked, isActive, ordering, page, pageSize, search, userType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatchedUserProfileUpdate} [patchedUserProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfilePartialUpdate(patchedUserProfileUpdate?: PatchedUserProfileUpdate, options?: any): AxiosPromise<UserProfileUpdate> {
            return localVarFp.v1UsersProfilePartialUpdate(patchedUserProfileUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfileRetrieve(options?: any): AxiosPromise<UserProfileDetail> {
            return localVarFp.v1UsersProfileRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserProfileUpdate} [userProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfileUpdate(userProfileUpdate?: UserProfileUpdate, options?: any): AxiosPromise<UserProfileUpdate> {
            return localVarFp.v1UsersProfileUpdate(userProfileUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfileUpdateCreate(options?: any): AxiosPromise<void> {
            return localVarFp.v1UsersProfileUpdateCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'female' | 'male' | 'other' | 'prefer_not_to_say'} [gender] * &#x60;male&#x60; - Male * &#x60;female&#x60; - Female * &#x60;other&#x60; - Other * &#x60;prefer_not_to_say&#x60; - Prefer not to say
         * @param {boolean} [isVerified] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {'both' | 'client' | 'service_provider'} [userType] * &#x60;client&#x60; - Client * &#x60;service_provider&#x60; - Service Provider * &#x60;both&#x60; - Both
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProfilesList(gender?: 'female' | 'male' | 'other' | 'prefer_not_to_say', isVerified?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, userType?: 'both' | 'client' | 'service_provider', options?: any): AxiosPromise<PaginatedUserProfileDetailList> {
            return localVarFp.v1UsersProfilesList(gender, isVerified, ordering, page, pageSize, search, userType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatchedServiceProviderUpdate} [patchedServiceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProviderPartialUpdate(patchedServiceProviderUpdate?: PatchedServiceProviderUpdate, options?: any): AxiosPromise<ServiceProviderUpdate> {
            return localVarFp.v1UsersProviderPartialUpdate(patchedServiceProviderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProviderRetrieve(options?: any): AxiosPromise<ServiceProvider> {
            return localVarFp.v1UsersProviderRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServiceProviderUpdate} [serviceProviderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProviderUpdate(serviceProviderUpdate?: ServiceProviderUpdate, options?: any): AxiosPromise<ServiceProviderUpdate> {
            return localVarFp.v1UsersProviderUpdate(serviceProviderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update service provider profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProviderUpdateCreate(options?: any): AxiosPromise<void> {
            return localVarFp.v1UsersProviderUpdateCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isAvailable] 
         * @param {boolean} [isVerifiedProvider] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsersProvidersList(isAvailable?: boolean, isVerifiedProvider?: boolean, ordering?: string, page?: number, pageSize?: number, search?: string, options?: any): AxiosPromise<PaginatedServiceProviderList> {
            return localVarFp.v1UsersProvidersList(isAvailable, isVerifiedProvider, ordering, page, pageSize, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for v1AnalyticsActivitiesCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AnalyticsActivitiesCreateCreateRequest
 */
export interface V1ApiV1AnalyticsActivitiesCreateCreateRequest {
    /**
     * 
     * @type {UserActivityCreate}
     * @memberof V1ApiV1AnalyticsActivitiesCreateCreate
     */
    readonly userActivityCreate: UserActivityCreate
}

/**
 * Request parameters for v1AnalyticsActivitiesList operation in V1Api.
 * @export
 * @interface V1ApiV1AnalyticsActivitiesListRequest
 */
export interface V1ApiV1AnalyticsActivitiesListRequest {
    /**
     * * &#x60;login&#x60; - Login * &#x60;logout&#x60; - Logout * &#x60;order_created&#x60; - Order Created * &#x60;order_viewed&#x60; - Order Viewed * &#x60;bid_submitted&#x60; - Bid Submitted * &#x60;chat_message&#x60; - Chat Message * &#x60;payment_made&#x60; - Payment Made * &#x60;profile_updated&#x60; - Profile Updated * &#x60;search_performed&#x60; - Search Performed * &#x60;service_viewed&#x60; - Service Viewed
     * @type {'bid_submitted' | 'chat_message' | 'login' | 'logout' | 'order_created' | 'order_viewed' | 'payment_made' | 'profile_updated' | 'search_performed' | 'service_viewed'}
     * @memberof V1ApiV1AnalyticsActivitiesList
     */
    readonly activityType?: 'bid_submitted' | 'chat_message' | 'login' | 'logout' | 'order_created' | 'order_viewed' | 'payment_made' | 'profile_updated' | 'search_performed' | 'service_viewed'

    /**
     * 
     * @type {string}
     * @memberof V1ApiV1AnalyticsActivitiesList
     */
    readonly ipAddress?: string

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1AnalyticsActivitiesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1AnalyticsActivitiesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1AnalyticsActivitiesList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1AnalyticsActivitiesList
     */
    readonly search?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1AnalyticsActivitiesList
     */
    readonly user?: number
}

/**
 * Request parameters for v1AnalyticsBusinessCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AnalyticsBusinessCreateCreateRequest
 */
export interface V1ApiV1AnalyticsBusinessCreateCreateRequest {
    /**
     * 
     * @type {BusinessMetricsCreate}
     * @memberof V1ApiV1AnalyticsBusinessCreateCreate
     */
    readonly businessMetricsCreate: BusinessMetricsCreate
}

/**
 * Request parameters for v1AnalyticsBusinessList operation in V1Api.
 * @export
 * @interface V1ApiV1AnalyticsBusinessListRequest
 */
export interface V1ApiV1AnalyticsBusinessListRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1AnalyticsBusinessList
     */
    readonly date?: string

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1AnalyticsBusinessList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1AnalyticsBusinessList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1AnalyticsBusinessList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1AnalyticsCategoriesCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AnalyticsCategoriesCreateCreateRequest
 */
export interface V1ApiV1AnalyticsCategoriesCreateCreateRequest {
    /**
     * 
     * @type {ServiceCategoryAnalyticsCreate}
     * @memberof V1ApiV1AnalyticsCategoriesCreateCreate
     */
    readonly serviceCategoryAnalyticsCreate: ServiceCategoryAnalyticsCreate
}

/**
 * Request parameters for v1AnalyticsCategoriesList operation in V1Api.
 * @export
 * @interface V1ApiV1AnalyticsCategoriesListRequest
 */
export interface V1ApiV1AnalyticsCategoriesListRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1AnalyticsCategoriesList
     */
    readonly category?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiV1AnalyticsCategoriesList
     */
    readonly date?: string

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1AnalyticsCategoriesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1AnalyticsCategoriesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1AnalyticsCategoriesList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1AnalyticsOrdersCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AnalyticsOrdersCreateCreateRequest
 */
export interface V1ApiV1AnalyticsOrdersCreateCreateRequest {
    /**
     * 
     * @type {OrderAnalyticsCreate}
     * @memberof V1ApiV1AnalyticsOrdersCreateCreate
     */
    readonly orderAnalyticsCreate: OrderAnalyticsCreate
}

/**
 * Request parameters for v1AnalyticsOrdersList operation in V1Api.
 * @export
 * @interface V1ApiV1AnalyticsOrdersListRequest
 */
export interface V1ApiV1AnalyticsOrdersListRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1AnalyticsOrdersList
     */
    readonly date?: string

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1AnalyticsOrdersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1AnalyticsOrdersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1AnalyticsOrdersList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1AnalyticsPerformanceList operation in V1Api.
 * @export
 * @interface V1ApiV1AnalyticsPerformanceListRequest
 */
export interface V1ApiV1AnalyticsPerformanceListRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1AnalyticsPerformanceList
     */
    readonly date?: string

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1AnalyticsPerformanceList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1AnalyticsPerformanceList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1AnalyticsPerformanceList
     */
    readonly pageSize?: number

    /**
     * * &#x60;hourly&#x60; - Hourly * &#x60;daily&#x60; - Daily * &#x60;weekly&#x60; - Weekly * &#x60;monthly&#x60; - Monthly
     * @type {'daily' | 'hourly' | 'monthly' | 'weekly'}
     * @memberof V1ApiV1AnalyticsPerformanceList
     */
    readonly timePeriod?: 'daily' | 'hourly' | 'monthly' | 'weekly'
}

/**
 * Request parameters for v1AuthFirebaseCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AuthFirebaseCreateRequest
 */
export interface V1ApiV1AuthFirebaseCreateRequest {
    /**
     * 
     * @type {FireBaseAuth}
     * @memberof V1ApiV1AuthFirebaseCreate
     */
    readonly fireBaseAuth: FireBaseAuth
}

/**
 * Request parameters for v1AuthLogoutCreate operation in V1Api.
 * @export
 * @interface V1ApiV1AuthLogoutCreateRequest
 */
export interface V1ApiV1AuthLogoutCreateRequest {
    /**
     * 
     * @type {LogoutResponse}
     * @memberof V1ApiV1AuthLogoutCreate
     */
    readonly logoutResponse: LogoutResponse
}

/**
 * Request parameters for v1ChatAttachmentsCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ChatAttachmentsCreateCreateRequest
 */
export interface V1ApiV1ChatAttachmentsCreateCreateRequest {
    /**
     * 
     * @type {ChatAttachmentCreate}
     * @memberof V1ApiV1ChatAttachmentsCreateCreate
     */
    readonly chatAttachmentCreate: ChatAttachmentCreate
}

/**
 * Request parameters for v1ChatAttachmentsDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1ChatAttachmentsDestroyRequest
 */
export interface V1ApiV1ChatAttachmentsDestroyRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatAttachmentsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1ChatAttachmentsList operation in V1Api.
 * @export
 * @interface V1ApiV1ChatAttachmentsListRequest
 */
export interface V1ApiV1ChatAttachmentsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ChatAttachmentsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ChatAttachmentsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ChatAttachmentsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1ChatAttachmentsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1ChatAttachmentsRetrieveRequest
 */
export interface V1ApiV1ChatAttachmentsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatAttachmentsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1ChatMessagesCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ChatMessagesCreateCreateRequest
 */
export interface V1ApiV1ChatMessagesCreateCreateRequest {
    /**
     * 
     * @type {MessageCreate}
     * @memberof V1ApiV1ChatMessagesCreateCreate
     */
    readonly messageCreate: MessageCreate
}

/**
 * Request parameters for v1ChatMessagesDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1ChatMessagesDestroyRequest
 */
export interface V1ApiV1ChatMessagesDestroyRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatMessagesDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1ChatMessagesList operation in V1Api.
 * @export
 * @interface V1ApiV1ChatMessagesListRequest
 */
export interface V1ApiV1ChatMessagesListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ChatMessagesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ChatMessagesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ChatMessagesList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1ChatMessagesPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ChatMessagesPartialUpdateRequest
 */
export interface V1ApiV1ChatMessagesPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatMessagesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedMessageUpdate}
     * @memberof V1ApiV1ChatMessagesPartialUpdate
     */
    readonly patchedMessageUpdate?: PatchedMessageUpdate
}

/**
 * Request parameters for v1ChatMessagesRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1ChatMessagesRetrieveRequest
 */
export interface V1ApiV1ChatMessagesRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatMessagesRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1ChatMessagesUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ChatMessagesUpdateRequest
 */
export interface V1ApiV1ChatMessagesUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatMessagesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {MessageUpdate}
     * @memberof V1ApiV1ChatMessagesUpdate
     */
    readonly messageUpdate: MessageUpdate
}

/**
 * Request parameters for v1ChatParticipantsCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ChatParticipantsCreateCreateRequest
 */
export interface V1ApiV1ChatParticipantsCreateCreateRequest {
    /**
     * 
     * @type {ChatParticipantCreate}
     * @memberof V1ApiV1ChatParticipantsCreateCreate
     */
    readonly chatParticipantCreate: ChatParticipantCreate
}

/**
 * Request parameters for v1ChatParticipantsList operation in V1Api.
 * @export
 * @interface V1ApiV1ChatParticipantsListRequest
 */
export interface V1ApiV1ChatParticipantsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ChatParticipantsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ChatParticipantsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ChatParticipantsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1ChatRoomsCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ChatRoomsCreateCreateRequest
 */
export interface V1ApiV1ChatRoomsCreateCreateRequest {
    /**
     * 
     * @type {ChatRoomCreate}
     * @memberof V1ApiV1ChatRoomsCreateCreate
     */
    readonly chatRoomCreate?: ChatRoomCreate
}

/**
 * Request parameters for v1ChatRoomsList operation in V1Api.
 * @export
 * @interface V1ApiV1ChatRoomsListRequest
 */
export interface V1ApiV1ChatRoomsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ChatRoomsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ChatRoomsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ChatRoomsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1ChatRoomsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1ChatRoomsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ChatRoomsPartialUpdateRequest
 */
export interface V1ApiV1ChatRoomsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatRoomsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedChatRoomUpdate}
     * @memberof V1ApiV1ChatRoomsPartialUpdate
     */
    readonly patchedChatRoomUpdate?: PatchedChatRoomUpdate
}

/**
 * Request parameters for v1ChatRoomsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1ChatRoomsRetrieveRequest
 */
export interface V1ApiV1ChatRoomsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatRoomsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1ChatRoomsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ChatRoomsUpdateRequest
 */
export interface V1ApiV1ChatRoomsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ChatRoomsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ChatRoomUpdate}
     * @memberof V1ApiV1ChatRoomsUpdate
     */
    readonly chatRoomUpdate?: ChatRoomUpdate
}

/**
 * Request parameters for v1CoreAppVersionsList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreAppVersionsListRequest
 */
export interface V1ApiV1CoreAppVersionsListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreAppVersionsList
     */
    readonly isActive?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreAppVersionsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreAppVersionsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreAppVersionsList
     */
    readonly pageSize?: number

    /**
     * * &#x60;android&#x60; - Android * &#x60;ios&#x60; - iOS * &#x60;web&#x60; - Web * &#x60;all&#x60; - All Platforms
     * @type {'all' | 'android' | 'ios' | 'web'}
     * @memberof V1ApiV1CoreAppVersionsList
     */
    readonly platform?: 'all' | 'android' | 'ios' | 'web'

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreAppVersionsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1CoreLanguagesList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreLanguagesListRequest
 */
export interface V1ApiV1CoreLanguagesListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly isDefault?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreLanguagesList
     */
    readonly search?: string
}

/**
 * Request parameters for v1CoreServiceAreasList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceAreasListRequest
 */
export interface V1ApiV1CoreServiceAreasListRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly country?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly isActive?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly search?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiV1CoreServiceAreasList
     */
    readonly state?: string
}

/**
 * Request parameters for v1CoreServiceCategoriesList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceCategoriesListRequest
 */
export interface V1ApiV1CoreServiceCategoriesListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly featured?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly isActive?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreServiceCategoriesList
     */
    readonly search?: string
}

/**
 * Request parameters for v1CoreServiceSubcategoriesList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreServiceSubcategoriesListRequest
 */
export interface V1ApiV1CoreServiceSubcategoriesListRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly category?: number

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly featured?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly isActive?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreServiceSubcategoriesList
     */
    readonly search?: string
}

/**
 * Request parameters for v1CoreSystemSettingsList operation in V1Api.
 * @export
 * @interface V1ApiV1CoreSystemSettingsListRequest
 */
export interface V1ApiV1CoreSystemSettingsListRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly category?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly isPublic?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1CoreSystemSettingsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1NotificationsCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsCreateCreateRequest
 */
export interface V1ApiV1NotificationsCreateCreateRequest {
    /**
     * 
     * @type {NotificationCreate}
     * @memberof V1ApiV1NotificationsCreateCreate
     */
    readonly notificationCreate: NotificationCreate
}

/**
 * Request parameters for v1NotificationsList operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsListRequest
 */
export interface V1ApiV1NotificationsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1NotificationsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1NotificationsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1NotificationsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1NotificationsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1NotificationsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsPartialUpdateRequest
 */
export interface V1ApiV1NotificationsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1NotificationsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedNotificationUpdate}
     * @memberof V1ApiV1NotificationsPartialUpdate
     */
    readonly patchedNotificationUpdate?: PatchedNotificationUpdate
}

/**
 * Request parameters for v1NotificationsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsRetrieveRequest
 */
export interface V1ApiV1NotificationsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1NotificationsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1NotificationsSettingsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsSettingsPartialUpdateRequest
 */
export interface V1ApiV1NotificationsSettingsPartialUpdateRequest {
    /**
     * 
     * @type {PatchedNotificationSettingUpdate}
     * @memberof V1ApiV1NotificationsSettingsPartialUpdate
     */
    readonly patchedNotificationSettingUpdate?: PatchedNotificationSettingUpdate
}

/**
 * Request parameters for v1NotificationsSettingsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsSettingsUpdateRequest
 */
export interface V1ApiV1NotificationsSettingsUpdateRequest {
    /**
     * 
     * @type {NotificationSettingUpdate}
     * @memberof V1ApiV1NotificationsSettingsUpdate
     */
    readonly notificationSettingUpdate?: NotificationSettingUpdate
}

/**
 * Request parameters for v1NotificationsTemplatesCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsTemplatesCreateCreateRequest
 */
export interface V1ApiV1NotificationsTemplatesCreateCreateRequest {
    /**
     * 
     * @type {NotificationTemplateCreate}
     * @memberof V1ApiV1NotificationsTemplatesCreateCreate
     */
    readonly notificationTemplateCreate: NotificationTemplateCreate
}

/**
 * Request parameters for v1NotificationsTemplatesList operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsTemplatesListRequest
 */
export interface V1ApiV1NotificationsTemplatesListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1NotificationsTemplatesList
     */
    readonly isActive?: boolean

    /**
     * * &#x60;order_update&#x60; - Order Update * &#x60;bid_received&#x60; - Bid Received * &#x60;payment_success&#x60; - Payment Success * &#x60;payment_failed&#x60; - Payment Failed * &#x60;chat_message&#x60; - Chat Message * &#x60;system_alert&#x60; - System Alert * &#x60;promotional&#x60; - Promotional
     * @type {'bid_received' | 'chat_message' | 'order_update' | 'payment_failed' | 'payment_success' | 'promotional' | 'system_alert'}
     * @memberof V1ApiV1NotificationsTemplatesList
     */
    readonly notificationType?: 'bid_received' | 'chat_message' | 'order_update' | 'payment_failed' | 'payment_success' | 'promotional' | 'system_alert'

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1NotificationsTemplatesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1NotificationsTemplatesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1NotificationsTemplatesList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1NotificationsTemplatesList
     */
    readonly search?: string
}

/**
 * Request parameters for v1NotificationsTemplatesPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsTemplatesPartialUpdateRequest
 */
export interface V1ApiV1NotificationsTemplatesPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1NotificationsTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedNotificationTemplateUpdate}
     * @memberof V1ApiV1NotificationsTemplatesPartialUpdate
     */
    readonly patchedNotificationTemplateUpdate?: PatchedNotificationTemplateUpdate
}

/**
 * Request parameters for v1NotificationsTemplatesRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsTemplatesRetrieveRequest
 */
export interface V1ApiV1NotificationsTemplatesRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1NotificationsTemplatesRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1NotificationsTemplatesUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsTemplatesUpdateRequest
 */
export interface V1ApiV1NotificationsTemplatesUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1NotificationsTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {NotificationTemplateUpdate}
     * @memberof V1ApiV1NotificationsTemplatesUpdate
     */
    readonly notificationTemplateUpdate: NotificationTemplateUpdate
}

/**
 * Request parameters for v1NotificationsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1NotificationsUpdateRequest
 */
export interface V1ApiV1NotificationsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1NotificationsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {NotificationUpdate}
     * @memberof V1ApiV1NotificationsUpdate
     */
    readonly notificationUpdate?: NotificationUpdate
}

/**
 * Request parameters for v1OrdersAddonsList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersAddonsListRequest
 */
export interface V1ApiV1OrdersAddonsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersAddonsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersAddonsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersAddonsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1OrdersAddonsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1OrdersBidsCreate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsCreateRequest
 */
export interface V1ApiV1OrdersBidsCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersBidsCreate
     */
    readonly orderId: number

    /**
     * 
     * @type {BidCreate}
     * @memberof V1ApiV1OrdersBidsCreate
     */
    readonly bidCreate: BidCreate
}

/**
 * Request parameters for v1OrdersBidsList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersBidsListRequest
 */
export interface V1ApiV1OrdersBidsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersBidsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersBidsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersBidsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1OrdersCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersCreateCreateRequest
 */
export interface V1ApiV1OrdersCreateCreateRequest {
    /**
     * 
     * @type {OrderCreate}
     * @memberof V1ApiV1OrdersCreateCreate
     */
    readonly orderCreate: OrderCreate
}

/**
 * Request parameters for v1OrdersDisputesCreate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersDisputesCreateRequest
 */
export interface V1ApiV1OrdersDisputesCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersDisputesCreate
     */
    readonly orderId: number

    /**
     * 
     * @type {OrderDisputeCreate}
     * @memberof V1ApiV1OrdersDisputesCreate
     */
    readonly orderDisputeCreate: OrderDisputeCreate
}

/**
 * Request parameters for v1OrdersDisputesList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersDisputesListRequest
 */
export interface V1ApiV1OrdersDisputesListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersDisputesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersDisputesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersDisputesList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1OrdersDisputesPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersDisputesPartialUpdateRequest
 */
export interface V1ApiV1OrdersDisputesPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersDisputesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedOrderDisputeUpdate}
     * @memberof V1ApiV1OrdersDisputesPartialUpdate
     */
    readonly patchedOrderDisputeUpdate?: PatchedOrderDisputeUpdate
}

/**
 * Request parameters for v1OrdersDisputesRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersDisputesRetrieveRequest
 */
export interface V1ApiV1OrdersDisputesRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersDisputesRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1OrdersDisputesUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersDisputesUpdateRequest
 */
export interface V1ApiV1OrdersDisputesUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersDisputesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {OrderDisputeUpdate}
     * @memberof V1ApiV1OrdersDisputesUpdate
     */
    readonly orderDisputeUpdate?: OrderDisputeUpdate
}

/**
 * Request parameters for v1OrdersList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersListRequest
 */
export interface V1ApiV1OrdersListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1OrdersList
     */
    readonly search?: string
}

/**
 * Request parameters for v1OrdersPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersPartialUpdateRequest
 */
export interface V1ApiV1OrdersPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedOrderUpdate}
     * @memberof V1ApiV1OrdersPartialUpdate
     */
    readonly patchedOrderUpdate?: PatchedOrderUpdate
}

/**
 * Request parameters for v1OrdersPhotosList operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersPhotosListRequest
 */
export interface V1ApiV1OrdersPhotosListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1OrdersPhotosList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1OrdersPhotosList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1OrdersPhotosList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1OrdersRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersRetrieveRequest
 */
export interface V1ApiV1OrdersRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1OrdersUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1OrdersUpdateRequest
 */
export interface V1ApiV1OrdersUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1OrdersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {OrderUpdate}
     * @memberof V1ApiV1OrdersUpdate
     */
    readonly orderUpdate: OrderUpdate
}

/**
 * Request parameters for v1PaymentsCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsCreateCreateRequest
 */
export interface V1ApiV1PaymentsCreateCreateRequest {
    /**
     * 
     * @type {PaymentCreate}
     * @memberof V1ApiV1PaymentsCreateCreate
     */
    readonly paymentCreate: PaymentCreate
}

/**
 * Request parameters for v1PaymentsInvoicesCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsInvoicesCreateCreateRequest
 */
export interface V1ApiV1PaymentsInvoicesCreateCreateRequest {
    /**
     * 
     * @type {InvoiceCreate}
     * @memberof V1ApiV1PaymentsInvoicesCreateCreate
     */
    readonly invoiceCreate: InvoiceCreate
}

/**
 * Request parameters for v1PaymentsInvoicesList operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsInvoicesListRequest
 */
export interface V1ApiV1PaymentsInvoicesListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1PaymentsInvoicesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1PaymentsInvoicesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1PaymentsInvoicesList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1PaymentsInvoicesRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsInvoicesRetrieveRequest
 */
export interface V1ApiV1PaymentsInvoicesRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsInvoicesRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1PaymentsList operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsListRequest
 */
export interface V1ApiV1PaymentsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1PaymentsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1PaymentsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1PaymentsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1PaymentsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1PaymentsMethodsCreateCreate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsCreateCreateRequest
 */
export interface V1ApiV1PaymentsMethodsCreateCreateRequest {
    /**
     * 
     * @type {PaymentMethodCreate}
     * @memberof V1ApiV1PaymentsMethodsCreateCreate
     */
    readonly paymentMethodCreate: PaymentMethodCreate
}

/**
 * Request parameters for v1PaymentsMethodsDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsDestroyRequest
 */
export interface V1ApiV1PaymentsMethodsDestroyRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1PaymentsMethodsList operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsListRequest
 */
export interface V1ApiV1PaymentsMethodsListRequest {
    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1PaymentsMethodsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1PaymentsMethodsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsPartialUpdateRequest
 */
export interface V1ApiV1PaymentsMethodsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedPaymentMethodUpdate}
     * @memberof V1ApiV1PaymentsMethodsPartialUpdate
     */
    readonly patchedPaymentMethodUpdate?: PatchedPaymentMethodUpdate
}

/**
 * Request parameters for v1PaymentsMethodsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsRetrieveRequest
 */
export interface V1ApiV1PaymentsMethodsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1PaymentsMethodsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsMethodsUpdateRequest
 */
export interface V1ApiV1PaymentsMethodsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsMethodsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PaymentMethodUpdate}
     * @memberof V1ApiV1PaymentsMethodsUpdate
     */
    readonly paymentMethodUpdate?: PaymentMethodUpdate
}

/**
 * Request parameters for v1PaymentsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsPartialUpdateRequest
 */
export interface V1ApiV1PaymentsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedPaymentCreate}
     * @memberof V1ApiV1PaymentsPartialUpdate
     */
    readonly patchedPaymentCreate?: PatchedPaymentCreate
}

/**
 * Request parameters for v1PaymentsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsRetrieveRequest
 */
export interface V1ApiV1PaymentsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1PaymentsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsUpdateRequest
 */
export interface V1ApiV1PaymentsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PaymentCreate}
     * @memberof V1ApiV1PaymentsUpdate
     */
    readonly paymentCreate: PaymentCreate
}

/**
 * Request parameters for v1PaymentsWebhooksEventsRetryCreate operation in V1Api.
 * @export
 * @interface V1ApiV1PaymentsWebhooksEventsRetryCreateRequest
 */
export interface V1ApiV1PaymentsWebhooksEventsRetryCreateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1PaymentsWebhooksEventsRetryCreate
     */
    readonly eventId: number
}

/**
 * Request parameters for v1ProfileCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ProfileCreateRequest
 */
export interface V1ApiV1ProfileCreateRequest {
    /**
     * 
     * @type {UserUpdate}
     * @memberof V1ApiV1ProfileCreate
     */
    readonly userUpdate: UserUpdate
}

/**
 * Request parameters for v1ProfilePartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ProfilePartialUpdateRequest
 */
export interface V1ApiV1ProfilePartialUpdateRequest {
    /**
     * 
     * @type {PatchedUserUpdate}
     * @memberof V1ApiV1ProfilePartialUpdate
     */
    readonly patchedUserUpdate?: PatchedUserUpdate
}

/**
 * Request parameters for v1ProfileUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ProfileUpdateRequest
 */
export interface V1ApiV1ProfileUpdateRequest {
    /**
     * 
     * @type {UserUpdate}
     * @memberof V1ApiV1ProfileUpdate
     */
    readonly userUpdate: UserUpdate
}

/**
 * Request parameters for v1ReviewsCreate operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsCreateRequest
 */
export interface V1ApiV1ReviewsCreateRequest {
    /**
     * 
     * @type {ReviewCreate}
     * @memberof V1ApiV1ReviewsCreate
     */
    readonly reviewCreate: ReviewCreate
}

/**
 * Request parameters for v1ReviewsDestroy operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsDestroyRequest
 */
export interface V1ApiV1ReviewsDestroyRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsDestroy
     */
    readonly id: number
}

/**
 * Request parameters for v1ReviewsList operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsListRequest
 */
export interface V1ApiV1ReviewsListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1ReviewsList
     */
    readonly isVerified?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ReviewsList
     */
    readonly ordering?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsList
     */
    readonly overallRating?: number

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ReviewsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ReviewsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1ReviewsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1ReviewsOrderList operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsOrderListRequest
 */
export interface V1ApiV1ReviewsOrderListRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsOrderList
     */
    readonly orderId: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ReviewsOrderList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ReviewsOrderList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ReviewsOrderList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1ReviewsOrderList
     */
    readonly search?: string
}

/**
 * Request parameters for v1ReviewsPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsPartialUpdateRequest
 */
export interface V1ApiV1ReviewsPartialUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedReviewUpdate}
     * @memberof V1ApiV1ReviewsPartialUpdate
     */
    readonly patchedReviewUpdate?: PatchedReviewUpdate
}

/**
 * Request parameters for v1ReviewsProviderList operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsProviderListRequest
 */
export interface V1ApiV1ReviewsProviderListRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly providerId: number

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly isVerified?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly ordering?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly overallRating?: number

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1ReviewsProviderList
     */
    readonly pageSize?: number
}

/**
 * Request parameters for v1ReviewsRetrieve operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsRetrieveRequest
 */
export interface V1ApiV1ReviewsRetrieveRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for v1ReviewsUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1ReviewsUpdateRequest
 */
export interface V1ApiV1ReviewsUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiV1ReviewsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ReviewUpdate}
     * @memberof V1ApiV1ReviewsUpdate
     */
    readonly reviewUpdate: ReviewUpdate
}

/**
 * Request parameters for v1SearchGlobalList operation in V1Api.
 * @export
 * @interface V1ApiV1SearchGlobalListRequest
 */
export interface V1ApiV1SearchGlobalListRequest {
    /**
     * Filter by city
     * @type {string}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly city?: string

    /**
     * Maximum budget
     * @type {number}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly maxBudget?: number

    /**
     * Minimum budget
     * @type {number}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly minBudget?: number

    /**
     * Minimum rating for providers
     * @type {number}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly minRating?: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly pageSize?: number

    /**
     * Search query
     * @type {string}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly q?: string

    /**
     * Filter by service category ID
     * @type {number}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly serviceCategory?: number

    /**
     * Type of search to perform  * &#x60;all&#x60; - All * &#x60;orders&#x60; - Orders * &#x60;providers&#x60; - Providers * &#x60;services&#x60; - Services
     * @type {'all' | 'orders' | 'providers' | 'services'}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly type?: 'all' | 'orders' | 'providers' | 'services'

    /**
     * Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
     * @type {'high' | 'low' | 'medium' | 'urgent'}
     * @memberof V1ApiV1SearchGlobalList
     */
    readonly urgency?: 'high' | 'low' | 'medium' | 'urgent'
}

/**
 * Request parameters for v1SearchOrdersList operation in V1Api.
 * @export
 * @interface V1ApiV1SearchOrdersListRequest
 */
export interface V1ApiV1SearchOrdersListRequest {
    /**
     * Filter by city
     * @type {string}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly city?: string

    /**
     * Maximum budget
     * @type {number}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly maxBudget?: number

    /**
     * Minimum budget
     * @type {number}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly minBudget?: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly pageSize?: number

    /**
     * Search query
     * @type {string}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly q?: string

    /**
     * Filter by service category ID
     * @type {number}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly serviceCategory?: number

    /**
     * Filter by urgency level  * &#x60;low&#x60; - Low * &#x60;medium&#x60; - Medium * &#x60;high&#x60; - High * &#x60;urgent&#x60; - Urgent
     * @type {'high' | 'low' | 'medium' | 'urgent'}
     * @memberof V1ApiV1SearchOrdersList
     */
    readonly urgency?: 'high' | 'low' | 'medium' | 'urgent'
}

/**
 * Request parameters for v1SearchProvidersList operation in V1Api.
 * @export
 * @interface V1ApiV1SearchProvidersListRequest
 */
export interface V1ApiV1SearchProvidersListRequest {
    /**
     * Filter by city
     * @type {string}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly city?: string

    /**
     * Minimum rating
     * @type {number}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly minRating?: number

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly pageSize?: number

    /**
     * Search query
     * @type {string}
     * @memberof V1ApiV1SearchProvidersList
     */
    readonly q?: string
}

/**
 * Request parameters for v1UsersClientPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersClientPartialUpdateRequest
 */
export interface V1ApiV1UsersClientPartialUpdateRequest {
    /**
     * 
     * @type {PatchedClientUpdate}
     * @memberof V1ApiV1UsersClientPartialUpdate
     */
    readonly patchedClientUpdate?: PatchedClientUpdate
}

/**
 * Request parameters for v1UsersClientUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersClientUpdateRequest
 */
export interface V1ApiV1UsersClientUpdateRequest {
    /**
     * 
     * @type {ClientUpdate}
     * @memberof V1ApiV1UsersClientUpdate
     */
    readonly clientUpdate?: ClientUpdate
}

/**
 * Request parameters for v1UsersClientsList operation in V1Api.
 * @export
 * @interface V1ApiV1UsersClientsListRequest
 */
export interface V1ApiV1UsersClientsListRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiV1UsersClientsList
     */
    readonly createdAt?: string

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1UsersClientsList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1UsersClientsList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1UsersClientsList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1UsersClientsList
     */
    readonly search?: string
}

/**
 * Request parameters for v1UsersList operation in V1Api.
 * @export
 * @interface V1ApiV1UsersListRequest
 */
export interface V1ApiV1UsersListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1UsersList
     */
    readonly blocked?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1UsersList
     */
    readonly isActive?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1UsersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1UsersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1UsersList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1UsersList
     */
    readonly search?: string

    /**
     * * &#x60;free&#x60; - Бесплатный * &#x60;paid&#x60; - Оплаченный * &#x60;premium_paid&#x60; - Премиум оплаченный
     * @type {'free' | 'paid' | 'premium_paid'}
     * @memberof V1ApiV1UsersList
     */
    readonly userType?: 'free' | 'paid' | 'premium_paid'
}

/**
 * Request parameters for v1UsersProfilePartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersProfilePartialUpdateRequest
 */
export interface V1ApiV1UsersProfilePartialUpdateRequest {
    /**
     * 
     * @type {PatchedUserProfileUpdate}
     * @memberof V1ApiV1UsersProfilePartialUpdate
     */
    readonly patchedUserProfileUpdate?: PatchedUserProfileUpdate
}

/**
 * Request parameters for v1UsersProfileUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersProfileUpdateRequest
 */
export interface V1ApiV1UsersProfileUpdateRequest {
    /**
     * 
     * @type {UserProfileUpdate}
     * @memberof V1ApiV1UsersProfileUpdate
     */
    readonly userProfileUpdate?: UserProfileUpdate
}

/**
 * Request parameters for v1UsersProfilesList operation in V1Api.
 * @export
 * @interface V1ApiV1UsersProfilesListRequest
 */
export interface V1ApiV1UsersProfilesListRequest {
    /**
     * * &#x60;male&#x60; - Male * &#x60;female&#x60; - Female * &#x60;other&#x60; - Other * &#x60;prefer_not_to_say&#x60; - Prefer not to say
     * @type {'female' | 'male' | 'other' | 'prefer_not_to_say'}
     * @memberof V1ApiV1UsersProfilesList
     */
    readonly gender?: 'female' | 'male' | 'other' | 'prefer_not_to_say'

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1UsersProfilesList
     */
    readonly isVerified?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1UsersProfilesList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1UsersProfilesList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1UsersProfilesList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1UsersProfilesList
     */
    readonly search?: string

    /**
     * * &#x60;client&#x60; - Client * &#x60;service_provider&#x60; - Service Provider * &#x60;both&#x60; - Both
     * @type {'both' | 'client' | 'service_provider'}
     * @memberof V1ApiV1UsersProfilesList
     */
    readonly userType?: 'both' | 'client' | 'service_provider'
}

/**
 * Request parameters for v1UsersProviderPartialUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersProviderPartialUpdateRequest
 */
export interface V1ApiV1UsersProviderPartialUpdateRequest {
    /**
     * 
     * @type {PatchedServiceProviderUpdate}
     * @memberof V1ApiV1UsersProviderPartialUpdate
     */
    readonly patchedServiceProviderUpdate?: PatchedServiceProviderUpdate
}

/**
 * Request parameters for v1UsersProviderUpdate operation in V1Api.
 * @export
 * @interface V1ApiV1UsersProviderUpdateRequest
 */
export interface V1ApiV1UsersProviderUpdateRequest {
    /**
     * 
     * @type {ServiceProviderUpdate}
     * @memberof V1ApiV1UsersProviderUpdate
     */
    readonly serviceProviderUpdate?: ServiceProviderUpdate
}

/**
 * Request parameters for v1UsersProvidersList operation in V1Api.
 * @export
 * @interface V1ApiV1UsersProvidersListRequest
 */
export interface V1ApiV1UsersProvidersListRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1UsersProvidersList
     */
    readonly isAvailable?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiV1UsersProvidersList
     */
    readonly isVerifiedProvider?: boolean

    /**
     * Which field to use when ordering the results.
     * @type {string}
     * @memberof V1ApiV1UsersProvidersList
     */
    readonly ordering?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof V1ApiV1UsersProvidersList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof V1ApiV1UsersProvidersList
     */
    readonly pageSize?: number

    /**
     * A search term.
     * @type {string}
     * @memberof V1ApiV1UsersProvidersList
     */
    readonly search?: string
}

/**
 * V1Api - object-oriented interface
 * @export
 * @class V1Api
 * @extends {BaseAPI}
 */
export class V1Api extends BaseAPI {
    /**
     * 
     * @param {V1ApiV1AnalyticsActivitiesCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AnalyticsActivitiesCreateCreate(requestParameters: V1ApiV1AnalyticsActivitiesCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AnalyticsActivitiesCreateCreate(requestParameters.userActivityCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1AnalyticsActivitiesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AnalyticsActivitiesList(requestParameters: V1ApiV1AnalyticsActivitiesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AnalyticsActivitiesList(requestParameters.activityType, requestParameters.ipAddress, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1AnalyticsBusinessCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AnalyticsBusinessCreateCreate(requestParameters: V1ApiV1AnalyticsBusinessCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AnalyticsBusinessCreateCreate(requestParameters.businessMetricsCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1AnalyticsBusinessListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AnalyticsBusinessList(requestParameters: V1ApiV1AnalyticsBusinessListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AnalyticsBusinessList(requestParameters.date, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1AnalyticsCategoriesCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AnalyticsCategoriesCreateCreate(requestParameters: V1ApiV1AnalyticsCategoriesCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AnalyticsCategoriesCreateCreate(requestParameters.serviceCategoryAnalyticsCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1AnalyticsCategoriesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AnalyticsCategoriesList(requestParameters: V1ApiV1AnalyticsCategoriesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AnalyticsCategoriesList(requestParameters.category, requestParameters.date, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dashboard overview data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AnalyticsDashboardRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AnalyticsDashboardRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1AnalyticsOrdersCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AnalyticsOrdersCreateCreate(requestParameters: V1ApiV1AnalyticsOrdersCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AnalyticsOrdersCreateCreate(requestParameters.orderAnalyticsCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1AnalyticsOrdersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AnalyticsOrdersList(requestParameters: V1ApiV1AnalyticsOrdersListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AnalyticsOrdersList(requestParameters.date, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1AnalyticsPerformanceListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AnalyticsPerformanceList(requestParameters: V1ApiV1AnalyticsPerformanceListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AnalyticsPerformanceList(requestParameters.date, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.timePeriod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate user with Firebase ID token or register new user if verified.
     * @param {V1ApiV1AuthFirebaseCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AuthFirebaseCreate(requestParameters: V1ApiV1AuthFirebaseCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AuthFirebaseCreate(requestParameters.fireBaseAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User logout view - enhanced version of api_users LogOutView
     * @param {V1ApiV1AuthLogoutCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1AuthLogoutCreate(requestParameters: V1ApiV1AuthLogoutCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1AuthLogoutCreate(requestParameters.logoutResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatAttachmentsCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatAttachmentsCreateCreate(requestParameters: V1ApiV1ChatAttachmentsCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatAttachmentsCreateCreate(requestParameters.chatAttachmentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatAttachmentsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatAttachmentsDestroy(requestParameters: V1ApiV1ChatAttachmentsDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatAttachmentsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatAttachmentsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatAttachmentsList(requestParameters: V1ApiV1ChatAttachmentsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatAttachmentsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatAttachmentsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatAttachmentsRetrieve(requestParameters: V1ApiV1ChatAttachmentsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatAttachmentsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatMessagesCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatMessagesCreateCreate(requestParameters: V1ApiV1ChatMessagesCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatMessagesCreateCreate(requestParameters.messageCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatMessagesDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatMessagesDestroy(requestParameters: V1ApiV1ChatMessagesDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatMessagesDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatMessagesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatMessagesList(requestParameters: V1ApiV1ChatMessagesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatMessagesList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatMessagesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatMessagesPartialUpdate(requestParameters: V1ApiV1ChatMessagesPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatMessagesPartialUpdate(requestParameters.id, requestParameters.patchedMessageUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatMessagesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatMessagesRetrieve(requestParameters: V1ApiV1ChatMessagesRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatMessagesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatMessagesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatMessagesUpdate(requestParameters: V1ApiV1ChatMessagesUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatMessagesUpdate(requestParameters.id, requestParameters.messageUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatParticipantsCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatParticipantsCreateCreate(requestParameters: V1ApiV1ChatParticipantsCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatParticipantsCreateCreate(requestParameters.chatParticipantCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatParticipantsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatParticipantsList(requestParameters: V1ApiV1ChatParticipantsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatParticipantsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatRoomsCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatRoomsCreateCreate(requestParameters: V1ApiV1ChatRoomsCreateCreateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatRoomsCreateCreate(requestParameters.chatRoomCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatRoomsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatRoomsList(requestParameters: V1ApiV1ChatRoomsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatRoomsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatRoomsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatRoomsPartialUpdate(requestParameters: V1ApiV1ChatRoomsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatRoomsPartialUpdate(requestParameters.id, requestParameters.patchedChatRoomUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatRoomsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatRoomsRetrieve(requestParameters: V1ApiV1ChatRoomsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatRoomsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1ChatRoomsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatRoomsUpdate(requestParameters: V1ApiV1ChatRoomsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatRoomsUpdate(requestParameters.id, requestParameters.chatRoomUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get WebSocket connection information for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ChatWebsocketInfoRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ChatWebsocketInfoRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1CoreAppVersionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreAppVersionsList(requestParameters: V1ApiV1CoreAppVersionsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreAppVersionsList(requestParameters.isActive, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.platform, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1CoreLanguagesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreLanguagesList(requestParameters: V1ApiV1CoreLanguagesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreLanguagesList(requestParameters.isActive, requestParameters.isDefault, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1CoreServiceAreasListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceAreasList(requestParameters: V1ApiV1CoreServiceAreasListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceAreasList(requestParameters.country, requestParameters.isActive, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1CoreServiceCategoriesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceCategoriesList(requestParameters: V1ApiV1CoreServiceCategoriesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceCategoriesList(requestParameters.featured, requestParameters.isActive, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1CoreServiceSubcategoriesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreServiceSubcategoriesList(requestParameters: V1ApiV1CoreServiceSubcategoriesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreServiceSubcategoriesList(requestParameters.category, requestParameters.featured, requestParameters.isActive, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1CoreSystemSettingsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1CoreSystemSettingsList(requestParameters: V1ApiV1CoreSystemSettingsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1CoreSystemSettingsList(requestParameters.category, requestParameters.isPublic, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsCreateCreate(requestParameters: V1ApiV1NotificationsCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsCreateCreate(requestParameters.notificationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsList(requestParameters: V1ApiV1NotificationsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsPartialUpdate(requestParameters: V1ApiV1NotificationsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsPartialUpdate(requestParameters.id, requestParameters.patchedNotificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsRetrieve(requestParameters: V1ApiV1NotificationsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsSettingsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsSettingsPartialUpdate(requestParameters: V1ApiV1NotificationsSettingsPartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsSettingsPartialUpdate(requestParameters.patchedNotificationSettingUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsSettingsRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsSettingsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsSettingsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsSettingsUpdate(requestParameters: V1ApiV1NotificationsSettingsUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsSettingsUpdate(requestParameters.notificationSettingUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsTemplatesCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsTemplatesCreateCreate(requestParameters: V1ApiV1NotificationsTemplatesCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsTemplatesCreateCreate(requestParameters.notificationTemplateCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsTemplatesList(requestParameters: V1ApiV1NotificationsTemplatesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsTemplatesList(requestParameters.isActive, requestParameters.notificationType, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsTemplatesPartialUpdate(requestParameters: V1ApiV1NotificationsTemplatesPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsTemplatesPartialUpdate(requestParameters.id, requestParameters.patchedNotificationTemplateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsTemplatesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsTemplatesRetrieve(requestParameters: V1ApiV1NotificationsTemplatesRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsTemplatesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsTemplatesUpdate(requestParameters: V1ApiV1NotificationsTemplatesUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsTemplatesUpdate(requestParameters.id, requestParameters.notificationTemplateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1NotificationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1NotificationsUpdate(requestParameters: V1ApiV1NotificationsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1NotificationsUpdate(requestParameters.id, requestParameters.notificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersAddonsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersAddonsList(requestParameters: V1ApiV1OrdersAddonsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersAddonsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersBidsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsCreate(requestParameters: V1ApiV1OrdersBidsCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsCreate(requestParameters.orderId, requestParameters.bidCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersBidsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersBidsList(requestParameters: V1ApiV1OrdersBidsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersBidsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersCreateCreate(requestParameters: V1ApiV1OrdersCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersCreateCreate(requestParameters.orderCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersDisputesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersDisputesCreate(requestParameters: V1ApiV1OrdersDisputesCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersDisputesCreate(requestParameters.orderId, requestParameters.orderDisputeCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersDisputesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersDisputesList(requestParameters: V1ApiV1OrdersDisputesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersDisputesList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersDisputesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersDisputesPartialUpdate(requestParameters: V1ApiV1OrdersDisputesPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersDisputesPartialUpdate(requestParameters.id, requestParameters.patchedOrderDisputeUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersDisputesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersDisputesRetrieve(requestParameters: V1ApiV1OrdersDisputesRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersDisputesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersDisputesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersDisputesUpdate(requestParameters: V1ApiV1OrdersDisputesUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersDisputesUpdate(requestParameters.id, requestParameters.orderDisputeUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersList(requestParameters: V1ApiV1OrdersListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersPartialUpdate(requestParameters: V1ApiV1OrdersPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersPartialUpdate(requestParameters.id, requestParameters.patchedOrderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersPhotosListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersPhotosList(requestParameters: V1ApiV1OrdersPhotosListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersPhotosList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersRetrieve(requestParameters: V1ApiV1OrdersRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to provide standardized exception handling for DRF views.
     * @param {V1ApiV1OrdersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1OrdersUpdate(requestParameters: V1ApiV1OrdersUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1OrdersUpdate(requestParameters.id, requestParameters.orderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to require specific group membership for class-based views.
     * @param {V1ApiV1PaymentsCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsCreateCreate(requestParameters: V1ApiV1PaymentsCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsCreateCreate(requestParameters.paymentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1PaymentsInvoicesCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsInvoicesCreateCreate(requestParameters: V1ApiV1PaymentsInvoicesCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsInvoicesCreateCreate(requestParameters.invoiceCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1PaymentsInvoicesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsInvoicesList(requestParameters: V1ApiV1PaymentsInvoicesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsInvoicesList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1PaymentsInvoicesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsInvoicesRetrieve(requestParameters: V1ApiV1PaymentsInvoicesRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsInvoicesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to require specific group membership for class-based views.
     * @param {V1ApiV1PaymentsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsList(requestParameters: V1ApiV1PaymentsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1PaymentsMethodsCreateCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsCreateCreate(requestParameters: V1ApiV1PaymentsMethodsCreateCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsCreateCreate(requestParameters.paymentMethodCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1PaymentsMethodsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsDestroy(requestParameters: V1ApiV1PaymentsMethodsDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to require specific group membership for class-based views.
     * @param {V1ApiV1PaymentsMethodsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsList(requestParameters: V1ApiV1PaymentsMethodsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsList(requestParameters.ordering, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1PaymentsMethodsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsPartialUpdate(requestParameters: V1ApiV1PaymentsMethodsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsPartialUpdate(requestParameters.id, requestParameters.patchedPaymentMethodUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1PaymentsMethodsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsRetrieve(requestParameters: V1ApiV1PaymentsMethodsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1PaymentsMethodsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsMethodsUpdate(requestParameters: V1ApiV1PaymentsMethodsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsMethodsUpdate(requestParameters.id, requestParameters.paymentMethodUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to require specific group membership for class-based views.
     * @param {V1ApiV1PaymentsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsPartialUpdate(requestParameters: V1ApiV1PaymentsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsPartialUpdate(requestParameters.id, requestParameters.patchedPaymentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to require specific group membership for class-based views.
     * @param {V1ApiV1PaymentsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsRetrieve(requestParameters: V1ApiV1PaymentsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mixin to require specific group membership for class-based views.
     * @param {V1ApiV1PaymentsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsUpdate(requestParameters: V1ApiV1PaymentsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsUpdate(requestParameters.id, requestParameters.paymentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List webhook events - function-based version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsWebhooksEventsRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsWebhooksEventsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retry processing a webhook event - function-based version.
     * @param {V1ApiV1PaymentsWebhooksEventsRetryCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsWebhooksEventsRetryCreate(requestParameters: V1ApiV1PaymentsWebhooksEventsRetryCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsWebhooksEventsRetryCreate(requestParameters.eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple Stripe webhook handler - function-based version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1PaymentsWebhooksStripeDrfCreate(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1PaymentsWebhooksStripeDrfCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload profile image
     * @param {V1ApiV1ProfileCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ProfileCreate(requestParameters: V1ApiV1ProfileCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ProfileCreate(requestParameters.userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset profile image to default by removing uploaded photo.  This clears the stored ImageField `photo`. The `photo_url` (e.g., Firebase avatar) remains unchanged. Frontend should use `photo_url` as fallback.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ProfileDestroy(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ProfileDestroy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User profile view with image upload
     * @param {V1ApiV1ProfilePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ProfilePartialUpdate(requestParameters: V1ApiV1ProfilePartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ProfilePartialUpdate(requestParameters.patchedUserUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User profile view with image upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ProfileRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ProfileRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User profile view with image upload
     * @param {V1ApiV1ProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ProfileUpdate(requestParameters: V1ApiV1ProfileUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ProfileUpdate(requestParameters.userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get review analytics.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsAnalyticsRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsAnalyticsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List and create reviews.
     * @param {V1ApiV1ReviewsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsCreate(requestParameters: V1ApiV1ReviewsCreateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsCreate(requestParameters.reviewCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete specific review.
     * @param {V1ApiV1ReviewsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsDestroy(requestParameters: V1ApiV1ReviewsDestroyRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List and create reviews.
     * @param {V1ApiV1ReviewsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsList(requestParameters: V1ApiV1ReviewsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsList(requestParameters.isVerified, requestParameters.ordering, requestParameters.overallRating, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get reviews for a specific order.
     * @param {V1ApiV1ReviewsOrderListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsOrderList(requestParameters: V1ApiV1ReviewsOrderListRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsOrderList(requestParameters.orderId, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete specific review.
     * @param {V1ApiV1ReviewsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsPartialUpdate(requestParameters: V1ApiV1ReviewsPartialUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsPartialUpdate(requestParameters.id, requestParameters.patchedReviewUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get reviews for a specific service provider.
     * @param {V1ApiV1ReviewsProviderListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsProviderList(requestParameters: V1ApiV1ReviewsProviderListRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsProviderList(requestParameters.providerId, requestParameters.isVerified, requestParameters.ordering, requestParameters.overallRating, requestParameters.page, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete specific review.
     * @param {V1ApiV1ReviewsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsRetrieve(requestParameters: V1ApiV1ReviewsRetrieveRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve, update, and delete specific review.
     * @param {V1ApiV1ReviewsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1ReviewsUpdate(requestParameters: V1ApiV1ReviewsUpdateRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1ReviewsUpdate(requestParameters.id, requestParameters.reviewUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simple global search across all content types.
     * @param {V1ApiV1SearchGlobalListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1SearchGlobalList(requestParameters: V1ApiV1SearchGlobalListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1SearchGlobalList(requestParameters.city, requestParameters.maxBudget, requestParameters.minBudget, requestParameters.minRating, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.q, requestParameters.serviceCategory, requestParameters.type, requestParameters.urgency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search specifically for orders (job vacancies).
     * @param {V1ApiV1SearchOrdersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1SearchOrdersList(requestParameters: V1ApiV1SearchOrdersListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1SearchOrdersList(requestParameters.city, requestParameters.maxBudget, requestParameters.minBudget, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.q, requestParameters.serviceCategory, requestParameters.urgency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search specifically for service providers.
     * @param {V1ApiV1SearchProvidersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1SearchProvidersList(requestParameters: V1ApiV1SearchProvidersListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1SearchProvidersList(requestParameters.city, requestParameters.minRating, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1UsersClientPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersClientPartialUpdate(requestParameters: V1ApiV1UsersClientPartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersClientPartialUpdate(requestParameters.patchedClientUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersClientRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersClientRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1UsersClientUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersClientUpdate(requestParameters: V1ApiV1UsersClientUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersClientUpdate(requestParameters.clientUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update client profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersClientUpdateCreate(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersClientUpdateCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1UsersClientsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersClientsList(requestParameters: V1ApiV1UsersClientsListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersClientsList(requestParameters.createdAt, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all users - not in api_users, useful for admin
     * @param {V1ApiV1UsersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersList(requestParameters: V1ApiV1UsersListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersList(requestParameters.blocked, requestParameters.isActive, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.userType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1UsersProfilePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProfilePartialUpdate(requestParameters: V1ApiV1UsersProfilePartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProfilePartialUpdate(requestParameters.patchedUserProfileUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProfileRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProfileRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1UsersProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProfileUpdate(requestParameters: V1ApiV1UsersProfileUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProfileUpdate(requestParameters.userProfileUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProfileUpdateCreate(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProfileUpdateCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1UsersProfilesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProfilesList(requestParameters: V1ApiV1UsersProfilesListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProfilesList(requestParameters.gender, requestParameters.isVerified, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, requestParameters.userType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1UsersProviderPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProviderPartialUpdate(requestParameters: V1ApiV1UsersProviderPartialUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProviderPartialUpdate(requestParameters.patchedServiceProviderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProviderRetrieve(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProviderRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1UsersProviderUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProviderUpdate(requestParameters: V1ApiV1UsersProviderUpdateRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProviderUpdate(requestParameters.serviceProviderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update service provider profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProviderUpdateCreate(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProviderUpdateCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1ApiV1UsersProvidersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public v1UsersProvidersList(requestParameters: V1ApiV1UsersProvidersListRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).v1UsersProvidersList(requestParameters.isAvailable, requestParameters.isVerifiedProvider, requestParameters.ordering, requestParameters.page, requestParameters.pageSize, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }
}


